{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nconst util = require(\"./util\");\n\nconst binarySearch = require(\"./binary-search\");\n\nconst ArraySet = require(\"./array-set\").ArraySet;\n\nconst base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\n\n\nconst readWasm = require(\"../lib/read-wasm\");\n\nconst wasm = require(\"./wasm\");\n\nconst INTERNAL = Symbol(\"smcInternal\");\n\nclass SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  static initialize(opts) {\n    readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n  }\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return _factoryBSM(aSourceMap, aSourceMapURL);\n  }\n  /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */\n\n\n  static async with(rawSourceMap, sourceMapUrl, f) {\n    const consumer = await new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n\n    try {\n      return await f(consumer);\n    } finally {\n      consumer.destroy();\n    }\n  }\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n\n\n  eachMapping(aCallback, aContext, aOrder) {\n    throw new Error(\"Subclasses must implement eachMapping\");\n  }\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */\n\n\n  allGeneratedPositionsFor(aArgs) {\n    throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n  }\n\n  destroy() {\n    throw new Error(\"Subclasses must implement destroy\");\n  }\n\n}\n/**\n * The version of the source mapping spec that we are consuming.\n */\n\n\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\nexports.SourceMapConsumer = SourceMapConsumer;\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\n\nclass BasicSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sources = util.getArg(sourceMap, \"sources\").map(String); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n\n      const names = util.getArg(sourceMap, \"names\", []);\n      const sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      const sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      const mappings = util.getArg(sourceMap, \"mappings\");\n      const file = util.getArg(sourceMap, \"file\", null); // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sourceLookupCache = new Map(); // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n      that._absoluteSources = ArraySet.fromArray(that._sources.toArray().map(function (s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n      }), true);\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n      return wasm().then(w => {\n        that._wasm = w;\n        return that;\n      });\n    });\n  }\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n\n\n  _findSourceIndex(aSource) {\n    // In the most common usecases, we'll be constantly looking up the index for the same source\n    // files, so we cache the index lookup to avoid constantly recomputing the full URLs.\n    const cachedIndex = this._sourceLookupCache.get(aSource);\n\n    if (typeof cachedIndex === \"number\") {\n      return cachedIndex;\n    } // Treat the source as map-relative overall by default.\n\n\n    const sourceAsMapRelative = util.computeSourceURL(null, aSource, this._sourceMapURL);\n\n    if (this._absoluteSources.has(sourceAsMapRelative)) {\n      const index = this._absoluteSources.indexOf(sourceAsMapRelative);\n\n      this._sourceLookupCache.set(aSource, index);\n\n      return index;\n    } // Fall back to treating the source as sourceRoot-relative.\n\n\n    const sourceAsSourceRootRelative = util.computeSourceURL(this.sourceRoot, aSource, this._sourceMapURL);\n\n    if (this._absoluteSources.has(sourceAsSourceRootRelative)) {\n      const index = this._absoluteSources.indexOf(sourceAsSourceRootRelative);\n\n      this._sourceLookupCache.set(aSource, index);\n\n      return index;\n    } // To avoid this cache growing forever, we do not cache lookup misses.\n\n\n    return -1;\n  }\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */\n\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return new BasicSourceMapConsumer(aSourceMap.toString());\n  }\n\n  get sources() {\n    return this._absoluteSources.toArray();\n  }\n\n  _getMappingsPtr() {\n    if (this._mappingsPtr === 0) {\n      this._parseMappings();\n    }\n\n    return this._mappingsPtr;\n  }\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n\n\n  _parseMappings() {\n    const aStr = this._mappings;\n    const size = aStr.length;\n\n    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n\n    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n\n    for (let i = 0; i < size; i++) {\n      mappingsBuf[i] = aStr.charCodeAt(i);\n    }\n\n    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n    if (!mappingsPtr) {\n      const error = this._wasm.exports.get_last_error();\n\n      let msg = `Error parsing mappings (code ${error}): `; // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n\n      switch (error) {\n        case 1:\n          msg += \"the mappings contained a negative line, column, source index, or name index\";\n          break;\n\n        case 2:\n          msg += \"the mappings contained a number larger than 2**32\";\n          break;\n\n        case 3:\n          msg += \"reached EOF while in the middle of parsing a VLQ\";\n          break;\n\n        case 4:\n          msg += \"invalid base 64 character while parsing a VLQ\";\n          break;\n\n        default:\n          msg += \"unknown error code\";\n          break;\n      }\n\n      throw new Error(msg);\n    }\n\n    this._mappingsPtr = mappingsPtr;\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    this._wasm.withMappingCallback(mapping => {\n      if (mapping.source !== null) {\n        mapping.source = this._absoluteSources.at(mapping.source);\n\n        if (mapping.name !== null) {\n          mapping.name = this._names.at(mapping.name);\n        }\n      }\n\n      if (this._computedColumnSpans && mapping.lastGeneratedColumn === null) {\n        mapping.lastGeneratedColumn = Infinity;\n      }\n\n      aCallback.call(context, mapping);\n    }, () => {\n      switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          this._wasm.exports.by_generated_location(this._getMappingsPtr());\n\n          break;\n\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          this._wasm.exports.by_original_location(this._getMappingsPtr());\n\n          break;\n\n        default:\n          throw new Error(\"Unknown order of iteration.\");\n      }\n    });\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    const originalLine = util.getArg(aArgs, \"line\");\n    const originalColumn = aArgs.column || 0;\n    source = this._findSourceIndex(source);\n\n    if (source < 0) {\n      return [];\n    }\n\n    if (originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    this._wasm.withMappingCallback(m => {\n      let lastColumn = m.lastGeneratedColumn;\n\n      if (this._computedColumnSpans && lastColumn === null) {\n        lastColumn = Infinity;\n      }\n\n      mappings.push({\n        line: m.generatedLine,\n        column: m.generatedColumn,\n        lastColumn\n      });\n    }, () => {\n      this._wasm.exports.all_generated_locations_for(this._getMappingsPtr(), source, originalLine - 1, \"column\" in aArgs, originalColumn);\n    });\n\n    return mappings;\n  }\n\n  destroy() {\n    if (this._mappingsPtr !== 0) {\n      this._wasm.exports.free_mappings(this._mappingsPtr);\n\n      this._mappingsPtr = 0;\n    }\n  }\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n\n\n  computeColumnSpans() {\n    if (this._computedColumnSpans) {\n      return;\n    }\n\n    this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n\n    this._computedColumnSpans = true;\n  }\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n\n\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.generatedLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.generatedColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.original_location_for(this._getMappingsPtr(), needle.generatedLine - 1, needle.generatedColumn, bias);\n    });\n\n    if (mapping) {\n      if (mapping.generatedLine === needle.generatedLine) {\n        let source = util.getArg(mapping, \"source\", null);\n\n        if (source !== null) {\n          source = this._absoluteSources.at(source);\n        }\n\n        let name = util.getArg(mapping, \"name\", null);\n\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n\n        return {\n          source,\n          line: util.getArg(mapping, \"originalLine\", null),\n          column: util.getArg(mapping, \"originalColumn\", null),\n          name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  }\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n\n\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n\n    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {\n      return sc == null;\n    });\n  }\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n\n\n  sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    const index = this._findSourceIndex(aSource);\n\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    } // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n\n\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n\n\n  generatedPositionFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    const needle = {\n      source,\n      originalLine: util.getArg(aArgs, \"line\"),\n      originalColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.generated_location_for(this._getMappingsPtr(), needle.source, needle.originalLine - 1, needle.originalColumn, bias);\n    });\n\n    if (mapping) {\n      if (mapping.source === needle.source) {\n        let lastColumn = mapping.lastGeneratedColumn;\n\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n\n        return {\n          line: util.getArg(mapping, \"generatedLine\", null),\n          column: util.getArg(mapping, \"generatedColumn\", null),\n          lastColumn\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n\n}\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\n\nclass IndexedSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      let lastOffset = {\n        line: -1,\n        column: 0\n      };\n      return Promise.all(sections.map(s => {\n        if (s.url) {\n          // The url field will require support for asynchronicity.\n          // See https://github.com/mozilla/source-map/issues/16\n          throw new Error(\"Support for url field in sections not implemented.\");\n        }\n\n        const offset = util.getArg(s, \"offset\");\n        const offsetLine = util.getArg(offset, \"line\");\n        const offsetColumn = util.getArg(offset, \"column\");\n\n        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n          throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n\n        lastOffset = offset;\n        const cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n        return cons.then(consumer => {\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer\n          };\n        });\n      })).then(s => {\n        that._sections = s;\n        return that;\n      });\n    });\n  }\n  /**\n   * The list of original sources.\n   */\n\n\n  get sources() {\n    const sources = [];\n\n    for (let i = 0; i < this._sections.length; i++) {\n      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n\n    return sources;\n  }\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n\n\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    }; // Find the section containing the generated position we're trying to map\n    // to an original position.\n\n    const sectionIndex = binarySearch.search(needle, this._sections, function (aNeedle, section) {\n      const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n\n      if (cmp) {\n        return cmp;\n      }\n\n      return aNeedle.generatedColumn - section.generatedOffset.generatedColumn;\n    });\n    const section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n      bias: aArgs.bias\n    });\n  }\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n\n\n  hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  }\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n\n\n  sourceContentFor(aSource, nullOnMissing) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n      const content = section.consumer.sourceContentFor(aSource, true);\n\n      if (content) {\n        return content;\n      }\n    }\n\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  _findSectionIndex(source) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const {\n        consumer\n      } = this._sections[i];\n\n      if (consumer._findSourceIndex(source) !== -1) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n\n\n  generatedPositionFor(aArgs) {\n    const index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n\n    const section = index >= 0 ? this._sections[index] : null;\n    const nextSection = index >= 0 && index + 1 < this._sections.length ? this._sections[index + 1] : null;\n    const generatedPosition = section && section.consumer.generatedPositionFor(aArgs);\n\n    if (generatedPosition && generatedPosition.line !== null) {\n      const lineShift = section.generatedOffset.generatedLine - 1;\n      const columnShift = section.generatedOffset.generatedColumn - 1;\n\n      if (generatedPosition.line === 1) {\n        generatedPosition.column += columnShift;\n\n        if (typeof generatedPosition.lastColumn === \"number\") {\n          generatedPosition.lastColumn += columnShift;\n        }\n      }\n\n      if (generatedPosition.lastColumn === Infinity && nextSection && generatedPosition.line === nextSection.generatedOffset.generatedLine) {\n        generatedPosition.lastColumn = nextSection.generatedOffset.generatedColumn - 2;\n      }\n\n      generatedPosition.line += lineShift;\n      return generatedPosition;\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    const index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n\n    const section = index >= 0 ? this._sections[index] : null;\n    const nextSection = index >= 0 && index + 1 < this._sections.length ? this._sections[index + 1] : null;\n    if (!section) return [];\n    return section.consumer.allGeneratedPositionsFor(aArgs).map(generatedPosition => {\n      const lineShift = section.generatedOffset.generatedLine - 1;\n      const columnShift = section.generatedOffset.generatedColumn - 1;\n\n      if (generatedPosition.line === 1) {\n        generatedPosition.column += columnShift;\n\n        if (typeof generatedPosition.lastColumn === \"number\") {\n          generatedPosition.lastColumn += columnShift;\n        }\n      }\n\n      if (generatedPosition.lastColumn === Infinity && nextSection && generatedPosition.line === nextSection.generatedOffset.generatedLine) {\n        generatedPosition.lastColumn = nextSection.generatedOffset.generatedColumn - 2;\n      }\n\n      generatedPosition.line += lineShift;\n      return generatedPosition;\n    });\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    this._sections.forEach((section, index) => {\n      const nextSection = index + 1 < this._sections.length ? this._sections[index + 1] : null;\n      const {\n        generatedOffset\n      } = section;\n      const lineShift = generatedOffset.generatedLine - 1;\n      const columnShift = generatedOffset.generatedColumn - 1;\n      section.consumer.eachMapping(function (mapping) {\n        if (mapping.generatedLine === 1) {\n          mapping.generatedColumn += columnShift;\n\n          if (typeof mapping.lastGeneratedColumn === \"number\") {\n            mapping.lastGeneratedColumn += columnShift;\n          }\n        }\n\n        if (mapping.lastGeneratedColumn === Infinity && nextSection && mapping.generatedLine === nextSection.generatedOffset.generatedLine) {\n          mapping.lastGeneratedColumn = nextSection.generatedOffset.generatedColumn - 2;\n        }\n\n        mapping.generatedLine += lineShift;\n        aCallback.call(this, mapping);\n      }, aContext, aOrder);\n    });\n  }\n\n  computeColumnSpans() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.computeColumnSpans();\n    }\n  }\n\n  destroy() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.destroy();\n    }\n  }\n\n}\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\n\nfunction _factory(aSourceMap, aSourceMapURL) {\n  let sourceMap = aSourceMap;\n\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  const consumer = sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}","map":{"version":3,"sources":["C:/xampp/public_html/vamo/interface2/node_modules/@next/react-dev-overlay/node_modules/source-map/lib/source-map-consumer.js"],"names":["util","require","binarySearch","ArraySet","base64VLQ","readWasm","wasm","INTERNAL","Symbol","SourceMapConsumer","constructor","aSourceMap","aSourceMapURL","Promise","resolve","_factory","initialize","opts","fromSourceMap","_factoryBSM","with","rawSourceMap","sourceMapUrl","f","consumer","destroy","eachMapping","aCallback","aContext","aOrder","Error","allGeneratedPositionsFor","aArgs","prototype","_version","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","exports","BasicSourceMapConsumer","then","that","sourceMap","parseSourceMapInput","version","getArg","sources","map","String","names","sourceRoot","sourcesContent","mappings","file","_sourceLookupCache","Map","_names","fromArray","_sources","_absoluteSources","toArray","s","computeSourceURL","_mappings","_sourceMapURL","_computedColumnSpans","_mappingsPtr","_wasm","w","_findSourceIndex","aSource","cachedIndex","get","sourceAsMapRelative","has","index","indexOf","set","sourceAsSourceRootRelative","toString","_getMappingsPtr","_parseMappings","aStr","size","length","mappingsBufPtr","allocate_mappings","mappingsBuf","Uint8Array","memory","buffer","i","charCodeAt","mappingsPtr","parse_mappings","error","get_last_error","msg","context","order","withMappingCallback","mapping","source","at","name","lastGeneratedColumn","Infinity","call","by_generated_location","by_original_location","originalLine","originalColumn","column","m","lastColumn","push","line","generatedLine","generatedColumn","all_generated_locations_for","free_mappings","computeColumnSpans","compute_column_spans","originalPositionFor","needle","bias","original_location_for","hasContentsOfAllSources","some","sc","sourceContentFor","nullOnMissing","generatedPositionFor","generated_location_for","IndexedSourceMapConsumer","sections","lastOffset","all","url","offset","offsetLine","offsetColumn","cons","generatedOffset","_sections","j","sectionIndex","search","aNeedle","section","cmp","every","content","_findSectionIndex","nextSection","generatedPosition","lineShift","columnShift","forEach"],"mappings":"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","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\nconst binarySearch = require(\"./binary-search\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\nconst readWasm = require(\"../lib/read-wasm\");\nconst wasm = require(\"./wasm\");\n\nconst INTERNAL = Symbol(\"smcInternal\");\n\nclass SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  static initialize(opts) {\n    readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n  }\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return _factoryBSM(aSourceMap, aSourceMapURL);\n  }\n\n  /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */\n  static async with(rawSourceMap, sourceMapUrl, f) {\n    const consumer = await new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n    try {\n      return await f(consumer);\n    } finally {\n      consumer.destroy();\n    }\n  }\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  eachMapping(aCallback, aContext, aOrder) {\n    throw new Error(\"Subclasses must implement eachMapping\");\n  }\n\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */\n  allGeneratedPositionsFor(aArgs) {\n    throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n  }\n\n  destroy() {\n    throw new Error(\"Subclasses must implement destroy\");\n  }\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nclass BasicSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sources = util.getArg(sourceMap, \"sources\").map(String);\n      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n      const names = util.getArg(sourceMap, \"names\", []);\n      const sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      const sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      const mappings = util.getArg(sourceMap, \"mappings\");\n      const file = util.getArg(sourceMap, \"file\", null);\n\n      // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sourceLookupCache = new Map();\n\n      // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n\n      that._absoluteSources = ArraySet.fromArray(that._sources.toArray().map(function(s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n      }), true);\n\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n\n      return wasm().then(w => {\n        that._wasm = w;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n  _findSourceIndex(aSource) {\n    // In the most common usecases, we'll be constantly looking up the index for the same source\n    // files, so we cache the index lookup to avoid constantly recomputing the full URLs.\n    const cachedIndex = this._sourceLookupCache.get(aSource);\n    if (typeof cachedIndex === \"number\") {\n      return cachedIndex;\n    }\n\n    // Treat the source as map-relative overall by default.\n    const sourceAsMapRelative = util.computeSourceURL(null, aSource, this._sourceMapURL);\n    if (this._absoluteSources.has(sourceAsMapRelative)) {\n      const index = this._absoluteSources.indexOf(sourceAsMapRelative);\n      this._sourceLookupCache.set(aSource, index);\n      return index;\n    }\n\n    // Fall back to treating the source as sourceRoot-relative.\n    const sourceAsSourceRootRelative = util.computeSourceURL(this.sourceRoot, aSource, this._sourceMapURL);\n    if (this._absoluteSources.has(sourceAsSourceRootRelative)) {\n      const index = this._absoluteSources.indexOf(sourceAsSourceRootRelative);\n      this._sourceLookupCache.set(aSource, index);\n      return index;\n    }\n\n    // To avoid this cache growing forever, we do not cache lookup misses.\n    return -1;\n  }\n\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return new BasicSourceMapConsumer(aSourceMap.toString());\n  }\n\n  get sources() {\n    return this._absoluteSources.toArray();\n  }\n\n  _getMappingsPtr() {\n    if (this._mappingsPtr === 0) {\n      this._parseMappings();\n    }\n\n    return this._mappingsPtr;\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings() {\n    const aStr = this._mappings;\n    const size = aStr.length;\n\n    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n    for (let i = 0; i < size; i++) {\n      mappingsBuf[i] = aStr.charCodeAt(i);\n    }\n\n    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n    if (!mappingsPtr) {\n      const error = this._wasm.exports.get_last_error();\n      let msg = `Error parsing mappings (code ${error}): `;\n\n      // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n      switch (error) {\n        case 1:\n          msg += \"the mappings contained a negative line, column, source index, or name index\";\n          break;\n        case 2:\n          msg += \"the mappings contained a number larger than 2**32\";\n          break;\n        case 3:\n          msg += \"reached EOF while in the middle of parsing a VLQ\";\n          break;\n        case 4:\n          msg += \"invalid base 64 character while parsing a VLQ\";\n          break;\n        default:\n          msg += \"unknown error code\";\n          break;\n      }\n\n      throw new Error(msg);\n    }\n\n    this._mappingsPtr = mappingsPtr;\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    this._wasm.withMappingCallback(\n      mapping => {\n        if (mapping.source !== null) {\n          mapping.source = this._absoluteSources.at(mapping.source);\n\n          if (mapping.name !== null) {\n            mapping.name = this._names.at(mapping.name);\n          }\n        }\n        if (this._computedColumnSpans && mapping.lastGeneratedColumn === null) {\n          mapping.lastGeneratedColumn = Infinity;\n        }\n\n        aCallback.call(context, mapping);\n      },\n      () => {\n        switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          this._wasm.exports.by_generated_location(this._getMappingsPtr());\n          break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          this._wasm.exports.by_original_location(this._getMappingsPtr());\n          break;\n        default:\n          throw new Error(\"Unknown order of iteration.\");\n        }\n      }\n    );\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    const originalLine = util.getArg(aArgs, \"line\");\n    const originalColumn = aArgs.column || 0;\n\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return [];\n    }\n\n    if (originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    this._wasm.withMappingCallback(\n      m => {\n        let lastColumn = m.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        mappings.push({\n          line: m.generatedLine,\n          column: m.generatedColumn,\n          lastColumn,\n        });\n      }, () => {\n        this._wasm.exports.all_generated_locations_for(\n          this._getMappingsPtr(),\n          source,\n          originalLine - 1,\n          \"column\" in aArgs,\n          originalColumn\n        );\n      }\n    );\n\n    return mappings;\n  }\n\n  destroy() {\n    if (this._mappingsPtr !== 0) {\n      this._wasm.exports.free_mappings(this._mappingsPtr);\n      this._mappingsPtr = 0;\n    }\n  }\n\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n  computeColumnSpans() {\n    if (this._computedColumnSpans) {\n      return;\n    }\n\n    this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n    this._computedColumnSpans = true;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.generatedLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.generatedColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.original_location_for(\n        this._getMappingsPtr(),\n        needle.generatedLine - 1,\n        needle.generatedColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.generatedLine === needle.generatedLine) {\n        let source = util.getArg(mapping, \"source\", null);\n        if (source !== null) {\n          source = this._absoluteSources.at(source);\n        }\n\n        let name = util.getArg(mapping, \"name\", null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n\n        return {\n          source,\n          line: util.getArg(mapping, \"originalLine\", null),\n          column: util.getArg(mapping, \"originalColumn\", null),\n          name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function(sc) { return sc == null; });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    const index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    const needle = {\n      source,\n      originalLine: util.getArg(aArgs, \"line\"),\n      originalColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.generated_location_for(\n        this._getMappingsPtr(),\n        needle.source,\n        needle.originalLine - 1,\n        needle.originalColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.source === needle.source) {\n        let lastColumn = mapping.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        return {\n          line: util.getArg(mapping, \"generatedLine\", null),\n          column: util.getArg(mapping, \"generatedColumn\", null),\n          lastColumn,\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n}\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nclass IndexedSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      let lastOffset = {\n        line: -1,\n        column: 0\n      };\n      return Promise.all(sections.map(s => {\n        if (s.url) {\n          // The url field will require support for asynchronicity.\n          // See https://github.com/mozilla/source-map/issues/16\n          throw new Error(\"Support for url field in sections not implemented.\");\n        }\n        const offset = util.getArg(s, \"offset\");\n        const offsetLine = util.getArg(offset, \"line\");\n        const offsetColumn = util.getArg(offset, \"column\");\n\n        if (offsetLine < lastOffset.line ||\n            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n          throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n        lastOffset = offset;\n\n        const cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n        return cons.then(consumer => {\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer\n          };\n        });\n      })).then(s => {\n        that._sections = s;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * The list of original sources.\n   */\n  get sources() {\n    const sources = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    const sectionIndex = binarySearch.search(needle, this._sections,\n      function(aNeedle, section) {\n        const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (aNeedle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    const section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    return this._sections.every(function(s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  _findSectionIndex(source) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const { consumer } = this._sections[i];\n      if (consumer._findSourceIndex(source) !== -1) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    const index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n    const section = index >= 0 ? this._sections[index] : null;\n    const nextSection =\n      index >= 0 && index + 1 < this._sections.length\n        ? this._sections[index + 1]\n        : null;\n\n    const generatedPosition =\n      section && section.consumer.generatedPositionFor(aArgs);\n    if (generatedPosition && generatedPosition.line !== null) {\n      const lineShift = section.generatedOffset.generatedLine - 1;\n      const columnShift = section.generatedOffset.generatedColumn - 1;\n\n      if (generatedPosition.line === 1) {\n        generatedPosition.column += columnShift;\n        if (typeof generatedPosition.lastColumn === \"number\") {\n          generatedPosition.lastColumn += columnShift;\n        }\n      }\n\n      if (\n        generatedPosition.lastColumn === Infinity &&\n        nextSection &&\n        generatedPosition.line === nextSection.generatedOffset.generatedLine\n      ) {\n        generatedPosition.lastColumn =\n          nextSection.generatedOffset.generatedColumn - 2;\n      }\n      generatedPosition.line += lineShift;\n\n      return generatedPosition;\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    const index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n    const section = index >= 0 ? this._sections[index] : null;\n    const nextSection =\n      index >= 0 && index + 1 < this._sections.length\n        ? this._sections[index + 1]\n        : null;\n\n    if (!section) return [];\n\n    return section.consumer.allGeneratedPositionsFor(aArgs).map(\n      generatedPosition => {\n        const lineShift = section.generatedOffset.generatedLine - 1;\n        const columnShift = section.generatedOffset.generatedColumn - 1;\n\n        if (generatedPosition.line === 1) {\n          generatedPosition.column += columnShift;\n          if (typeof generatedPosition.lastColumn === \"number\") {\n            generatedPosition.lastColumn += columnShift;\n          }\n        }\n\n        if (\n          generatedPosition.lastColumn === Infinity &&\n          nextSection &&\n          generatedPosition.line === nextSection.generatedOffset.generatedLine\n        ) {\n          generatedPosition.lastColumn =\n            nextSection.generatedOffset.generatedColumn - 2;\n        }\n        generatedPosition.line += lineShift;\n\n        return generatedPosition;\n      }\n    );\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    this._sections.forEach((section, index) => {\n      const nextSection =\n        index + 1 < this._sections.length\n          ? this._sections[index + 1]\n          : null;\n      const { generatedOffset } = section;\n\n      const lineShift = generatedOffset.generatedLine - 1;\n      const columnShift = generatedOffset.generatedColumn - 1;\n\n      section.consumer.eachMapping(function(mapping) {\n        if (mapping.generatedLine === 1) {\n          mapping.generatedColumn += columnShift;\n\n          if (typeof mapping.lastGeneratedColumn === \"number\") {\n            mapping.lastGeneratedColumn += columnShift;\n          }\n        }\n\n        if (\n          mapping.lastGeneratedColumn === Infinity &&\n          nextSection &&\n          mapping.generatedLine === nextSection.generatedOffset.generatedLine\n        ) {\n          mapping.lastGeneratedColumn =\n            nextSection.generatedOffset.generatedColumn - 2;\n        }\n        mapping.generatedLine += lineShift;\n\n        aCallback.call(this, mapping);\n      }, aContext, aOrder);\n    });\n  }\n\n  computeColumnSpans() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.computeColumnSpans();\n    }\n  }\n\n  destroy() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.destroy();\n    }\n  }\n}\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\nfunction _factory(aSourceMap, aSourceMapURL) {\n  let sourceMap = aSourceMap;\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  const consumer = sourceMap.sections != null\n      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n"]},"metadata":{},"sourceType":"script"}