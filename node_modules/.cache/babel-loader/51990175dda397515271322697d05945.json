{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findPageFile = findPageFile;\n\nvar _path = require(\"path\");\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _log = require(\"../../build/output/log\");\n\nvar _fs = require(\"fs\");\n\nvar _normalizePagePath = require(\"../normalize-page-path\");\n\nvar _fileExists = require(\"../../lib/file-exists\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nasync function isTrueCasePagePath(pagePath, pagesDir) {\n  const pageSegments = (0, _path).normalize(pagePath).split(_path.sep).filter(Boolean);\n  const segmentExistsPromises = pageSegments.map(async (segment, i) => {\n    const segmentParentDir = (0, _path).join(pagesDir, ...pageSegments.slice(0, i));\n    const parentDirEntries = await _fs.promises.readdir(segmentParentDir);\n    return parentDirEntries.includes(segment);\n  });\n  return (await Promise.all(segmentExistsPromises)).every(Boolean);\n}\n\nasync function findPageFile(rootDir, normalizedPagePath, pageExtensions) {\n  const foundPagePaths = [];\n  const page = (0, _normalizePagePath).denormalizePagePath(normalizedPagePath);\n\n  for (const extension of pageExtensions) {\n    if (!normalizedPagePath.endsWith('/index')) {\n      const relativePagePath = `${page}.${extension}`;\n      const pagePath = (0, _path).join(rootDir, relativePagePath);\n\n      if (await (0, _fileExists).fileExists(pagePath)) {\n        foundPagePaths.push(relativePagePath);\n      }\n    }\n\n    const relativePagePathWithIndex = (0, _path).join(page, `index.${extension}`);\n    const pagePathWithIndex = (0, _path).join(rootDir, relativePagePathWithIndex);\n\n    if (await (0, _fileExists).fileExists(pagePathWithIndex)) {\n      foundPagePaths.push(relativePagePathWithIndex);\n    }\n  }\n\n  if (foundPagePaths.length < 1) {\n    return null;\n  }\n\n  if (!(await isTrueCasePagePath(foundPagePaths[0], rootDir))) {\n    return null;\n  }\n\n  if (foundPagePaths.length > 1) {\n    (0, _log).warn(`Duplicate page detected. ${_chalk.default.cyan((0, _path).join('pages', foundPagePaths[0]))} and ${_chalk.default.cyan((0, _path).join('pages', foundPagePaths[1]))} both resolve to ${_chalk.default.cyan(normalizedPagePath)}.`);\n  }\n\n  return foundPagePaths[0];\n}","map":{"version":3,"sources":["../../../server/lib/find-page-file.ts"],"names":[],"mappings":"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","sourcesContent":["import { join, sep as pathSeparator, normalize } from 'path'\nimport chalk from 'chalk'\nimport { warn } from '../../build/output/log'\nimport { promises } from 'fs'\nimport { denormalizePagePath } from '../normalize-page-path'\nimport { fileExists } from '../../lib/file-exists'\n\nasync function isTrueCasePagePath(pagePath: string, pagesDir: string) {\n  const pageSegments = normalize(pagePath).split(pathSeparator).filter(Boolean)\n\n  const segmentExistsPromises = pageSegments.map(async (segment, i) => {\n    const segmentParentDir = join(pagesDir, ...pageSegments.slice(0, i))\n    const parentDirEntries = await promises.readdir(segmentParentDir)\n    return parentDirEntries.includes(segment)\n  })\n\n  return (await Promise.all(segmentExistsPromises)).every(Boolean)\n}\n\nexport async function findPageFile(\n  rootDir: string,\n  normalizedPagePath: string,\n  pageExtensions: string[]\n): Promise<string | null> {\n  const foundPagePaths: string[] = []\n\n  const page = denormalizePagePath(normalizedPagePath)\n\n  for (const extension of pageExtensions) {\n    if (!normalizedPagePath.endsWith('/index')) {\n      const relativePagePath = `${page}.${extension}`\n      const pagePath = join(rootDir, relativePagePath)\n\n      if (await fileExists(pagePath)) {\n        foundPagePaths.push(relativePagePath)\n      }\n    }\n\n    const relativePagePathWithIndex = join(page, `index.${extension}`)\n    const pagePathWithIndex = join(rootDir, relativePagePathWithIndex)\n    if (await fileExists(pagePathWithIndex)) {\n      foundPagePaths.push(relativePagePathWithIndex)\n    }\n  }\n\n  if (foundPagePaths.length < 1) {\n    return null\n  }\n\n  if (!(await isTrueCasePagePath(foundPagePaths[0], rootDir))) {\n    return null\n  }\n\n  if (foundPagePaths.length > 1) {\n    warn(\n      `Duplicate page detected. ${chalk.cyan(\n        join('pages', foundPagePaths[0])\n      )} and ${chalk.cyan(\n        join('pages', foundPagePaths[1])\n      )} both resolve to ${chalk.cyan(normalizedPagePath)}.`\n    )\n  }\n\n  return foundPagePaths[0]\n}\n"]},"metadata":{},"sourceType":"script"}