{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifyTypeScriptSetup = verifyTypeScriptSetup;\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _hasNecessaryDependencies = require(\"./has-necessary-dependencies\");\n\nvar _semver = _interopRequireDefault(require(\"next/dist/compiled/semver\"));\n\nvar _compileError = require(\"./compile-error\");\n\nvar _fatalError = require(\"./fatal-error\");\n\nvar log = _interopRequireWildcard(require(\"../build/output/log\"));\n\nvar _getTypeScriptIntent = require(\"./typescript/getTypeScriptIntent\");\n\nvar _writeAppTypeDeclarations = require(\"./typescript/writeAppTypeDeclarations\");\n\nvar _writeConfigurationDefaults = require(\"./typescript/writeConfigurationDefaults\");\n\nvar _missingDependencyError = require(\"./typescript/missingDependencyError\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nconst requiredPackages = [{\n  file: 'typescript',\n  pkg: 'typescript'\n}, {\n  file: '@types/react/index.d.ts',\n  pkg: '@types/react'\n}, {\n  file: '@types/node/index.d.ts',\n  pkg: '@types/node'\n}];\n\nasync function verifyTypeScriptSetup(dir, pagesDir, typeCheckPreflight, imageImportsEnabled, cacheDir) {\n  const tsConfigPath = _path.default.join(dir, 'tsconfig.json');\n\n  try {\n    var ref; // Check if the project uses TypeScript:\n\n    const intent = await (0, _getTypeScriptIntent).getTypeScriptIntent(dir, pagesDir);\n\n    if (!intent) {\n      return {\n        version: null\n      };\n    } // Ensure TypeScript and necessary `@types/*` are installed:\n\n\n    const deps = await (0, _hasNecessaryDependencies).hasNecessaryDependencies(dir, requiredPackages);\n\n    if (((ref = deps.missing) === null || ref === void 0 ? void 0 : ref.length) > 0) {\n      (0, _missingDependencyError).missingDepsError(dir, deps.missing);\n    } // Load TypeScript after we're sure it exists:\n\n\n    const ts = await Promise.resolve().then(function () {\n      return _interopRequireWildcard(require(deps.resolved.get('typescript')));\n    });\n\n    if (_semver.default.lt(ts.version, '4.3.2')) {\n      log.warn(`Minimum recommended TypeScript version is v4.3.2, older versions can potentially be incompatible with Next.js. Detected: ${ts.version}`);\n    } // Reconfigure (or create) the user's `tsconfig.json` for them:\n\n\n    await (0, _writeConfigurationDefaults).writeConfigurationDefaults(ts, tsConfigPath, intent.firstTimeSetup); // Write out the necessary `next-env.d.ts` file to correctly register\n    // Next.js' types:\n\n    await (0, _writeAppTypeDeclarations).writeAppTypeDeclarations(dir, imageImportsEnabled);\n    let result;\n\n    if (typeCheckPreflight) {\n      const {\n        runTypeCheck\n      } = require('./typescript/runTypeCheck'); // Verify the project passes type-checking before we go to webpack phase:\n\n\n      result = await runTypeCheck(ts, dir, tsConfigPath, cacheDir);\n    }\n\n    return {\n      result,\n      version: ts.version\n    };\n  } catch (err) {\n    // These are special errors that should not show a stack trace:\n    if (err instanceof _compileError.CompileError) {\n      console.error(_chalk.default.red('Failed to compile.\\n'));\n      console.error(err.message);\n      process.exit(1);\n    } else if (err instanceof _fatalError.FatalError) {\n      console.error(err.message);\n      process.exit(1);\n    }\n\n    throw err;\n  }\n}","map":{"version":3,"sources":["../../lib/verifyTypeScriptSetup.ts"],"names":[],"mappings":"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","sourcesContent":["import chalk from 'chalk'\nimport path from 'path'\nimport {\n  hasNecessaryDependencies,\n  NecessaryDependencies,\n} from './has-necessary-dependencies'\nimport semver from 'next/dist/compiled/semver'\nimport { CompileError } from './compile-error'\nimport { FatalError } from './fatal-error'\nimport * as log from '../build/output/log'\n\nimport { getTypeScriptIntent } from './typescript/getTypeScriptIntent'\nimport { TypeCheckResult } from './typescript/runTypeCheck'\nimport { writeAppTypeDeclarations } from './typescript/writeAppTypeDeclarations'\nimport { writeConfigurationDefaults } from './typescript/writeConfigurationDefaults'\nimport { missingDepsError } from './typescript/missingDependencyError'\n\nconst requiredPackages = [\n  { file: 'typescript', pkg: 'typescript' },\n  { file: '@types/react/index.d.ts', pkg: '@types/react' },\n  { file: '@types/node/index.d.ts', pkg: '@types/node' },\n]\n\nexport async function verifyTypeScriptSetup(\n  dir: string,\n  pagesDir: string,\n  typeCheckPreflight: boolean,\n  imageImportsEnabled: boolean,\n  cacheDir?: string\n): Promise<{ result?: TypeCheckResult; version: string | null }> {\n  const tsConfigPath = path.join(dir, 'tsconfig.json')\n\n  try {\n    // Check if the project uses TypeScript:\n    const intent = await getTypeScriptIntent(dir, pagesDir)\n    if (!intent) {\n      return { version: null }\n    }\n\n    // Ensure TypeScript and necessary `@types/*` are installed:\n    const deps: NecessaryDependencies = await hasNecessaryDependencies(\n      dir,\n      requiredPackages\n    )\n\n    if (deps.missing?.length > 0) {\n      missingDepsError(dir, deps.missing)\n    }\n\n    // Load TypeScript after we're sure it exists:\n    const ts = (await import(\n      deps.resolved.get('typescript')!\n    )) as typeof import('typescript')\n\n    if (semver.lt(ts.version, '4.3.2')) {\n      log.warn(\n        `Minimum recommended TypeScript version is v4.3.2, older versions can potentially be incompatible with Next.js. Detected: ${ts.version}`\n      )\n    }\n\n    // Reconfigure (or create) the user's `tsconfig.json` for them:\n    await writeConfigurationDefaults(ts, tsConfigPath, intent.firstTimeSetup)\n    // Write out the necessary `next-env.d.ts` file to correctly register\n    // Next.js' types:\n    await writeAppTypeDeclarations(dir, imageImportsEnabled)\n\n    let result\n    if (typeCheckPreflight) {\n      const { runTypeCheck } = require('./typescript/runTypeCheck')\n\n      // Verify the project passes type-checking before we go to webpack phase:\n      result = await runTypeCheck(ts, dir, tsConfigPath, cacheDir)\n    }\n    return { result, version: ts.version }\n  } catch (err) {\n    // These are special errors that should not show a stack trace:\n    if (err instanceof CompileError) {\n      console.error(chalk.red('Failed to compile.\\n'))\n      console.error(err.message)\n      process.exit(1)\n    } else if (err instanceof FatalError) {\n      console.error(err.message)\n      process.exit(1)\n    }\n    throw err\n  }\n}\n"]},"metadata":{},"sourceType":"script"}