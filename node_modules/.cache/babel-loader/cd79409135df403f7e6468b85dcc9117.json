{"ast":null,"code":"const path = require(`path`);\n\nconst {\n  resolveModuleName\n} = require(`ts-pnp`);\n\nfunction nothing() {// ¯\\_(ツ)_/¯\n}\n\nfunction getModuleLocator(module) {\n  const pnp = require(`pnpapi`);\n\n  const moduleLocation = typeof module === `string` ? module : module.filename;\n  if (!moduleLocation) throw new Error(`The specified module doesn't seem to exist on the filesystem`);\n  const moduleLocator = pnp.findPackageLocator(moduleLocation);\n  if (!moduleLocator) throw new Error(`the specified module doesn't seem to be part of the dependency tree`);\n  return moduleLocator;\n}\n\nfunction getDependencyLocator(sourceLocator, name) {\n  const pnp = require(`pnpapi`);\n\n  const {\n    packageDependencies\n  } = pnp.getPackageInformation(sourceLocator);\n  const reference = packageDependencies.get(name);\n  return {\n    name,\n    reference\n  };\n}\n\nfunction getSourceLocation(sourceLocator) {\n  if (!sourceLocator) return null;\n\n  const pnp = require(`pnpapi`);\n\n  const sourceInformation = pnp.getPackageInformation(sourceLocator);\n  if (!sourceInformation) throw new Error(`Couldn't find the package to use as resolution source`);\n  if (!sourceInformation.packageLocation) throw new Error(`The package to use as resolution source seem to not have been installed - maybe it's a devDependency not installed in prod?`);\n  return sourceInformation.packageLocation.replace(/\\/?$/, `/`);\n}\n\nfunction makeResolver(sourceLocator, filter) {\n  const sourceLocation = getSourceLocation(sourceLocator);\n  return resolver => {\n    const BACKWARD_PATH = /^\\.\\.([\\\\\\/]|$)/;\n    const resolvedHook = resolver.ensureHook(`resolve`); // Prevents the SymlinkPlugin from kicking in. We need the symlinks to be preserved because that's how we deal with peer dependencies ambiguities.\n\n    resolver.getHook(`file`).intercept({\n      register: tapInfo => {\n        return tapInfo.name !== `SymlinkPlugin` ? tapInfo : Object.assign({}, tapInfo, {\n          fn: (request, resolveContext, callback) => {\n            callback();\n          }\n        });\n      }\n    });\n    resolver.getHook(`after-module`).tapAsync(`PnpResolver`, (request, resolveContext, callback) => {\n      // rethrow pnp errors if we have any for this request\n      return callback(resolveContext.pnpErrors && resolveContext.pnpErrors.get(request.context.issuer));\n    }); // Register a plugin that will resolve bare imports into the package location on the filesystem before leaving the rest of the resolution to Webpack\n\n    resolver.getHook(`before-module`).tapAsync(`PnpResolver`, (requestContext, resolveContext, callback) => {\n      const pnp = require(`pnpapi`);\n\n      let request = requestContext.request;\n      let issuer = requestContext.context.issuer; // When using require.context, issuer seems to be false (cf https://github.com/webpack/webpack-dev-server/blob/d0725c98fb752d8c0b1e8c9067e526e22b5f5134/client-src/default/index.js#L94)\n\n      if (!issuer) {\n        issuer = `${requestContext.path}/`; // We only support issuer when they're absolute paths. I'm not sure the opposite can ever happen, but better check here.\n      } else if (!path.isAbsolute(issuer)) {\n        throw new Error(`Cannot successfully resolve this dependency - issuer not supported (${issuer})`);\n      }\n\n      if (filter) {\n        const relative = path.relative(filter, issuer);\n\n        if (path.isAbsolute(relative) || BACKWARD_PATH.test(relative)) {\n          return callback(null);\n        }\n      }\n\n      let resolutionIssuer = sourceLocation || issuer;\n      let resolution;\n\n      try {\n        resolution = pnp.resolveToUnqualified(request, resolutionIssuer, {\n          considerBuiltins: false\n        });\n      } catch (error) {\n        if (resolveContext.missingDependencies) resolveContext.missingDependencies.add(requestContext.path);\n        if (resolveContext.log) resolveContext.log(error.message);\n        resolveContext.pnpErrors = resolveContext.pnpErrors || new Map();\n        resolveContext.pnpErrors.set(issuer, error);\n        return callback();\n      }\n\n      resolver.doResolve(resolvedHook, Object.assign({}, requestContext, {\n        request: resolution\n      }), null, resolveContext, callback);\n    });\n  };\n}\n\nmodule.exports = process.versions.pnp ? {\n  apply: makeResolver(null)\n} : {\n  apply: nothing\n};\n\nmodule.exports.makePlugin = (locator, filter) => process.versions.pnp ? {\n  apply: makeResolver(locator, filter)\n} : {\n  apply: nothing\n};\n\nmodule.exports.moduleLoader = module => process.versions.pnp ? {\n  apply: makeResolver(getModuleLocator(module))\n} : {\n  apply: nothing\n};\n\nmodule.exports.topLevelLoader = process.versions.pnp ? {\n  apply: makeResolver({\n    name: null,\n    reference: null\n  })\n} : {\n  apply: nothing\n};\n\nmodule.exports.bind = (filter, module, dependency) => process.versions.pnp ? {\n  apply: makeResolver(dependency ? getDependencyLocator(getModuleLocator(module), dependency) : getModuleLocator(module), filter)\n} : {\n  apply: nothing\n};\n\nmodule.exports.tsLoaderOptions = (options = {}) => process.versions.pnp ? Object.assign({}, options, {\n  resolveModuleName: resolveModuleName,\n  resolveTypeReferenceDirective: resolveModuleName\n}) : options;\n\nmodule.exports.forkTsCheckerOptions = (options = {}) => process.versions.pnp ? Object.assign({}, options, {\n  resolveModuleNameModule: require.resolve(`./ts`),\n  resolveTypeReferenceDirectiveModule: require.resolve(`./ts`)\n}) : options;","map":{"version":3,"sources":["C:/xampp/public_html/vamo/interface2/node_modules/pnp-webpack-plugin/index.js"],"names":["path","require","resolveModuleName","nothing","getModuleLocator","module","pnp","moduleLocation","filename","Error","moduleLocator","findPackageLocator","getDependencyLocator","sourceLocator","name","packageDependencies","getPackageInformation","reference","get","getSourceLocation","sourceInformation","packageLocation","replace","makeResolver","filter","sourceLocation","resolver","BACKWARD_PATH","resolvedHook","ensureHook","getHook","intercept","register","tapInfo","Object","assign","fn","request","resolveContext","callback","tapAsync","pnpErrors","context","issuer","requestContext","isAbsolute","relative","test","resolutionIssuer","resolution","resolveToUnqualified","considerBuiltins","error","missingDependencies","add","log","message","Map","set","doResolve","exports","process","versions","apply","makePlugin","locator","moduleLoader","topLevelLoader","bind","dependency","tsLoaderOptions","options","resolveTypeReferenceDirective","forkTsCheckerOptions","resolveModuleNameModule","resolve","resolveTypeReferenceDirectiveModule"],"mappings":"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","sourcesContent":["const path = require(`path`);\nconst {resolveModuleName} = require(`ts-pnp`);\n\nfunction nothing() {\n  // ¯\\_(ツ)_/¯\n}\n\nfunction getModuleLocator(module) {\n  const pnp = require(`pnpapi`);\n\n  const moduleLocation = typeof module === `string`\n    ? module\n    : module.filename;\n\n  if (!moduleLocation)\n    throw new Error(`The specified module doesn't seem to exist on the filesystem`);\n\n  const moduleLocator = pnp.findPackageLocator(moduleLocation);\n\n  if (!moduleLocator)\n    throw new Error(`the specified module doesn't seem to be part of the dependency tree`);\n\n  return moduleLocator;\n}\n\nfunction getDependencyLocator(sourceLocator, name) {\n  const pnp = require(`pnpapi`);\n\n  const {packageDependencies} = pnp.getPackageInformation(sourceLocator);\n  const reference = packageDependencies.get(name);\n\n  return {name, reference};\n}\n\nfunction getSourceLocation(sourceLocator) {\n  if (!sourceLocator)\n    return null;\n\n  const pnp = require(`pnpapi`);\n\n  const sourceInformation = pnp.getPackageInformation(sourceLocator);\n\n  if (!sourceInformation)\n    throw new Error(`Couldn't find the package to use as resolution source`);\n\n  if (!sourceInformation.packageLocation)\n    throw new Error(`The package to use as resolution source seem to not have been installed - maybe it's a devDependency not installed in prod?`);\n\n  return sourceInformation.packageLocation.replace(/\\/?$/, `/`);\n}\n\nfunction makeResolver(sourceLocator, filter) {\n  const sourceLocation = getSourceLocation(sourceLocator);\n\n  return resolver => {\n    const BACKWARD_PATH = /^\\.\\.([\\\\\\/]|$)/;\n\n    const resolvedHook = resolver.ensureHook(`resolve`);\n\n    // Prevents the SymlinkPlugin from kicking in. We need the symlinks to be preserved because that's how we deal with peer dependencies ambiguities.\n    resolver.getHook(`file`).intercept({\n      register: tapInfo => {\n        return tapInfo.name !== `SymlinkPlugin` ? tapInfo : Object.assign({}, tapInfo, {fn: (request, resolveContext, callback) => {\n          callback();\n        }});\n      }\n    });\n\n    resolver.getHook(`after-module`).tapAsync(`PnpResolver`, (request, resolveContext, callback) => {\n      // rethrow pnp errors if we have any for this request\n      return callback(resolveContext.pnpErrors && resolveContext.pnpErrors.get(request.context.issuer));\n    });\n\n    // Register a plugin that will resolve bare imports into the package location on the filesystem before leaving the rest of the resolution to Webpack\n    resolver.getHook(`before-module`).tapAsync(`PnpResolver`, (requestContext, resolveContext, callback) => {\n      const pnp = require(`pnpapi`);\n\n      let request = requestContext.request;\n      let issuer = requestContext.context.issuer;\n\n      // When using require.context, issuer seems to be false (cf https://github.com/webpack/webpack-dev-server/blob/d0725c98fb752d8c0b1e8c9067e526e22b5f5134/client-src/default/index.js#L94)\n      if (!issuer) {\n        issuer = `${requestContext.path}/`;\n      // We only support issuer when they're absolute paths. I'm not sure the opposite can ever happen, but better check here.\n      } else if (!path.isAbsolute(issuer)) {\n        throw new Error(`Cannot successfully resolve this dependency - issuer not supported (${issuer})`);\n      }\n\n      if (filter) {\n        const relative = path.relative(filter, issuer);\n        if (path.isAbsolute(relative) || BACKWARD_PATH.test(relative)) {\n          return callback(null);\n        }\n      }\n\n      let resolutionIssuer = sourceLocation || issuer;\n      let resolution;\n\n      try {\n        resolution = pnp.resolveToUnqualified(request, resolutionIssuer, {considerBuiltins: false});\n      } catch (error) {\n        if (resolveContext.missingDependencies)\n          resolveContext.missingDependencies.add(requestContext.path);\n\n        if (resolveContext.log)\n          resolveContext.log(error.message);\n\n        resolveContext.pnpErrors = resolveContext.pnpErrors || new Map();\n        resolveContext.pnpErrors.set(issuer, error);\n\n        return callback();\n      }\n\n      resolver.doResolve(\n        resolvedHook,\n        Object.assign({}, requestContext, {\n          request: resolution,\n        }),\n        null,\n        resolveContext,\n        callback\n      );\n    });\n  };\n}\n\nmodule.exports = process.versions.pnp ? {\n  apply: makeResolver(null),\n} : {\n  apply: nothing,\n};\n\nmodule.exports.makePlugin = (locator, filter) => process.versions.pnp ? {\n  apply: makeResolver(locator, filter),\n} : {\n  apply: nothing,\n};\n\nmodule.exports.moduleLoader = module => process.versions.pnp ? {\n  apply: makeResolver(getModuleLocator(module)),\n} : {\n  apply: nothing,\n};\n\nmodule.exports.topLevelLoader = process.versions.pnp ? {\n  apply: makeResolver({name: null, reference: null}),\n} : {\n  apply: nothing,\n};\n\nmodule.exports.bind = (filter, module, dependency) => process.versions.pnp ? {\n  apply: makeResolver(dependency ? getDependencyLocator(getModuleLocator(module), dependency) : getModuleLocator(module), filter),\n} : {\n  apply: nothing,\n};\n\nmodule.exports.tsLoaderOptions = (options = {}) => process.versions.pnp ? Object.assign({}, options, {\n  resolveModuleName: resolveModuleName,\n  resolveTypeReferenceDirective: resolveModuleName,\n}) : options;\n\nmodule.exports.forkTsCheckerOptions = (options = {}) => process.versions.pnp ? Object.assign({}, options, {\n  resolveModuleNameModule: require.resolve(`./ts`),\n  resolveTypeReferenceDirectiveModule: require.resolve(`./ts`),\n}) : options;\n"]},"metadata":{},"sourceType":"script"}