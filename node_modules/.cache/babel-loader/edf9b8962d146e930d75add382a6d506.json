{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.recursiveDelete = recursiveDelete;\n\nvar _fs = require(\"fs\");\n\nvar _path = require(\"path\");\n\nvar _util = require(\"util\");\n\nconst sleep = (0, _util).promisify(setTimeout);\n\nconst unlinkFile = async (p, t = 1) => {\n  try {\n    await _fs.promises.unlink(p);\n  } catch (e) {\n    if ((e.code === 'EBUSY' || e.code === 'ENOTEMPTY' || e.code === 'EPERM' || e.code === 'EMFILE') && t < 3) {\n      await sleep(t * 100);\n      return unlinkFile(p, t++);\n    }\n\n    if (e.code === 'ENOENT') {\n      return;\n    }\n\n    throw e;\n  }\n};\n\nasync function recursiveDelete(dir, exclude, previousPath = '') {\n  let result;\n\n  try {\n    result = await _fs.promises.readdir(dir, {\n      withFileTypes: true\n    });\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      return;\n    }\n\n    throw e;\n  }\n\n  await Promise.all(result.map(async part => {\n    const absolutePath = (0, _path).join(dir, part.name); // readdir does not follow symbolic links\n    // if part is a symbolic link, follow it using stat\n\n    let isDirectory = part.isDirectory();\n\n    if (part.isSymbolicLink()) {\n      const stats = await _fs.promises.stat(absolutePath);\n      isDirectory = stats.isDirectory();\n    }\n\n    const pp = (0, _path).join(previousPath, part.name);\n\n    if (isDirectory && (!exclude || !exclude.test(pp))) {\n      await recursiveDelete(absolutePath, exclude, pp);\n      return _fs.promises.rmdir(absolutePath);\n    }\n\n    if (!exclude || !exclude.test(pp)) {\n      return unlinkFile(absolutePath);\n    }\n  }));\n}","map":{"version":3,"sources":["../../lib/recursive-delete.ts"],"names":[],"mappings":";;;;;QAoCsB,e,GAAA,e;;AApCW,IAAA,GAAI,GAAA,OAAA,CAAA,IAAA,CAAJ;;AACZ,IAAA,KAAM,GAAA,OAAA,CAAA,MAAA,CAAN;;AACK,IAAA,KAAM,GAAA,OAAA,CAAA,MAAA,CAAN;;AAE1B,MAAM,KAAK,GAAA,CAAA,GAFe,KAEf,EAFqB,SAErB,CAAa,UAAb,CAAX;;AAEA,MAAM,UAAU,GAAA,OAAU,CAAV,EAAqB,CAAC,GAAG,CAAzB,KAA8C;MACxD;UAP2B,GAAI,CAAA,QAAJ,CAQd,MARc,CAQP,CARO,C;AAS9B,G,CAAA,OAAQ,CAAR,EAAW;AACV,QAAE,CACC,CAAC,CAAC,IAAF,KAAM,OAAN,IACC,CAAC,CAAC,IAAF,KAAM,WADP,IAEC,CAAC,CAAC,IAAF,KAAM,OAFP,IAGC,CAAC,CAAC,IAAF,KAAM,QAJR,KAKA,CAAC,GAAG,CALN,EAME;YACM,KAAK,CAAC,CAAC,GAAG,GAAL,C;aACJ,UAAU,CAAC,CAAD,EAAI,CAAC,EAAL,C;AAClB;;AAED,QAAI,CAAC,CAAC,IAAF,KAAM,QAAV,EAAyB;;AAExB;;AAED,UAAM,CAAN;AACD;AACF,CArBD;;eA8BsB,e,CACpB,G,EACA,O,EACA,YAAoB,GAAA,E,EACL;AACf,MAAI,MAAJ;;MACI;AACF,IAAA,MAAM,GAAA,MA3CuB,GAAI,CAAA,QAAJ,CA2CL,OA3CK,CA2CG,GA3CH,EA2CM;AAAI,MAAA,aAAa,EAAE;AAAnB,KA3CN,CA2C7B;AACD,G,CAAA,OAAQ,CAAR,EAAW;AACV,QAAI,CAAC,CAAC,IAAF,KAAM,QAAV,EAAyB;;AAExB;;AACD,UAAM,CAAN;AACD;;QAEK,OAAO,CAAC,GAAR,CACJ,MAAM,CAAC,GAAP,CAAU,MAAQ,IAAR,IAAyB;AACjC,UAAM,YAAY,GAAA,CAAA,GApDH,KAoDG,EApDG,IAoDH,CAAQ,GAAR,EAAa,IAAI,CAAC,IAAlB,CAAlB,CADiC,CAGjC;AACA;;AACA,QAAI,WAAW,GAAG,IAAI,CAAC,WAAL,EAAlB;;AACA,QAAI,IAAI,CAAC,cAAL,EAAJ,EAA2B;AACzB,YAAM,KAAK,GAAA,MA3Dc,GAAI,CAAA,QAAJ,CA2DI,IA3DJ,CA2DS,YA3DT,CA2DzB;AACA,MAAA,WAAW,GAAG,KAAK,CAAC,WAAN,EAAd;AACD;;AAED,UAAM,EAAE,GAAA,CAAA,GA9DO,KA8DP,EA9Da,IA8Db,CAAQ,YAAR,EAAsB,IAAI,CAAC,IAA3B,CAAR;;AACA,QAAI,WAAW,KAAA,CAAM,OAAN,IAAa,CAAK,OAAO,CAAC,IAAR,CAAa,EAAb,CAAlB,CAAf,EAAoD;YAC5C,eAAe,CAAC,YAAD,EAAe,OAAf,EAAwB,EAAxB,C;aAjEI,GAAI,CAAA,QAAJ,CAkET,KAlES,CAkEH,YAlEG,C;AAmE1B;;AAED,QAAE,CAAG,OAAH,IAAU,CAAK,OAAO,CAAC,IAAR,CAAa,EAAb,CAAjB,EAAmC;aAC1B,UAAU,CAAC,YAAD,C;AAClB;AACF,GApBD,CADI,C;AAuBP","sourcesContent":["import { Dirent, promises } from 'fs'\nimport { join } from 'path'\nimport { promisify } from 'util'\n\nconst sleep = promisify(setTimeout)\n\nconst unlinkFile = async (p: string, t = 1): Promise<void> => {\n  try {\n    await promises.unlink(p)\n  } catch (e) {\n    if (\n      (e.code === 'EBUSY' ||\n        e.code === 'ENOTEMPTY' ||\n        e.code === 'EPERM' ||\n        e.code === 'EMFILE') &&\n      t < 3\n    ) {\n      await sleep(t * 100)\n      return unlinkFile(p, t++)\n    }\n\n    if (e.code === 'ENOENT') {\n      return\n    }\n\n    throw e\n  }\n}\n\n/**\n * Recursively delete directory contents\n * @param  {string} dir Directory to delete the contents of\n * @param  {RegExp} [exclude] Exclude based on relative file path\n * @param  {string} [previousPath] Ensures that parameter dir exists, this is not passed recursively\n * @returns Promise void\n */\nexport async function recursiveDelete(\n  dir: string,\n  exclude?: RegExp,\n  previousPath: string = ''\n): Promise<void> {\n  let result\n  try {\n    result = await promises.readdir(dir, { withFileTypes: true })\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      return\n    }\n    throw e\n  }\n\n  await Promise.all(\n    result.map(async (part: Dirent) => {\n      const absolutePath = join(dir, part.name)\n\n      // readdir does not follow symbolic links\n      // if part is a symbolic link, follow it using stat\n      let isDirectory = part.isDirectory()\n      if (part.isSymbolicLink()) {\n        const stats = await promises.stat(absolutePath)\n        isDirectory = stats.isDirectory()\n      }\n\n      const pp = join(previousPath, part.name)\n      if (isDirectory && (!exclude || !exclude.test(pp))) {\n        await recursiveDelete(absolutePath, exclude, pp)\n        return promises.rmdir(absolutePath)\n      }\n\n      if (!exclude || !exclude.test(pp)) {\n        return unlinkFile(absolutePath)\n      }\n    })\n  )\n}\n"]},"metadata":{},"sourceType":"script"}