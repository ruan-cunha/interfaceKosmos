{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.renderScriptError = renderScriptError;\nexports.default = void 0;\n\nvar _middleware = require(\"@next/react-dev-overlay/lib/middleware\");\n\nvar _hotMiddleware = require(\"./hot-middleware\");\n\nvar _path = require(\"path\");\n\nvar _webpack = require(\"next/dist/compiled/webpack/webpack\");\n\nvar _entries = require(\"../../build/entries\");\n\nvar _output = require(\"../../build/output\");\n\nvar _webpackConfig = _interopRequireDefault(require(\"../../build/webpack-config\"));\n\nvar _constants = require(\"../../lib/constants\");\n\nvar _recursiveDelete = require(\"../../lib/recursive-delete\");\n\nvar _constants1 = require(\"../../shared/lib/constants\");\n\nvar _router = require(\"../router\");\n\nvar _findPageFile = require(\"../lib/find-page-file\");\n\nvar _onDemandEntryHandler = _interopRequireWildcard(require(\"./on-demand-entry-handler\"));\n\nvar _normalizePagePath = require(\"../normalize-page-path\");\n\nvar _getRouteFromEntrypoint = _interopRequireDefault(require(\"../get-route-from-entrypoint\"));\n\nvar _isWriteable = require(\"../../build/is-writeable\");\n\nvar _querystring = require(\"querystring\");\n\nvar _utils = require(\"../../build/utils\");\n\nvar _utils1 = require(\"../../shared/lib/utils\");\n\nvar _trace = require(\"../../telemetry/trace\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nasync function renderScriptError(res, error, {\n  verbose = true\n} = {}) {\n  // Asks CDNs and others to not to cache the errored page\n  res.setHeader('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate');\n\n  if (error.code === 'ENOENT') {\n    res.statusCode = 404;\n    res.end('404 - Not Found');\n    return;\n  }\n\n  if (verbose) {\n    console.error(error.stack);\n  }\n\n  res.statusCode = 500;\n  res.end('500 - Internal Error');\n}\n\nfunction addCorsSupport(req, res) {\n  const isApiRoute = req.url.match(_constants.API_ROUTE); // API routes handle their own CORS headers\n\n  if (isApiRoute) {\n    return {\n      preflight: false\n    };\n  }\n\n  if (!req.headers.origin) {\n    return {\n      preflight: false\n    };\n  }\n\n  res.setHeader('Access-Control-Allow-Origin', req.headers.origin);\n  res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET'); // Based on https://github.com/primus/access-control/blob/4cf1bc0e54b086c91e6aa44fb14966fa5ef7549c/index.js#L158\n\n  if (req.headers['access-control-request-headers']) {\n    res.setHeader('Access-Control-Allow-Headers', req.headers['access-control-request-headers']);\n  }\n\n  if (req.method === 'OPTIONS') {\n    res.writeHead(200);\n    res.end();\n    return {\n      preflight: true\n    };\n  }\n\n  return {\n    preflight: false\n  };\n}\n\nconst matchNextPageBundleRequest = (0, _router).route('/_next/static/chunks/pages/:path*.js(\\\\.map|)'); // Recursively look up the issuer till it ends up at the root\n\nfunction findEntryModule(issuer) {\n  if (issuer.issuer) {\n    return findEntryModule(issuer.issuer);\n  }\n\n  return issuer;\n}\n\nfunction erroredPages(compilation) {\n  const failedPages = {};\n\n  for (const error of compilation.errors) {\n    if (!error.origin) {\n      continue;\n    }\n\n    const entryModule = findEntryModule(error.origin);\n    const {\n      name\n    } = entryModule;\n\n    if (!name) {\n      continue;\n    } // Only pages have to be reloaded\n\n\n    const enhancedName = (0, _getRouteFromEntrypoint).default(name);\n\n    if (!enhancedName) {\n      continue;\n    }\n\n    if (!failedPages[enhancedName]) {\n      failedPages[enhancedName] = [];\n    }\n\n    failedPages[enhancedName].push(error);\n  }\n\n  return failedPages;\n}\n\nclass HotReloader {\n  constructor(dir, {\n    config,\n    pagesDir,\n    buildId,\n    previewProps,\n    rewrites\n  }) {\n    this.clientError = null;\n    this.serverError = null;\n    this.buildId = buildId;\n    this.dir = dir;\n    this.middlewares = [];\n    this.pagesDir = pagesDir;\n    this.webpackHotMiddleware = null;\n    this.stats = null;\n    this.serverStats = null;\n    this.serverPrevDocumentHash = null;\n    this.config = config;\n    this.previewProps = previewProps;\n    this.rewrites = rewrites;\n    this.isWebpack5 = _webpack.isWebpack5;\n    this.hotReloaderSpan = (0, _trace).trace('hot-reloader');\n  }\n\n  async run(req, res, parsedUrl) {\n    // Usually CORS support is not needed for the hot-reloader (this is dev only feature)\n    // With when the app runs for multi-zones support behind a proxy,\n    // the current page is trying to access this URL via assetPrefix.\n    // That's when the CORS support is needed.\n    const {\n      preflight\n    } = addCorsSupport(req, res);\n\n    if (preflight) {\n      return {};\n    } // When a request comes in that is a page bundle, e.g. /_next/static/<buildid>/pages/index.js\n    // we have to compile the page using on-demand-entries, this middleware will handle doing that\n    // by adding the page to on-demand-entries, waiting till it's done\n    // and then the bundle will be served like usual by the actual route in server/index.js\n\n\n    const handlePageBundleRequest = async (pageBundleRes, parsedPageBundleUrl) => {\n      const {\n        pathname\n      } = parsedPageBundleUrl;\n      const params = matchNextPageBundleRequest(pathname);\n\n      if (!params) {\n        return {};\n      }\n\n      let decodedPagePath;\n\n      try {\n        decodedPagePath = `/${params.path.map(param => decodeURIComponent(param)).join('/')}`;\n      } catch (_) {\n        throw new _utils1.DecodeError('failed to decode param');\n      }\n\n      const page = (0, _normalizePagePath).denormalizePagePath(decodedPagePath);\n\n      if (page === '/_error' || _constants1.BLOCKED_PAGES.indexOf(page) === -1) {\n        try {\n          await this.ensurePage(page);\n        } catch (error) {\n          await renderScriptError(pageBundleRes, error);\n          return {\n            finished: true\n          };\n        }\n\n        const errors = await this.getCompilationErrors(page);\n\n        if (errors.length > 0) {\n          await renderScriptError(pageBundleRes, errors[0], {\n            verbose: false\n          });\n          return {\n            finished: true\n          };\n        }\n      }\n\n      return {};\n    };\n\n    const {\n      finished\n    } = await handlePageBundleRequest(res, parsedUrl);\n\n    for (const fn of this.middlewares) {\n      await new Promise((resolve, reject) => {\n        fn(req, res, err => {\n          if (err) return reject(err);\n          resolve();\n        });\n      });\n    }\n\n    return {\n      finished\n    };\n  }\n\n  async clean() {\n    return (0, _recursiveDelete).recursiveDelete((0, _path).join(this.dir, this.config.distDir), /^cache/);\n  }\n\n  async getWebpackConfig() {\n    const pagePaths = await Promise.all([(0, _findPageFile).findPageFile(this.pagesDir, '/_app', this.config.pageExtensions), (0, _findPageFile).findPageFile(this.pagesDir, '/_document', this.config.pageExtensions)]);\n    const pages = (0, _entries).createPagesMapping(pagePaths.filter(i => i !== null), this.config.pageExtensions, this.isWebpack5, true);\n    const entrypoints = (0, _entries).createEntrypoints(pages, 'server', this.buildId, this.previewProps, this.config, []);\n    return Promise.all([(0, _webpackConfig).default(this.dir, {\n      dev: true,\n      isServer: false,\n      config: this.config,\n      buildId: this.buildId,\n      pagesDir: this.pagesDir,\n      rewrites: this.rewrites,\n      entrypoints: entrypoints.client,\n      runWebpackSpan: this.hotReloaderSpan\n    }), (0, _webpackConfig).default(this.dir, {\n      dev: true,\n      isServer: true,\n      config: this.config,\n      buildId: this.buildId,\n      pagesDir: this.pagesDir,\n      rewrites: this.rewrites,\n      entrypoints: entrypoints.server,\n      runWebpackSpan: this.hotReloaderSpan\n    })]);\n  }\n\n  async buildFallbackError() {\n    if (this.fallbackWatcher) return;\n    const fallbackConfig = await (0, _webpackConfig).default(this.dir, {\n      runWebpackSpan: this.hotReloaderSpan,\n      dev: true,\n      isServer: false,\n      config: this.config,\n      buildId: this.buildId,\n      pagesDir: this.pagesDir,\n      rewrites: {\n        beforeFiles: [],\n        afterFiles: [],\n        fallback: []\n      },\n      isDevFallback: true,\n      entrypoints: (0, _entries).createEntrypoints({\n        '/_app': 'next/dist/pages/_app',\n        '/_error': 'next/dist/pages/_error'\n      }, 'server', this.buildId, this.previewProps, this.config, []).client\n    });\n    const fallbackCompiler = (0, _webpack).webpack(fallbackConfig);\n    this.fallbackWatcher = await new Promise(resolve => {\n      let bootedFallbackCompiler = false;\n      fallbackCompiler.watch( // @ts-ignore webpack supports an array of watchOptions when using a multiCompiler\n      fallbackConfig.watchOptions, // Errors are handled separately\n      _err => {\n        if (!bootedFallbackCompiler) {\n          bootedFallbackCompiler = true;\n          resolve(true);\n        }\n      });\n    });\n  }\n\n  async start() {\n    await this.clean();\n    const configs = await this.getWebpackConfig();\n\n    for (const config1 of configs) {\n      const defaultEntry = config1.entry;\n\n      config1.entry = async (...args) => {\n        // @ts-ignore entry is always a functon\n        const entrypoints = await defaultEntry(...args);\n        const isClientCompilation = config1.name === 'client';\n        await Promise.all(Object.keys(_onDemandEntryHandler.entries).map(async page => {\n          if (isClientCompilation && page.match(_constants.API_ROUTE)) {\n            return;\n          }\n\n          const {\n            serverBundlePath,\n            clientBundlePath,\n            absolutePagePath\n          } = _onDemandEntryHandler.entries[page];\n          const pageExists = await (0, _isWriteable).isWriteable(absolutePagePath);\n\n          if (!pageExists) {\n            // page was removed\n            delete _onDemandEntryHandler.entries[page];\n            return;\n          }\n\n          _onDemandEntryHandler.entries[page].status = _onDemandEntryHandler.BUILDING;\n          const pageLoaderOpts = {\n            page,\n            absolutePagePath\n          };\n          entrypoints[isClientCompilation ? clientBundlePath : serverBundlePath] = isClientCompilation ? `next-client-pages-loader?${(0, _querystring).stringify(pageLoaderOpts)}!` : absolutePagePath;\n        }));\n        return entrypoints;\n      };\n    }\n\n    const multiCompiler = (0, _webpack).webpack(configs);\n    (0, _output).watchCompilers(multiCompiler.compilers[0], multiCompiler.compilers[1]); // Watch for changes to client/server page files so we can tell when just\n    // the server file changes and trigger a reload for GS(S)P pages\n\n    const changedClientPages = new Set();\n    const changedServerPages = new Set();\n    const prevClientPageHashes = new Map();\n    const prevServerPageHashes = new Map();\n\n    const trackPageChanges = (pageHashMap, changedItems) => stats => {\n      stats.entrypoints.forEach((entry, key) => {\n        if (key.startsWith('pages/')) {\n          entry.chunks.forEach(chunk => {\n            if (chunk.id === key) {\n              const prevHash = pageHashMap.get(key);\n\n              if (prevHash && prevHash !== chunk.hash) {\n                changedItems.add(key);\n              }\n\n              pageHashMap.set(key, chunk.hash);\n            }\n          });\n        }\n      });\n    };\n\n    multiCompiler.compilers[0].hooks.emit.tap('NextjsHotReloaderForClient', trackPageChanges(prevClientPageHashes, changedClientPages));\n    multiCompiler.compilers[1].hooks.emit.tap('NextjsHotReloaderForServer', trackPageChanges(prevServerPageHashes, changedServerPages)); // This plugin watches for changes to _document.js and notifies the client side that it should reload the page\n\n    multiCompiler.compilers[1].hooks.failed.tap('NextjsHotReloaderForServer', err => {\n      this.serverError = err;\n      this.serverStats = null;\n    });\n    multiCompiler.compilers[1].hooks.done.tap('NextjsHotReloaderForServer', stats => {\n      this.serverError = null;\n      this.serverStats = stats;\n      const serverOnlyChanges = (0, _utils).difference(changedServerPages, changedClientPages);\n      changedClientPages.clear();\n      changedServerPages.clear();\n\n      if (serverOnlyChanges.length > 0) {\n        this.send({\n          event: 'serverOnlyChanges',\n          pages: serverOnlyChanges.map(pg => (0, _normalizePagePath).denormalizePagePath(pg.substr('pages'.length)))\n        });\n      }\n\n      const {\n        compilation\n      } = stats; // We only watch `_document` for changes on the server compilation\n      // the rest of the files will be triggered by the client compilation\n\n      const documentChunk = compilation.namedChunks.get('pages/_document'); // If the document chunk can't be found we do nothing\n\n      if (!documentChunk) {\n        console.warn('_document.js chunk not found');\n        return;\n      } // Initial value\n\n\n      if (this.serverPrevDocumentHash === null) {\n        this.serverPrevDocumentHash = documentChunk.hash;\n        return;\n      } // If _document.js didn't change we don't trigger a reload\n\n\n      if (documentChunk.hash === this.serverPrevDocumentHash) {\n        return;\n      } // Notify reload to reload the page, as _document.js was changed (different hash)\n\n\n      this.send('reloadPage');\n      this.serverPrevDocumentHash = documentChunk.hash;\n    });\n    multiCompiler.compilers[0].hooks.failed.tap('NextjsHotReloaderForClient', err => {\n      this.clientError = err;\n      this.stats = null;\n    });\n    multiCompiler.compilers[0].hooks.done.tap('NextjsHotReloaderForClient', stats => {\n      this.clientError = null;\n      this.stats = stats;\n      const {\n        compilation\n      } = stats;\n      const chunkNames = new Set([...compilation.namedChunks.keys()].filter(name => !!(0, _getRouteFromEntrypoint).default(name)));\n\n      if (this.prevChunkNames) {\n        // detect chunks which have to be replaced with a new template\n        // e.g, pages/index.js <-> pages/_error.js\n        const addedPages = diff(chunkNames, this.prevChunkNames);\n        const removedPages = diff(this.prevChunkNames, chunkNames);\n\n        if (addedPages.size > 0) {\n          for (const addedPage of addedPages) {\n            const page = (0, _getRouteFromEntrypoint).default(addedPage);\n            this.send('addedPage', page);\n          }\n        }\n\n        if (removedPages.size > 0) {\n          for (const removedPage of removedPages) {\n            const page = (0, _getRouteFromEntrypoint).default(removedPage);\n            this.send('removedPage', page);\n          }\n        }\n      }\n\n      this.prevChunkNames = chunkNames;\n    });\n    this.webpackHotMiddleware = new _hotMiddleware.WebpackHotMiddleware(multiCompiler.compilers);\n    let booted = false;\n    this.watcher = await new Promise(resolve => {\n      const watcher = multiCompiler.watch( // @ts-ignore webpack supports an array of watchOptions when using a multiCompiler\n      configs.map(config2 => config2.watchOptions), // Errors are handled separately\n      _err => {\n        if (!booted) {\n          booted = true;\n          resolve(watcher);\n        }\n      });\n    });\n    this.onDemandEntries = (0, _onDemandEntryHandler).default(this.watcher, multiCompiler, {\n      pagesDir: this.pagesDir,\n      pageExtensions: this.config.pageExtensions,\n      ...this.config.onDemandEntries\n    });\n    this.middlewares = [// must come before hotMiddleware\n    this.onDemandEntries.middleware, this.webpackHotMiddleware.middleware, (0, _middleware).getOverlayMiddleware({\n      isWebpack5: _webpack.isWebpack5,\n      rootDirectory: this.dir,\n      stats: () => this.stats,\n      serverStats: () => this.serverStats\n    })];\n  }\n\n  async stop() {\n    await new Promise((resolve, reject) => {\n      this.watcher.close(err => err ? reject(err) : resolve(true));\n    });\n\n    if (this.fallbackWatcher) {\n      await new Promise((resolve, reject) => {\n        this.fallbackWatcher.close(err => err ? reject(err) : resolve(true));\n      });\n    }\n  }\n\n  async getCompilationErrors(page) {\n    var ref, ref1;\n    const normalizedPage = (0, _normalizePagePath).normalizePathSep(page);\n\n    if (this.clientError || this.serverError) {\n      return [this.clientError || this.serverError];\n    } else if ((ref = this.stats) === null || ref === void 0 ? void 0 : ref.hasErrors()) {\n      const {\n        compilation\n      } = this.stats;\n      const failedPages = erroredPages(compilation); // If there is an error related to the requesting page we display it instead of the first error\n\n      if (failedPages[normalizedPage] && failedPages[normalizedPage].length > 0) {\n        return failedPages[normalizedPage];\n      } // If none were found we still have to show the other errors\n\n\n      return this.stats.compilation.errors;\n    } else if ((ref1 = this.serverStats) === null || ref1 === void 0 ? void 0 : ref1.hasErrors()) {\n      const {\n        compilation\n      } = this.serverStats;\n      const failedPages = erroredPages(compilation); // If there is an error related to the requesting page we display it instead of the first error\n\n      if (failedPages[normalizedPage] && failedPages[normalizedPage].length > 0) {\n        return failedPages[normalizedPage];\n      } // If none were found we still have to show the other errors\n\n\n      return this.serverStats.compilation.errors;\n    }\n\n    return [];\n  }\n\n  send(action, ...args) {\n    this.webpackHotMiddleware.publish(action && typeof action === 'object' ? action : {\n      action,\n      data: args\n    });\n  }\n\n  async ensurePage(page) {\n    // Make sure we don't re-build or dispose prebuilt pages\n    if (page !== '/_error' && _constants1.BLOCKED_PAGES.indexOf(page) !== -1) {\n      return;\n    }\n\n    if (this.serverError || this.clientError) {\n      return Promise.reject(this.serverError || this.clientError);\n    }\n\n    return this.onDemandEntries.ensurePage(page);\n  }\n\n}\n\nexports.default = HotReloader;\n\nfunction diff(a, b) {\n  return new Set([...a].filter(v => !b.has(v)));\n}","map":{"version":3,"sources":["../../../server/dev/hot-reloader.ts"],"names":[],"mappings":"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","sourcesContent":["import { getOverlayMiddleware } from '@next/react-dev-overlay/lib/middleware'\nimport { NextHandleFunction } from 'connect'\nimport { IncomingMessage, ServerResponse } from 'http'\nimport { WebpackHotMiddleware } from './hot-middleware'\nimport { join } from 'path'\nimport { UrlObject } from 'url'\nimport { webpack, isWebpack5 } from 'next/dist/compiled/webpack/webpack'\nimport { createEntrypoints, createPagesMapping } from '../../build/entries'\nimport { watchCompilers } from '../../build/output'\nimport getBaseWebpackConfig from '../../build/webpack-config'\nimport { API_ROUTE } from '../../lib/constants'\nimport { recursiveDelete } from '../../lib/recursive-delete'\nimport { BLOCKED_PAGES } from '../../shared/lib/constants'\nimport { __ApiPreviewProps } from '../api-utils'\nimport { route } from '../router'\nimport { findPageFile } from '../lib/find-page-file'\nimport onDemandEntryHandler, {\n  entries,\n  BUILDING,\n} from './on-demand-entry-handler'\nimport { denormalizePagePath, normalizePathSep } from '../normalize-page-path'\nimport getRouteFromEntrypoint from '../get-route-from-entrypoint'\nimport { isWriteable } from '../../build/is-writeable'\nimport { ClientPagesLoaderOptions } from '../../build/webpack/loaders/next-client-pages-loader'\nimport { stringify } from 'querystring'\nimport { difference } from '../../build/utils'\nimport { NextConfigComplete } from '../config-shared'\nimport { CustomRoutes } from '../../lib/load-custom-routes'\nimport { DecodeError } from '../../shared/lib/utils'\nimport { Span, trace } from '../../telemetry/trace'\n\nexport async function renderScriptError(\n  res: ServerResponse,\n  error: Error,\n  { verbose = true } = {}\n) {\n  // Asks CDNs and others to not to cache the errored page\n  res.setHeader(\n    'Cache-Control',\n    'no-cache, no-store, max-age=0, must-revalidate'\n  )\n\n  if ((error as any).code === 'ENOENT') {\n    res.statusCode = 404\n    res.end('404 - Not Found')\n    return\n  }\n\n  if (verbose) {\n    console.error(error.stack)\n  }\n  res.statusCode = 500\n  res.end('500 - Internal Error')\n}\n\nfunction addCorsSupport(req: IncomingMessage, res: ServerResponse) {\n  const isApiRoute = req.url!.match(API_ROUTE)\n  // API routes handle their own CORS headers\n  if (isApiRoute) {\n    return { preflight: false }\n  }\n\n  if (!req.headers.origin) {\n    return { preflight: false }\n  }\n\n  res.setHeader('Access-Control-Allow-Origin', req.headers.origin)\n  res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET')\n  // Based on https://github.com/primus/access-control/blob/4cf1bc0e54b086c91e6aa44fb14966fa5ef7549c/index.js#L158\n  if (req.headers['access-control-request-headers']) {\n    res.setHeader(\n      'Access-Control-Allow-Headers',\n      req.headers['access-control-request-headers'] as string\n    )\n  }\n\n  if (req.method === 'OPTIONS') {\n    res.writeHead(200)\n    res.end()\n    return { preflight: true }\n  }\n\n  return { preflight: false }\n}\n\nconst matchNextPageBundleRequest = route(\n  '/_next/static/chunks/pages/:path*.js(\\\\.map|)'\n)\n\n// Recursively look up the issuer till it ends up at the root\nfunction findEntryModule(issuer: any): any {\n  if (issuer.issuer) {\n    return findEntryModule(issuer.issuer)\n  }\n\n  return issuer\n}\n\nfunction erroredPages(compilation: webpack.compilation.Compilation) {\n  const failedPages: { [page: string]: any[] } = {}\n  for (const error of compilation.errors) {\n    if (!error.origin) {\n      continue\n    }\n\n    const entryModule = findEntryModule(error.origin)\n    const { name } = entryModule\n    if (!name) {\n      continue\n    }\n\n    // Only pages have to be reloaded\n    const enhancedName = getRouteFromEntrypoint(name)\n\n    if (!enhancedName) {\n      continue\n    }\n\n    if (!failedPages[enhancedName]) {\n      failedPages[enhancedName] = []\n    }\n\n    failedPages[enhancedName].push(error)\n  }\n\n  return failedPages\n}\n\nexport default class HotReloader {\n  private dir: string\n  private buildId: string\n  private middlewares: any[]\n  private pagesDir: string\n  private webpackHotMiddleware: (NextHandleFunction & any) | null\n  private config: NextConfigComplete\n  private stats: webpack.Stats | null\n  public serverStats: webpack.Stats | null\n  private clientError: Error | null = null\n  private serverError: Error | null = null\n  private serverPrevDocumentHash: string | null\n  private prevChunkNames?: Set<any>\n  private onDemandEntries: any\n  private previewProps: __ApiPreviewProps\n  private watcher: any\n  private rewrites: CustomRoutes['rewrites']\n  private fallbackWatcher: any\n  private hotReloaderSpan: Span\n  public isWebpack5: any\n\n  constructor(\n    dir: string,\n    {\n      config,\n      pagesDir,\n      buildId,\n      previewProps,\n      rewrites,\n    }: {\n      config: NextConfigComplete\n      pagesDir: string\n      buildId: string\n      previewProps: __ApiPreviewProps\n      rewrites: CustomRoutes['rewrites']\n    }\n  ) {\n    this.buildId = buildId\n    this.dir = dir\n    this.middlewares = []\n    this.pagesDir = pagesDir\n    this.webpackHotMiddleware = null\n    this.stats = null\n    this.serverStats = null\n    this.serverPrevDocumentHash = null\n\n    this.config = config\n    this.previewProps = previewProps\n    this.rewrites = rewrites\n    this.isWebpack5 = isWebpack5\n    this.hotReloaderSpan = trace('hot-reloader')\n  }\n\n  public async run(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlObject\n  ): Promise<{ finished?: true }> {\n    // Usually CORS support is not needed for the hot-reloader (this is dev only feature)\n    // With when the app runs for multi-zones support behind a proxy,\n    // the current page is trying to access this URL via assetPrefix.\n    // That's when the CORS support is needed.\n    const { preflight } = addCorsSupport(req, res)\n    if (preflight) {\n      return {}\n    }\n\n    // When a request comes in that is a page bundle, e.g. /_next/static/<buildid>/pages/index.js\n    // we have to compile the page using on-demand-entries, this middleware will handle doing that\n    // by adding the page to on-demand-entries, waiting till it's done\n    // and then the bundle will be served like usual by the actual route in server/index.js\n    const handlePageBundleRequest = async (\n      pageBundleRes: ServerResponse,\n      parsedPageBundleUrl: UrlObject\n    ): Promise<{ finished?: true }> => {\n      const { pathname } = parsedPageBundleUrl\n      const params: { path: string[] } | null =\n        matchNextPageBundleRequest(pathname)\n      if (!params) {\n        return {}\n      }\n\n      let decodedPagePath: string\n\n      try {\n        decodedPagePath = `/${params.path\n          .map((param) => decodeURIComponent(param))\n          .join('/')}`\n      } catch (_) {\n        throw new DecodeError('failed to decode param')\n      }\n\n      const page = denormalizePagePath(decodedPagePath)\n\n      if (page === '/_error' || BLOCKED_PAGES.indexOf(page) === -1) {\n        try {\n          await this.ensurePage(page)\n        } catch (error) {\n          await renderScriptError(pageBundleRes, error)\n          return { finished: true }\n        }\n\n        const errors = await this.getCompilationErrors(page)\n        if (errors.length > 0) {\n          await renderScriptError(pageBundleRes, errors[0], { verbose: false })\n          return { finished: true }\n        }\n      }\n\n      return {}\n    }\n\n    const { finished } = await handlePageBundleRequest(res, parsedUrl)\n\n    for (const fn of this.middlewares) {\n      await new Promise<void>((resolve, reject) => {\n        fn(req, res, (err: Error) => {\n          if (err) return reject(err)\n          resolve()\n        })\n      })\n    }\n\n    return { finished }\n  }\n\n  private async clean(): Promise<void> {\n    return recursiveDelete(join(this.dir, this.config.distDir), /^cache/)\n  }\n\n  private async getWebpackConfig() {\n    const pagePaths = await Promise.all([\n      findPageFile(this.pagesDir, '/_app', this.config.pageExtensions),\n      findPageFile(this.pagesDir, '/_document', this.config.pageExtensions),\n    ])\n\n    const pages = createPagesMapping(\n      pagePaths.filter((i) => i !== null) as string[],\n      this.config.pageExtensions,\n      this.isWebpack5,\n      true\n    )\n    const entrypoints = createEntrypoints(\n      pages,\n      'server',\n      this.buildId,\n      this.previewProps,\n      this.config,\n      []\n    )\n\n    return Promise.all([\n      getBaseWebpackConfig(this.dir, {\n        dev: true,\n        isServer: false,\n        config: this.config,\n        buildId: this.buildId,\n        pagesDir: this.pagesDir,\n        rewrites: this.rewrites,\n        entrypoints: entrypoints.client,\n        runWebpackSpan: this.hotReloaderSpan,\n      }),\n      getBaseWebpackConfig(this.dir, {\n        dev: true,\n        isServer: true,\n        config: this.config,\n        buildId: this.buildId,\n        pagesDir: this.pagesDir,\n        rewrites: this.rewrites,\n        entrypoints: entrypoints.server,\n        runWebpackSpan: this.hotReloaderSpan,\n      }),\n    ])\n  }\n\n  public async buildFallbackError(): Promise<void> {\n    if (this.fallbackWatcher) return\n\n    const fallbackConfig = await getBaseWebpackConfig(this.dir, {\n      runWebpackSpan: this.hotReloaderSpan,\n      dev: true,\n      isServer: false,\n      config: this.config,\n      buildId: this.buildId,\n      pagesDir: this.pagesDir,\n      rewrites: {\n        beforeFiles: [],\n        afterFiles: [],\n        fallback: [],\n      },\n      isDevFallback: true,\n      entrypoints: createEntrypoints(\n        {\n          '/_app': 'next/dist/pages/_app',\n          '/_error': 'next/dist/pages/_error',\n        },\n        'server',\n        this.buildId,\n        this.previewProps,\n        this.config,\n        []\n      ).client,\n    })\n    const fallbackCompiler = webpack(fallbackConfig)\n\n    this.fallbackWatcher = await new Promise((resolve) => {\n      let bootedFallbackCompiler = false\n      fallbackCompiler.watch(\n        // @ts-ignore webpack supports an array of watchOptions when using a multiCompiler\n        fallbackConfig.watchOptions,\n        // Errors are handled separately\n        (_err: any) => {\n          if (!bootedFallbackCompiler) {\n            bootedFallbackCompiler = true\n            resolve(true)\n          }\n        }\n      )\n    })\n  }\n\n  public async start(): Promise<void> {\n    await this.clean()\n\n    const configs = await this.getWebpackConfig()\n\n    for (const config of configs) {\n      const defaultEntry = config.entry\n      config.entry = async (...args) => {\n        // @ts-ignore entry is always a functon\n        const entrypoints = await defaultEntry(...args)\n\n        const isClientCompilation = config.name === 'client'\n\n        await Promise.all(\n          Object.keys(entries).map(async (page) => {\n            if (isClientCompilation && page.match(API_ROUTE)) {\n              return\n            }\n            const { serverBundlePath, clientBundlePath, absolutePagePath } =\n              entries[page]\n            const pageExists = await isWriteable(absolutePagePath)\n            if (!pageExists) {\n              // page was removed\n              delete entries[page]\n              return\n            }\n\n            entries[page].status = BUILDING\n            const pageLoaderOpts: ClientPagesLoaderOptions = {\n              page,\n              absolutePagePath,\n            }\n\n            entrypoints[\n              isClientCompilation ? clientBundlePath : serverBundlePath\n            ] = isClientCompilation\n              ? `next-client-pages-loader?${stringify(pageLoaderOpts)}!`\n              : absolutePagePath\n          })\n        )\n\n        return entrypoints\n      }\n    }\n\n    const multiCompiler = webpack(configs)\n\n    watchCompilers(multiCompiler.compilers[0], multiCompiler.compilers[1])\n\n    // Watch for changes to client/server page files so we can tell when just\n    // the server file changes and trigger a reload for GS(S)P pages\n    const changedClientPages = new Set<string>()\n    const changedServerPages = new Set<string>()\n    const prevClientPageHashes = new Map<string, string>()\n    const prevServerPageHashes = new Map<string, string>()\n\n    const trackPageChanges =\n      (pageHashMap: Map<string, string>, changedItems: Set<string>) =>\n      (stats: webpack.compilation.Compilation) => {\n        stats.entrypoints.forEach((entry, key) => {\n          if (key.startsWith('pages/')) {\n            entry.chunks.forEach((chunk: any) => {\n              if (chunk.id === key) {\n                const prevHash = pageHashMap.get(key)\n\n                if (prevHash && prevHash !== chunk.hash) {\n                  changedItems.add(key)\n                }\n                pageHashMap.set(key, chunk.hash)\n              }\n            })\n          }\n        })\n      }\n\n    multiCompiler.compilers[0].hooks.emit.tap(\n      'NextjsHotReloaderForClient',\n      trackPageChanges(prevClientPageHashes, changedClientPages)\n    )\n    multiCompiler.compilers[1].hooks.emit.tap(\n      'NextjsHotReloaderForServer',\n      trackPageChanges(prevServerPageHashes, changedServerPages)\n    )\n\n    // This plugin watches for changes to _document.js and notifies the client side that it should reload the page\n    multiCompiler.compilers[1].hooks.failed.tap(\n      'NextjsHotReloaderForServer',\n      (err: Error) => {\n        this.serverError = err\n        this.serverStats = null\n      }\n    )\n    multiCompiler.compilers[1].hooks.done.tap(\n      'NextjsHotReloaderForServer',\n      (stats) => {\n        this.serverError = null\n        this.serverStats = stats\n\n        const serverOnlyChanges = difference<string>(\n          changedServerPages,\n          changedClientPages\n        )\n        changedClientPages.clear()\n        changedServerPages.clear()\n\n        if (serverOnlyChanges.length > 0) {\n          this.send({\n            event: 'serverOnlyChanges',\n            pages: serverOnlyChanges.map((pg) =>\n              denormalizePagePath(pg.substr('pages'.length))\n            ),\n          })\n        }\n\n        const { compilation } = stats\n\n        // We only watch `_document` for changes on the server compilation\n        // the rest of the files will be triggered by the client compilation\n        const documentChunk = compilation.namedChunks.get('pages/_document')\n        // If the document chunk can't be found we do nothing\n        if (!documentChunk) {\n          console.warn('_document.js chunk not found')\n          return\n        }\n\n        // Initial value\n        if (this.serverPrevDocumentHash === null) {\n          this.serverPrevDocumentHash = documentChunk.hash\n          return\n        }\n\n        // If _document.js didn't change we don't trigger a reload\n        if (documentChunk.hash === this.serverPrevDocumentHash) {\n          return\n        }\n\n        // Notify reload to reload the page, as _document.js was changed (different hash)\n        this.send('reloadPage')\n        this.serverPrevDocumentHash = documentChunk.hash\n      }\n    )\n\n    multiCompiler.compilers[0].hooks.failed.tap(\n      'NextjsHotReloaderForClient',\n      (err: Error) => {\n        this.clientError = err\n        this.stats = null\n      }\n    )\n    multiCompiler.compilers[0].hooks.done.tap(\n      'NextjsHotReloaderForClient',\n      (stats) => {\n        this.clientError = null\n        this.stats = stats\n\n        const { compilation } = stats\n        const chunkNames = new Set(\n          [...compilation.namedChunks.keys()].filter(\n            (name) => !!getRouteFromEntrypoint(name)\n          )\n        )\n\n        if (this.prevChunkNames) {\n          // detect chunks which have to be replaced with a new template\n          // e.g, pages/index.js <-> pages/_error.js\n          const addedPages = diff(chunkNames, this.prevChunkNames!)\n          const removedPages = diff(this.prevChunkNames!, chunkNames)\n\n          if (addedPages.size > 0) {\n            for (const addedPage of addedPages) {\n              const page = getRouteFromEntrypoint(addedPage)\n              this.send('addedPage', page)\n            }\n          }\n\n          if (removedPages.size > 0) {\n            for (const removedPage of removedPages) {\n              const page = getRouteFromEntrypoint(removedPage)\n              this.send('removedPage', page)\n            }\n          }\n        }\n\n        this.prevChunkNames = chunkNames\n      }\n    )\n\n    this.webpackHotMiddleware = new WebpackHotMiddleware(\n      multiCompiler.compilers\n    )\n\n    let booted = false\n\n    this.watcher = await new Promise((resolve) => {\n      const watcher = multiCompiler.watch(\n        // @ts-ignore webpack supports an array of watchOptions when using a multiCompiler\n        configs.map((config) => config.watchOptions!),\n        // Errors are handled separately\n        (_err: any) => {\n          if (!booted) {\n            booted = true\n            resolve(watcher)\n          }\n        }\n      )\n    })\n\n    this.onDemandEntries = onDemandEntryHandler(this.watcher, multiCompiler, {\n      pagesDir: this.pagesDir,\n      pageExtensions: this.config.pageExtensions,\n      ...(this.config.onDemandEntries as {\n        maxInactiveAge: number\n        pagesBufferLength: number\n      }),\n    })\n\n    this.middlewares = [\n      // must come before hotMiddleware\n      this.onDemandEntries.middleware,\n      this.webpackHotMiddleware.middleware,\n      getOverlayMiddleware({\n        isWebpack5,\n        rootDirectory: this.dir,\n        stats: () => this.stats,\n        serverStats: () => this.serverStats,\n      }),\n    ]\n  }\n\n  public async stop(): Promise<void> {\n    await new Promise((resolve, reject) => {\n      this.watcher.close((err: any) => (err ? reject(err) : resolve(true)))\n    })\n\n    if (this.fallbackWatcher) {\n      await new Promise((resolve, reject) => {\n        this.fallbackWatcher.close((err: any) =>\n          err ? reject(err) : resolve(true)\n        )\n      })\n    }\n  }\n\n  public async getCompilationErrors(page: string) {\n    const normalizedPage = normalizePathSep(page)\n\n    if (this.clientError || this.serverError) {\n      return [this.clientError || this.serverError]\n    } else if (this.stats?.hasErrors()) {\n      const { compilation } = this.stats\n      const failedPages = erroredPages(compilation)\n\n      // If there is an error related to the requesting page we display it instead of the first error\n      if (\n        failedPages[normalizedPage] &&\n        failedPages[normalizedPage].length > 0\n      ) {\n        return failedPages[normalizedPage]\n      }\n\n      // If none were found we still have to show the other errors\n      return this.stats.compilation.errors\n    } else if (this.serverStats?.hasErrors()) {\n      const { compilation } = this.serverStats\n      const failedPages = erroredPages(compilation)\n\n      // If there is an error related to the requesting page we display it instead of the first error\n      if (\n        failedPages[normalizedPage] &&\n        failedPages[normalizedPage].length > 0\n      ) {\n        return failedPages[normalizedPage]\n      }\n\n      // If none were found we still have to show the other errors\n      return this.serverStats.compilation.errors\n    }\n\n    return []\n  }\n\n  public send(action?: string | any, ...args: any[]): void {\n    this.webpackHotMiddleware!.publish(\n      action && typeof action === 'object' ? action : { action, data: args }\n    )\n  }\n\n  public async ensurePage(page: string) {\n    // Make sure we don't re-build or dispose prebuilt pages\n    if (page !== '/_error' && BLOCKED_PAGES.indexOf(page) !== -1) {\n      return\n    }\n    if (this.serverError || this.clientError) {\n      return Promise.reject(this.serverError || this.clientError)\n    }\n    return this.onDemandEntries.ensurePage(page)\n  }\n}\n\nfunction diff(a: Set<any>, b: Set<any>) {\n  return new Set([...a].filter((v) => !b.has(v)))\n}\n"]},"metadata":{},"sourceType":"script"}