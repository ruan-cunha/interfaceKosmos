{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _compression = _interopRequireDefault(require(\"next/dist/compiled/compression\"));\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _httpProxy = _interopRequireDefault(require(\"next/dist/compiled/http-proxy\"));\n\nvar _path = require(\"path\");\n\nvar _querystring = require(\"querystring\");\n\nvar _url = require(\"url\");\n\nvar _zenObservable = _interopRequireDefault(require(\"next/dist/compiled/zen-observable\"));\n\nvar _loadCustomRoutes = require(\"../lib/load-custom-routes\");\n\nvar _constants = require(\"../shared/lib/constants\");\n\nvar _utils = require(\"../shared/lib/router/utils\");\n\nvar envConfig = _interopRequireWildcard(require(\"../shared/lib/runtime-config\"));\n\nvar _utils1 = require(\"../shared/lib/utils\");\n\nvar _apiUtils = require(\"./api-utils\");\n\nvar _config = require(\"./config\");\n\nvar _pathMatch = _interopRequireDefault(require(\"../shared/lib/router/utils/path-match\"));\n\nvar _recursiveReaddirSync = require(\"./lib/recursive-readdir-sync\");\n\nvar _loadComponents = require(\"./load-components\");\n\nvar _normalizePagePath = require(\"./normalize-page-path\");\n\nvar _render = require(\"./render\");\n\nvar _require = require(\"./require\");\n\nvar _router = _interopRequireWildcard(require(\"./router\"));\n\nvar _prepareDestination = _interopRequireWildcard(require(\"../shared/lib/router/utils/prepare-destination\"));\n\nvar _sendPayload = require(\"./send-payload\");\n\nvar _serveStatic = require(\"./serve-static\");\n\nvar _incrementalCache = require(\"./incremental-cache\");\n\nvar _utils2 = require(\"./utils\");\n\nvar _env = require(\"@next/env\");\n\nrequire(\"./node-polyfill-fetch\");\n\nvar _normalizeTrailingSlash = require(\"../client/normalize-trailing-slash\");\n\nvar _getRouteFromAssetPath = _interopRequireDefault(require(\"../shared/lib/router/utils/get-route-from-asset-path\"));\n\nvar _denormalizePagePath = require(\"./denormalize-page-path\");\n\nvar _normalizeLocalePath = require(\"../shared/lib/i18n/normalize-locale-path\");\n\nvar Log = _interopRequireWildcard(require(\"../build/output/log\"));\n\nvar _detectDomainLocale = require(\"../shared/lib/i18n/detect-domain-locale\");\n\nvar _escapePathDelimiters = _interopRequireDefault(require(\"../shared/lib/router/utils/escape-path-delimiters\"));\n\nvar _utils3 = require(\"../build/webpack/loaders/next-serverless-loader/utils\");\n\nvar _responseCache = _interopRequireDefault(require(\"./response-cache\"));\n\nvar _parseNextUrl = require(\"../shared/lib/router/utils/parse-next-url\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nconst getCustomRouteMatcher = (0, _pathMatch).default(true);\n\nclass Server {\n  constructor({\n    dir = '.',\n    quiet = false,\n    conf,\n    dev = false,\n    minimalMode = false,\n    customServer = true\n  }) {\n    var ref, ref1, ref2;\n    this.customErrorNo404Warn = (0, _utils1).execOnce(() => {\n      console.warn(_chalk.default.bold.yellow(`Warning: `) + _chalk.default.yellow(`You have added a custom /_error page without a custom /404 page. This prevents the 404 page from being auto statically optimized.\\nSee here for info: https://nextjs.org/docs/messages/custom-error-no-custom-404`));\n    });\n    this._validFilesystemPathSet = null;\n    this.dir = (0, _path).resolve(dir);\n    this.quiet = quiet;\n    (0, _env).loadEnvConfig(this.dir, dev, Log);\n    this.nextConfig = conf;\n    this.distDir = (0, _path).join(this.dir, this.nextConfig.distDir);\n    this.publicDir = (0, _path).join(this.dir, _constants.CLIENT_PUBLIC_FILES_PATH);\n    this.hasStaticDir = !minimalMode && _fs.default.existsSync((0, _path).join(this.dir, 'static')); // Only serverRuntimeConfig needs the default\n    // publicRuntimeConfig gets it's default in client/index.js\n\n    const {\n      serverRuntimeConfig = {},\n      publicRuntimeConfig,\n      assetPrefix,\n      generateEtags,\n      compress\n    } = this.nextConfig;\n    this.buildId = this.readBuildId();\n    this.minimalMode = minimalMode;\n    this.renderOpts = {\n      poweredByHeader: this.nextConfig.poweredByHeader,\n      canonicalBase: this.nextConfig.amp.canonicalBase || '',\n      buildId: this.buildId,\n      generateEtags,\n      previewProps: this.getPreviewProps(),\n      customServer: customServer === true ? true : undefined,\n      ampOptimizerConfig: (ref = this.nextConfig.experimental.amp) === null || ref === void 0 ? void 0 : ref.optimizer,\n      basePath: this.nextConfig.basePath,\n      images: JSON.stringify(this.nextConfig.images),\n      optimizeFonts: !!this.nextConfig.optimizeFonts && !dev,\n      fontManifest: this.nextConfig.optimizeFonts && !dev ? (0, _require).requireFontManifest(this.distDir, this._isLikeServerless) : null,\n      optimizeImages: !!this.nextConfig.experimental.optimizeImages,\n      optimizeCss: this.nextConfig.experimental.optimizeCss,\n      disableOptimizedLoading: this.nextConfig.experimental.disableOptimizedLoading,\n      domainLocales: (ref1 = this.nextConfig.i18n) === null || ref1 === void 0 ? void 0 : ref1.domains,\n      distDir: this.distDir,\n      concurrentFeatures: this.nextConfig.experimental.concurrentFeatures\n    }; // Only the `publicRuntimeConfig` key is exposed to the client side\n    // It'll be rendered as part of __NEXT_DATA__ on the client side\n\n    if (Object.keys(publicRuntimeConfig).length > 0) {\n      this.renderOpts.runtimeConfig = publicRuntimeConfig;\n    }\n\n    if (compress && this.nextConfig.target === 'server') {\n      this.compression = (0, _compression).default();\n    } // Initialize next/config with the environment configuration\n\n\n    envConfig.setConfig({\n      serverRuntimeConfig,\n      publicRuntimeConfig\n    });\n    this.serverBuildDir = (0, _path).join(this.distDir, this._isLikeServerless ? _constants.SERVERLESS_DIRECTORY : _constants.SERVER_DIRECTORY);\n    const pagesManifestPath = (0, _path).join(this.serverBuildDir, _constants.PAGES_MANIFEST);\n\n    if (!dev) {\n      this.pagesManifest = require(pagesManifestPath);\n    }\n\n    this.customRoutes = this.getCustomRoutes();\n    this.router = new _router.default(this.generateRoutes());\n    this.setAssetPrefix(assetPrefix);\n    this.incrementalCache = new _incrementalCache.IncrementalCache({\n      dev,\n      distDir: this.distDir,\n      pagesDir: (0, _path).join(this.distDir, this._isLikeServerless ? _constants.SERVERLESS_DIRECTORY : _constants.SERVER_DIRECTORY, 'pages'),\n      locales: (ref2 = this.nextConfig.i18n) === null || ref2 === void 0 ? void 0 : ref2.locales,\n      max: this.nextConfig.experimental.isrMemoryCacheSize,\n      flushToDisk: !minimalMode && this.nextConfig.experimental.isrFlushToDisk\n    });\n    this.responseCache = new _responseCache.default(this.incrementalCache);\n    /**\n    * This sets environment variable to be used at the time of SSR by head.tsx.\n    * Using this from process.env allows targeting both serverless and SSR by calling\n    * `process.env.__NEXT_OPTIMIZE_IMAGES`.\n    * TODO(atcastle@): Remove this when experimental.optimizeImages are being cleaned up.\n    */\n\n    if (this.renderOpts.optimizeFonts) {\n      process.env.__NEXT_OPTIMIZE_FONTS = JSON.stringify(true);\n    }\n\n    if (this.renderOpts.optimizeImages) {\n      process.env.__NEXT_OPTIMIZE_IMAGES = JSON.stringify(true);\n    }\n\n    if (this.renderOpts.optimizeCss) {\n      process.env.__NEXT_OPTIMIZE_CSS = JSON.stringify(true);\n    }\n  }\n\n  logError(err) {\n    if (this.quiet) return;\n    console.error(err);\n  }\n\n  async handleRequest(req, res, parsedUrl) {\n    var ref3, ref4, ref5, ref6, ref7, ref8;\n    const urlParts = (req.url || '').split('?');\n    const urlNoQuery = urlParts[0];\n\n    if (urlNoQuery === null || urlNoQuery === void 0 ? void 0 : urlNoQuery.match(/(\\\\|\\/\\/)/)) {\n      const cleanUrl = (0, _utils1).normalizeRepeatedSlashes(req.url);\n      res.setHeader('Location', cleanUrl);\n      res.setHeader('Refresh', `0;url=${cleanUrl}`);\n      res.statusCode = 308;\n      res.end(cleanUrl);\n      return;\n    }\n\n    (0, _apiUtils).setLazyProp({\n      req: req\n    }, 'cookies', (0, _apiUtils).getCookieParser(req.headers)); // Parse url if parsedUrl not provided\n\n    if (!parsedUrl || typeof parsedUrl !== 'object') {\n      const url = req.url;\n      parsedUrl = (0, _url).parse(url, true);\n    }\n\n    const {\n      basePath,\n      i18n\n    } = this.nextConfig; // Parse the querystring ourselves if the user doesn't handle querystring parsing\n\n    if (typeof parsedUrl.query === 'string') {\n      parsedUrl.query = (0, _querystring).parse(parsedUrl.query);\n    }\n\n    req.__NEXT_INIT_QUERY = Object.assign({}, parsedUrl.query);\n    const url = (0, _parseNextUrl).parseNextUrl({\n      headers: req.headers,\n      nextConfig: this.nextConfig,\n      url: (ref3 = req.url) === null || ref3 === void 0 ? void 0 : ref3.replace(/^\\/+/, '/')\n    });\n\n    if (url.basePath) {\n      req._nextHadBasePath = true;\n      req.url = req.url.replace(basePath, '') || '/';\n    }\n\n    if (this.minimalMode && req.headers['x-matched-path'] && typeof req.headers['x-matched-path'] === 'string') {\n      var ref9, ref10;\n      const reqUrlIsDataUrl = (ref9 = req.url) === null || ref9 === void 0 ? void 0 : ref9.includes('/_next/data');\n      const matchedPathIsDataUrl = (ref10 = req.headers['x-matched-path']) === null || ref10 === void 0 ? void 0 : ref10.includes('/_next/data');\n      const isDataUrl = reqUrlIsDataUrl || matchedPathIsDataUrl;\n      let parsedPath = (0, _url).parse(isDataUrl ? req.url : req.headers['x-matched-path'], true);\n      const {\n        pathname,\n        query\n      } = parsedPath;\n      let matchedPathname = pathname;\n      let matchedPathnameNoExt = isDataUrl ? matchedPathname.replace(/\\.json$/, '') : matchedPathname;\n\n      if (i18n) {\n        const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(matchedPathname || '/', i18n.locales);\n\n        if (localePathResult.detectedLocale) {\n          parsedUrl.query.__nextLocale = localePathResult.detectedLocale;\n        }\n      }\n\n      if (isDataUrl) {\n        matchedPathname = (0, _denormalizePagePath).denormalizePagePath(matchedPathname);\n        matchedPathnameNoExt = (0, _denormalizePagePath).denormalizePagePath(matchedPathnameNoExt);\n      }\n\n      const pageIsDynamic = (0, _utils).isDynamicRoute(matchedPathnameNoExt);\n      const combinedRewrites = [];\n      combinedRewrites.push(...this.customRoutes.rewrites.beforeFiles);\n      combinedRewrites.push(...this.customRoutes.rewrites.afterFiles);\n      combinedRewrites.push(...this.customRoutes.rewrites.fallback);\n      const utils = (0, _utils3).getUtils({\n        pageIsDynamic,\n        page: matchedPathnameNoExt,\n        i18n: this.nextConfig.i18n,\n        basePath: this.nextConfig.basePath,\n        rewrites: combinedRewrites\n      });\n      utils.handleRewrites(req, parsedUrl); // interpolate dynamic params and normalize URL if needed\n\n      if (pageIsDynamic) {\n        let params = {};\n        Object.assign(parsedUrl.query, query);\n        const paramsResult = utils.normalizeDynamicRouteParams(parsedUrl.query);\n\n        if (paramsResult.hasValidParams) {\n          params = paramsResult.params;\n        } else if (req.headers['x-now-route-matches']) {\n          const opts = {};\n          params = utils.getParamsFromRouteMatches(req, opts, parsedUrl.query.__nextLocale || '');\n\n          if (opts.locale) {\n            parsedUrl.query.__nextLocale = opts.locale;\n          }\n        } else {\n          params = utils.dynamicRouteMatcher(matchedPathnameNoExt);\n        }\n\n        if (params) {\n          params = utils.normalizeDynamicRouteParams(params).params;\n          matchedPathname = utils.interpolateDynamicPath(matchedPathname, params);\n          req.url = utils.interpolateDynamicPath(req.url, params);\n        }\n\n        if (reqUrlIsDataUrl && matchedPathIsDataUrl) {\n          req.url = (0, _url).format({ ...parsedPath,\n            pathname: matchedPathname\n          });\n        }\n\n        Object.assign(parsedUrl.query, params);\n        utils.normalizeVercelUrl(req, true);\n      }\n\n      parsedUrl.pathname = `${basePath || ''}${matchedPathname === '/' && basePath ? '' : matchedPathname}`;\n    }\n\n    req.__nextHadTrailingSlash = (ref4 = url.locale) === null || ref4 === void 0 ? void 0 : ref4.trailingSlash;\n\n    if ((ref5 = url.locale) === null || ref5 === void 0 ? void 0 : ref5.domain) {\n      req.__nextIsLocaleDomain = true;\n    }\n\n    if ((ref6 = url.locale) === null || ref6 === void 0 ? void 0 : ref6.path.detectedLocale) {\n      req.url = (0, _url).format(url);\n      req.__nextStrippedLocale = true;\n\n      if (url.pathname === '/api' || url.pathname.startsWith('/api/')) {\n        return this.render404(req, res, parsedUrl);\n      }\n    }\n\n    if (!this.minimalMode || !parsedUrl.query.__nextLocale) {\n      var ref11;\n\n      if (url === null || url === void 0 ? void 0 : (ref11 = url.locale) === null || ref11 === void 0 ? void 0 : ref11.locale) {\n        parsedUrl.query.__nextLocale = url.locale.locale;\n      }\n    }\n\n    if (url === null || url === void 0 ? void 0 : (ref7 = url.locale) === null || ref7 === void 0 ? void 0 : ref7.defaultLocale) {\n      parsedUrl.query.__nextDefaultLocale = url.locale.defaultLocale;\n    }\n\n    if ((ref8 = url.locale) === null || ref8 === void 0 ? void 0 : ref8.redirect) {\n      res.setHeader('Location', url.locale.redirect);\n      res.statusCode = _constants.TEMPORARY_REDIRECT_STATUS;\n      res.end();\n      return;\n    }\n\n    res.statusCode = 200;\n\n    try {\n      return await this.run(req, res, parsedUrl);\n    } catch (err) {\n      if (this.minimalMode || this.renderOpts.dev) {\n        throw err;\n      }\n\n      this.logError(err);\n      res.statusCode = 500;\n      res.end('Internal Server Error');\n    }\n  }\n\n  getRequestHandler() {\n    return this.handleRequest.bind(this);\n  }\n\n  setAssetPrefix(prefix) {\n    this.renderOpts.assetPrefix = prefix ? prefix.replace(/\\/$/, '') : '';\n  } // Backwards compatibility\n\n\n  async prepare() {} // Backwards compatibility\n\n\n  async close() {}\n\n  setImmutableAssetCacheControl(res) {\n    res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');\n  }\n\n  getCustomRoutes() {\n    const customRoutes = require((0, _path).join(this.distDir, _constants.ROUTES_MANIFEST));\n\n    let rewrites; // rewrites can be stored as an array when an array is\n    // returned in next.config.js so massage them into\n    // the expected object format\n\n    if (Array.isArray(customRoutes.rewrites)) {\n      rewrites = {\n        beforeFiles: [],\n        afterFiles: customRoutes.rewrites,\n        fallback: []\n      };\n    } else {\n      rewrites = customRoutes.rewrites;\n    }\n\n    return Object.assign(customRoutes, {\n      rewrites\n    });\n  }\n\n  getPrerenderManifest() {\n    if (this._cachedPreviewManifest) {\n      return this._cachedPreviewManifest;\n    }\n\n    const manifest = require((0, _path).join(this.distDir, _constants.PRERENDER_MANIFEST));\n\n    return this._cachedPreviewManifest = manifest;\n  }\n\n  getPreviewProps() {\n    return this.getPrerenderManifest().preview;\n  }\n\n  generateRoutes() {\n    var ref12;\n    const server = this;\n    const publicRoutes = _fs.default.existsSync(this.publicDir) ? this.generatePublicRoutes() : [];\n    const staticFilesRoute = this.hasStaticDir ? [{\n      // It's very important to keep this route's param optional.\n      // (but it should support as many params as needed, separated by '/')\n      // Otherwise this will lead to a pretty simple DOS attack.\n      // See more: https://github.com/vercel/next.js/issues/2617\n      match: (0, _router).route('/static/:path*'),\n      name: 'static catchall',\n      fn: async (req, res, params, parsedUrl) => {\n        const p = (0, _path).join(this.dir, 'static', ...params.path);\n        await this.serveStatic(req, res, p, parsedUrl);\n        return {\n          finished: true\n        };\n      }\n    }] : [];\n    const fsRoutes = [{\n      match: (0, _router).route('/_next/static/:path*'),\n      type: 'route',\n      name: '_next/static catchall',\n      fn: async (req, res, params, parsedUrl) => {\n        // make sure to 404 for /_next/static itself\n        if (!params.path) {\n          await this.render404(req, res, parsedUrl);\n          return {\n            finished: true\n          };\n        }\n\n        if (params.path[0] === _constants.CLIENT_STATIC_FILES_RUNTIME || params.path[0] === 'chunks' || params.path[0] === 'css' || params.path[0] === 'image' || params.path[0] === 'media' || params.path[0] === this.buildId || params.path[0] === 'pages' || params.path[1] === 'pages') {\n          this.setImmutableAssetCacheControl(res);\n        }\n\n        const p = (0, _path).join(this.distDir, _constants.CLIENT_STATIC_FILES_PATH, ...(params.path || []));\n        await this.serveStatic(req, res, p, parsedUrl);\n        return {\n          finished: true\n        };\n      }\n    }, {\n      match: (0, _router).route('/_next/data/:path*'),\n      type: 'route',\n      name: '_next/data catchall',\n      fn: async (req, res, params, _parsedUrl) => {\n        // Make sure to 404 for /_next/data/ itself and\n        // we also want to 404 if the buildId isn't correct\n        if (!params.path || params.path[0] !== this.buildId) {\n          await this.render404(req, res, _parsedUrl);\n          return {\n            finished: true\n          };\n        } // remove buildId from URL\n\n\n        params.path.shift(); // show 404 if it doesn't end with .json\n\n        if (!params.path[params.path.length - 1].endsWith('.json')) {\n          await this.render404(req, res, _parsedUrl);\n          return {\n            finished: true\n          };\n        } // re-create page's pathname\n\n\n        let pathname = `/${params.path.join('/')}`;\n        pathname = (0, _getRouteFromAssetPath).default(pathname, '.json');\n        const {\n          i18n\n        } = this.nextConfig;\n\n        if (i18n) {\n          const {\n            host\n          } = (req === null || req === void 0 ? void 0 : req.headers) || {}; // remove port from host and remove port if present\n\n          const hostname = host === null || host === void 0 ? void 0 : host.split(':')[0].toLowerCase();\n          const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(pathname, i18n.locales);\n          const {\n            defaultLocale\n          } = (0, _detectDomainLocale).detectDomainLocale(i18n.domains, hostname) || {};\n          let detectedLocale = '';\n\n          if (localePathResult.detectedLocale) {\n            pathname = localePathResult.pathname;\n            detectedLocale = localePathResult.detectedLocale;\n          }\n\n          _parsedUrl.query.__nextLocale = detectedLocale;\n          _parsedUrl.query.__nextDefaultLocale = defaultLocale || i18n.defaultLocale;\n\n          if (!detectedLocale) {\n            _parsedUrl.query.__nextLocale = _parsedUrl.query.__nextDefaultLocale;\n            await this.render404(req, res, _parsedUrl);\n            return {\n              finished: true\n            };\n          }\n        }\n\n        const parsedUrl = (0, _url).parse(pathname, true);\n        await this.render(req, res, pathname, { ..._parsedUrl.query,\n          _nextDataReq: '1'\n        }, parsedUrl);\n        return {\n          finished: true\n        };\n      }\n    }, {\n      match: (0, _router).route('/_next/image'),\n      type: 'route',\n      name: '_next/image catchall',\n      fn: (req, res, _params, parsedUrl) => {\n        if (this.minimalMode) {\n          res.statusCode = 400;\n          res.end('Bad Request');\n          return {\n            finished: true\n          };\n        }\n\n        const {\n          imageOptimizer\n        } = require('./image-optimizer');\n\n        return imageOptimizer(server, req, res, parsedUrl, server.nextConfig, server.distDir, this.renderOpts.dev);\n      }\n    }, {\n      match: (0, _router).route('/_next/:path*'),\n      type: 'route',\n      name: '_next catchall',\n      // This path is needed because `render()` does a check for `/_next` and the calls the routing again\n      fn: async (req, res, _params, parsedUrl) => {\n        await this.render404(req, res, parsedUrl);\n        return {\n          finished: true\n        };\n      }\n    }, ...publicRoutes, ...staticFilesRoute];\n    const restrictedRedirectPaths = ['/_next'].map(p => this.nextConfig.basePath ? `${this.nextConfig.basePath}${p}` : p);\n\n    const getCustomRoute = (r, type) => {\n      const match = getCustomRouteMatcher(r.source, !r.internal ? regex => (0, _loadCustomRoutes).modifyRouteRegex(regex, type === 'redirect' ? restrictedRedirectPaths : undefined) : undefined);\n      return { ...r,\n        type,\n        match,\n        name: type,\n        fn: async (_req, _res, _params, _parsedUrl) => ({\n          finished: false\n        })\n      };\n    }; // Headers come very first\n\n\n    const headers = this.minimalMode ? [] : this.customRoutes.headers.map(r => {\n      const headerRoute = getCustomRoute(r, 'header');\n      return {\n        match: headerRoute.match,\n        has: headerRoute.has,\n        type: headerRoute.type,\n        name: `${headerRoute.type} ${headerRoute.source} header route`,\n        fn: async (_req, res, params, _parsedUrl) => {\n          const hasParams = Object.keys(params).length > 0;\n\n          for (const header of headerRoute.headers) {\n            let {\n              key,\n              value\n            } = header;\n\n            if (hasParams) {\n              key = (0, _prepareDestination).compileNonPath(key, params);\n              value = (0, _prepareDestination).compileNonPath(value, params);\n            }\n\n            res.setHeader(key, value);\n          }\n\n          return {\n            finished: false\n          };\n        }\n      };\n    }); // since initial query values are decoded by querystring.parse\n    // we need to re-encode them here but still allow passing through\n    // values from rewrites/redirects\n\n    const stringifyQuery = (req, query) => {\n      const initialQueryValues = Object.values(req.__NEXT_INIT_QUERY);\n      return (0, _querystring).stringify(query, undefined, undefined, {\n        encodeURIComponent(value) {\n          if (initialQueryValues.some(val => val === value)) {\n            return encodeURIComponent(value);\n          }\n\n          return value;\n        }\n\n      });\n    };\n\n    const redirects = this.minimalMode ? [] : this.customRoutes.redirects.map(redirect => {\n      const redirectRoute = getCustomRoute(redirect, 'redirect');\n      return {\n        internal: redirectRoute.internal,\n        type: redirectRoute.type,\n        match: redirectRoute.match,\n        has: redirectRoute.has,\n        statusCode: redirectRoute.statusCode,\n        name: `Redirect route ${redirectRoute.source}`,\n        fn: async (req, res, params, parsedUrl) => {\n          const {\n            parsedDestination\n          } = (0, _prepareDestination).default(redirectRoute.destination, params, parsedUrl.query, false);\n          const {\n            query\n          } = parsedDestination;\n          delete parsedDestination.query;\n          parsedDestination.search = stringifyQuery(req, query);\n          let updatedDestination = (0, _url).format(parsedDestination);\n\n          if (updatedDestination.startsWith('/')) {\n            updatedDestination = (0, _utils1).normalizeRepeatedSlashes(updatedDestination);\n          }\n\n          res.setHeader('Location', updatedDestination);\n          res.statusCode = (0, _loadCustomRoutes).getRedirectStatus(redirectRoute); // Since IE11 doesn't support the 308 header add backwards\n          // compatibility using refresh header\n\n          if (res.statusCode === 308) {\n            res.setHeader('Refresh', `0;url=${updatedDestination}`);\n          }\n\n          res.end(updatedDestination);\n          return {\n            finished: true\n          };\n        }\n      };\n    });\n\n    const buildRewrite = (rewrite, check = true) => {\n      const rewriteRoute = getCustomRoute(rewrite, 'rewrite');\n      return { ...rewriteRoute,\n        check,\n        type: rewriteRoute.type,\n        name: `Rewrite route ${rewriteRoute.source}`,\n        match: rewriteRoute.match,\n        fn: async (req, res, params, parsedUrl) => {\n          const {\n            newUrl,\n            parsedDestination\n          } = (0, _prepareDestination).default(rewriteRoute.destination, params, parsedUrl.query, true); // external rewrite, proxy it\n\n          if (parsedDestination.protocol) {\n            const {\n              query\n            } = parsedDestination;\n            delete parsedDestination.query;\n            parsedDestination.search = stringifyQuery(req, query);\n            const target = (0, _url).format(parsedDestination);\n            const proxy = new _httpProxy.default({\n              target,\n              changeOrigin: true,\n              ignorePath: true,\n              xfwd: true,\n              proxyTimeout: 30000\n            });\n            await new Promise((proxyResolve, proxyReject) => {\n              let finished = false;\n              proxy.on('proxyReq', proxyReq => {\n                proxyReq.on('close', () => {\n                  if (!finished) {\n                    finished = true;\n                    proxyResolve(true);\n                  }\n                });\n              });\n              proxy.on('error', err => {\n                if (!finished) {\n                  finished = true;\n                  proxyReject(err);\n                }\n              });\n              proxy.web(req, res);\n            });\n            return {\n              finished: true\n            };\n          }\n\n          req._nextRewroteUrl = newUrl;\n          req._nextDidRewrite = req._nextRewroteUrl !== req.url;\n          return {\n            finished: false,\n            pathname: newUrl,\n            query: parsedDestination.query\n          };\n        }\n      };\n    };\n\n    let beforeFiles = [];\n    let afterFiles = [];\n    let fallback = [];\n\n    if (!this.minimalMode) {\n      if (Array.isArray(this.customRoutes.rewrites)) {\n        afterFiles = this.customRoutes.rewrites.map(r => buildRewrite(r));\n      } else {\n        beforeFiles = this.customRoutes.rewrites.beforeFiles.map(r => buildRewrite(r, false));\n        afterFiles = this.customRoutes.rewrites.afterFiles.map(r => buildRewrite(r));\n        fallback = this.customRoutes.rewrites.fallback.map(r => buildRewrite(r));\n      }\n    }\n\n    const catchAllRoute = {\n      match: (0, _router).route('/:path*'),\n      type: 'route',\n      name: 'Catchall render',\n      fn: async (req, res, _params, parsedUrl) => {\n        let {\n          pathname,\n          query\n        } = parsedUrl;\n\n        if (!pathname) {\n          throw new Error('pathname is undefined');\n        } // next.js core assumes page path without trailing slash\n\n\n        pathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n\n        if (this.nextConfig.i18n) {\n          var ref13;\n          const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(pathname, (ref13 = this.nextConfig.i18n) === null || ref13 === void 0 ? void 0 : ref13.locales);\n\n          if (localePathResult.detectedLocale) {\n            pathname = localePathResult.pathname;\n            parsedUrl.query.__nextLocale = localePathResult.detectedLocale;\n          }\n        }\n\n        const bubbleNoFallback = !!query._nextBubbleNoFallback;\n\n        if (pathname === '/api' || pathname.startsWith('/api/')) {\n          delete query._nextBubbleNoFallback;\n          const handled = await this.handleApiRequest(req, res, pathname, query);\n\n          if (handled) {\n            return {\n              finished: true\n            };\n          }\n        }\n\n        try {\n          await this.render(req, res, pathname, query, parsedUrl);\n          return {\n            finished: true\n          };\n        } catch (err) {\n          if (err instanceof NoFallbackError && bubbleNoFallback) {\n            return {\n              finished: false\n            };\n          }\n\n          throw err;\n        }\n      }\n    };\n    const {\n      useFileSystemPublicRoutes\n    } = this.nextConfig;\n\n    if (useFileSystemPublicRoutes) {\n      this.dynamicRoutes = this.getDynamicRoutes();\n    }\n\n    return {\n      headers,\n      fsRoutes,\n      rewrites: {\n        beforeFiles,\n        afterFiles,\n        fallback\n      },\n      redirects,\n      catchAllRoute,\n      useFileSystemPublicRoutes,\n      dynamicRoutes: this.dynamicRoutes,\n      basePath: this.nextConfig.basePath,\n      pageChecker: this.hasPage.bind(this),\n      locales: ((ref12 = this.nextConfig.i18n) === null || ref12 === void 0 ? void 0 : ref12.locales) || []\n    };\n  }\n\n  async getPagePath(pathname, locales) {\n    return (0, _require).getPagePath(pathname, this.distDir, this._isLikeServerless, this.renderOpts.dev, locales);\n  }\n\n  async hasPage(pathname) {\n    let found = false;\n\n    try {\n      var ref14;\n      found = !!(await this.getPagePath(pathname, (ref14 = this.nextConfig.i18n) === null || ref14 === void 0 ? void 0 : ref14.locales));\n    } catch (_) {}\n\n    return found;\n  }\n\n  async _beforeCatchAllRender(_req, _res, _params, _parsedUrl) {\n    return false;\n  } // Used to build API page in development\n\n\n  async ensureApiPage(_pathname) {}\n  /**\n  * Resolves `API` request, in development builds on demand\n  * @param req http request\n  * @param res http response\n  * @param pathname path of request\n  */\n\n\n  async handleApiRequest(req, res, pathname, query) {\n    let page = pathname;\n    let params = false;\n    let pageFound = await this.hasPage(page);\n\n    if (!pageFound && this.dynamicRoutes) {\n      for (const dynamicRoute of this.dynamicRoutes) {\n        params = dynamicRoute.match(pathname);\n\n        if (dynamicRoute.page.startsWith('/api') && params) {\n          page = dynamicRoute.page;\n          pageFound = true;\n          break;\n        }\n      }\n    }\n\n    if (!pageFound) {\n      return false;\n    } // Make sure the page is built before getting the path\n    // or else it won't be in the manifest yet\n\n\n    await this.ensureApiPage(page);\n    let builtPagePath;\n\n    try {\n      builtPagePath = await this.getPagePath(page);\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        return false;\n      }\n\n      throw err;\n    }\n\n    const pageModule = await require(builtPagePath);\n    query = { ...query,\n      ...params\n    };\n    delete query.__nextLocale;\n    delete query.__nextDefaultLocale;\n\n    if (!this.renderOpts.dev && this._isLikeServerless) {\n      if (typeof pageModule.default === 'function') {\n        prepareServerlessUrl(req, query);\n        await pageModule.default(req, res);\n        return true;\n      }\n    }\n\n    await (0, _apiUtils).apiResolver(req, res, query, pageModule, this.renderOpts.previewProps, this.minimalMode, this.renderOpts.dev, page);\n    return true;\n  }\n\n  generatePublicRoutes() {\n    const publicFiles = new Set((0, _recursiveReaddirSync).recursiveReadDirSync(this.publicDir).map(p => encodeURI(p.replace(/\\\\/g, '/'))));\n    return [{\n      match: (0, _router).route('/:path*'),\n      name: 'public folder catchall',\n      fn: async (req, res, params, parsedUrl) => {\n        const pathParts = params.path || [];\n        const {\n          basePath\n        } = this.nextConfig; // if basePath is defined require it be present\n\n        if (basePath) {\n          const basePathParts = basePath.split('/'); // remove first empty value\n\n          basePathParts.shift();\n\n          if (!basePathParts.every((part, idx) => {\n            return part === pathParts[idx];\n          })) {\n            return {\n              finished: false\n            };\n          }\n\n          pathParts.splice(0, basePathParts.length);\n        }\n\n        let path = `/${pathParts.join('/')}`;\n\n        if (!publicFiles.has(path)) {\n          // In `next-dev-server.ts`, we ensure encoded paths match\n          // decoded paths on the filesystem. So we need do the\n          // opposite here: make sure decoded paths match encoded.\n          path = encodeURI(path);\n        }\n\n        if (publicFiles.has(path)) {\n          await this.serveStatic(req, res, (0, _path).join(this.publicDir, ...pathParts), parsedUrl);\n          return {\n            finished: true\n          };\n        }\n\n        return {\n          finished: false\n        };\n      }\n    }];\n  }\n\n  getDynamicRoutes() {\n    const addedPages = new Set();\n    return (0, _utils).getSortedRoutes(Object.keys(this.pagesManifest).map(page => {\n      var ref15;\n      return (0, _normalizeLocalePath).normalizeLocalePath(page, (ref15 = this.nextConfig.i18n) === null || ref15 === void 0 ? void 0 : ref15.locales).pathname;\n    })).map(page => {\n      if (addedPages.has(page) || !(0, _utils).isDynamicRoute(page)) return null;\n      addedPages.add(page);\n      return {\n        page,\n        match: (0, _utils).getRouteMatcher((0, _utils).getRouteRegex(page))\n      };\n    }).filter(item => Boolean(item));\n  }\n\n  handleCompression(req, res) {\n    if (this.compression) {\n      this.compression(req, res, () => {});\n    }\n  }\n\n  async run(req, res, parsedUrl) {\n    this.handleCompression(req, res);\n\n    try {\n      const matched = await this.router.execute(req, res, parsedUrl);\n\n      if (matched) {\n        return;\n      }\n    } catch (err) {\n      if (err instanceof _utils1.DecodeError) {\n        res.statusCode = 400;\n        return this.renderError(null, req, res, '/_error', {});\n      }\n\n      throw err;\n    }\n\n    await this.render404(req, res, parsedUrl);\n  }\n\n  async pipe(fn, partialContext) {\n    // TODO: Determine when dynamic HTML is allowed\n    const requireStaticHTML = true;\n    const ctx = { ...partialContext,\n      renderOpts: { ...this.renderOpts,\n        requireStaticHTML\n      }\n    };\n    const payload = await fn(ctx);\n\n    if (payload === null) {\n      return;\n    }\n\n    const {\n      req,\n      res\n    } = ctx;\n    const {\n      body,\n      type,\n      revalidateOptions\n    } = payload;\n\n    if (!(0, _utils1).isResSent(res)) {\n      const {\n        generateEtags: generateEtags1,\n        poweredByHeader,\n        dev: dev1\n      } = this.renderOpts;\n\n      if (dev1) {\n        // In dev, we should not cache pages for any reason.\n        res.setHeader('Cache-Control', 'no-store, must-revalidate');\n      }\n\n      return (0, _sendPayload).sendRenderResult({\n        req,\n        res,\n        resultOrPayload: requireStaticHTML ? await (0, _utils2).resultsToString([body]) : body,\n        type,\n        generateEtags: generateEtags1,\n        poweredByHeader,\n        options: revalidateOptions\n      });\n    }\n  }\n\n  async getStaticHTML(fn, partialContext) {\n    const payload = await fn({ ...partialContext,\n      renderOpts: { ...this.renderOpts,\n        requireStaticHTML: true\n      }\n    });\n\n    if (payload === null) {\n      return null;\n    }\n\n    return (0, _utils2).resultsToString([payload.body]);\n  }\n\n  async render(req, res, pathname, query = {}, parsedUrl) {\n    if (!pathname.startsWith('/')) {\n      console.warn(`Cannot render page with path \"${pathname}\", did you mean \"/${pathname}\"?. See more info here: https://nextjs.org/docs/messages/render-no-starting-slash`);\n    }\n\n    if (this.renderOpts.customServer && pathname === '/index' && !(await this.hasPage('/index'))) {\n      // maintain backwards compatibility for custom server\n      // (see custom-server integration tests)\n      pathname = '/';\n    }\n\n    const url = req.url; // we allow custom servers to call render for all URLs\n    // so check if we need to serve a static _next file or not.\n    // we don't modify the URL for _next/data request but still\n    // call render so we special case this to prevent an infinite loop\n\n    if (!this.minimalMode && !query._nextDataReq && (url.match(/^\\/_next\\//) || this.hasStaticDir && url.match(/^\\/static\\//))) {\n      return this.handleRequest(req, res, parsedUrl);\n    } // Custom server users can run `app.render()` which needs compression.\n\n\n    if (this.renderOpts.customServer) {\n      this.handleCompression(req, res);\n    }\n\n    if ((0, _utils2).isBlockedPage(pathname)) {\n      return this.render404(req, res, parsedUrl);\n    }\n\n    return this.pipe(ctx => this.renderToResponse(ctx), {\n      req,\n      res,\n      pathname,\n      query\n    });\n  }\n\n  async findPageComponents(pathname, query = {}, params = null) {\n    let paths = [// try serving a static AMP version first\n    query.amp ? (0, _normalizePagePath).normalizePagePath(pathname) + '.amp' : null, pathname].filter(Boolean);\n\n    if (query.__nextLocale) {\n      paths = [...paths.map(path => `/${query.__nextLocale}${path === '/' ? '' : path}`), ...paths];\n    }\n\n    for (const pagePath of paths) {\n      try {\n        const components = await (0, _loadComponents).loadComponents(this.distDir, pagePath, !this.renderOpts.dev && this._isLikeServerless);\n\n        if (query.__nextLocale && typeof components.Component === 'string' && !(pagePath === null || pagePath === void 0 ? void 0 : pagePath.startsWith(`/${query.__nextLocale}`))) {\n          continue;\n        }\n\n        return {\n          components,\n          query: { ...(components.getStaticProps ? {\n              amp: query.amp,\n              _nextDataReq: query._nextDataReq,\n              __nextLocale: query.__nextLocale,\n              __nextDefaultLocale: query.__nextDefaultLocale\n            } : query),\n            ...(params || {})\n          }\n        };\n      } catch (err) {\n        if (err.code !== 'ENOENT') throw err;\n      }\n    }\n\n    return null;\n  }\n\n  async getStaticPaths(pathname) {\n    // `staticPaths` is intentionally set to `undefined` as it should've\n    // been caught when checking disk data.\n    const staticPaths = undefined; // Read whether or not fallback should exist from the manifest.\n\n    const fallbackField = this.getPrerenderManifest().dynamicRoutes[pathname].fallback;\n    return {\n      staticPaths,\n      fallbackMode: typeof fallbackField === 'string' ? 'static' : fallbackField === null ? 'blocking' : false\n    };\n  }\n\n  async renderToResponseWithComponents({\n    req,\n    res,\n    pathname,\n    renderOpts: opts\n  }, {\n    components,\n    query\n  }) {\n    var ref16, ref17;\n    const is404Page = pathname === '/404';\n    const is500Page = pathname === '/500';\n    const isLikeServerless = typeof components.Component === 'object' && typeof components.Component.renderReqToHTML === 'function';\n    const isSSG = !!components.getStaticProps;\n    const hasServerProps = !!components.getServerSideProps;\n    const hasStaticPaths = !!components.getStaticPaths;\n    const hasGetInitialProps = !!components.Component.getInitialProps; // Toggle whether or not this is a Data request\n\n    const isDataReq = !!query._nextDataReq && (isSSG || hasServerProps);\n    delete query._nextDataReq; // we need to ensure the status code if /404 is visited directly\n\n    if (is404Page && !isDataReq) {\n      res.statusCode = 404;\n    } // ensure correct status is set when visiting a status page\n    // directly e.g. /500\n\n\n    if (_constants.STATIC_STATUS_PAGES.includes(pathname)) {\n      res.statusCode = parseInt(pathname.substr(1), 10);\n    } // handle static page\n\n\n    if (typeof components.Component === 'string') {\n      return {\n        type: 'html',\n        // TODO: Static pages should be written as chunks\n        body: _zenObservable.default.of(components.Component)\n      };\n    }\n\n    if (!query.amp) {\n      delete query.amp;\n    }\n\n    const locale = query.__nextLocale;\n    const defaultLocale = isSSG ? (ref16 = this.nextConfig.i18n) === null || ref16 === void 0 ? void 0 : ref16.defaultLocale : query.__nextDefaultLocale;\n    const {\n      i18n\n    } = this.nextConfig;\n    const locales = i18n === null || i18n === void 0 ? void 0 : i18n.locales;\n    let previewData;\n    let isPreviewMode = false;\n\n    if (hasServerProps || isSSG) {\n      previewData = (0, _apiUtils).tryGetPreviewData(req, res, this.renderOpts.previewProps);\n      isPreviewMode = previewData !== false;\n    } // Compute the iSSG cache key. We use the rewroteUrl since\n    // pages with fallback: false are allowed to be rewritten to\n    // and we need to look up the path by the rewritten path\n\n\n    let urlPathname = (0, _url).parse(req.url || '').pathname || '/';\n    let resolvedUrlPathname = req._nextRewroteUrl ? req._nextRewroteUrl : urlPathname;\n    urlPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(urlPathname);\n    resolvedUrlPathname = (0, _normalizeLocalePath).normalizeLocalePath((0, _normalizeTrailingSlash).removePathTrailingSlash(resolvedUrlPathname), (ref17 = this.nextConfig.i18n) === null || ref17 === void 0 ? void 0 : ref17.locales).pathname;\n\n    const stripNextDataPath = path => {\n      if (path.includes(this.buildId)) {\n        const splitPath = path.substring(path.indexOf(this.buildId) + this.buildId.length);\n        path = (0, _denormalizePagePath).denormalizePagePath(splitPath.replace(/\\.json$/, ''));\n      }\n\n      if (this.nextConfig.i18n) {\n        return (0, _normalizeLocalePath).normalizeLocalePath(path, locales).pathname;\n      }\n\n      return path;\n    };\n\n    const handleRedirect = pageData => {\n      const redirect = {\n        destination: pageData.pageProps.__N_REDIRECT,\n        statusCode: pageData.pageProps.__N_REDIRECT_STATUS,\n        basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH\n      };\n      const statusCode = (0, _loadCustomRoutes).getRedirectStatus(redirect);\n      const {\n        basePath\n      } = this.nextConfig;\n\n      if (basePath && redirect.basePath !== false && redirect.destination.startsWith('/')) {\n        redirect.destination = `${basePath}${redirect.destination}`;\n      }\n\n      if (redirect.destination.startsWith('/')) {\n        redirect.destination = (0, _utils1).normalizeRepeatedSlashes(redirect.destination);\n      }\n\n      if (statusCode === _constants.PERMANENT_REDIRECT_STATUS) {\n        res.setHeader('Refresh', `0;url=${redirect.destination}`);\n      }\n\n      res.statusCode = statusCode;\n      res.setHeader('Location', redirect.destination);\n      res.end();\n    }; // remove /_next/data prefix from urlPathname so it matches\n    // for direct page visit and /_next/data visit\n\n\n    if (isDataReq) {\n      resolvedUrlPathname = stripNextDataPath(resolvedUrlPathname);\n      urlPathname = stripNextDataPath(urlPathname);\n    }\n\n    let ssgCacheKey = isPreviewMode || !isSSG || this.minimalMode ? null // Preview mode bypasses the cache\n    : `${locale ? `/${locale}` : ''}${(pathname === '/' || resolvedUrlPathname === '/') && locale ? '' : resolvedUrlPathname}${query.amp ? '.amp' : ''}`;\n\n    if ((is404Page || is500Page) && isSSG) {\n      ssgCacheKey = `${locale ? `/${locale}` : ''}${pathname}${query.amp ? '.amp' : ''}`;\n    }\n\n    if (ssgCacheKey) {\n      // we only encode path delimiters for path segments from\n      // getStaticPaths so we need to attempt decoding the URL\n      // to match against and only escape the path delimiters\n      // this allows non-ascii values to be handled e.g. Japanese characters\n      // TODO: investigate adding this handling for non-SSG pages so\n      // non-ascii names work there also\n      ssgCacheKey = ssgCacheKey.split('/').map(seg => {\n        try {\n          seg = (0, _escapePathDelimiters).default(decodeURIComponent(seg), true);\n        } catch (_) {\n          // An improperly encoded URL was provided\n          throw new _utils1.DecodeError('failed to decode param');\n        }\n\n        return seg;\n      }).join('/');\n    }\n\n    const doRender = async () => {\n      let pageData;\n      let body;\n      let sprRevalidate;\n      let isNotFound;\n      let isRedirect; // handle serverless\n\n      if (isLikeServerless) {\n        const renderResult = await components.Component.renderReqToHTML(req, res, 'passthrough', {\n          locale,\n          locales,\n          defaultLocale,\n          optimizeCss: this.renderOpts.optimizeCss,\n          distDir: this.distDir,\n          fontManifest: this.renderOpts.fontManifest,\n          domainLocales: this.renderOpts.domainLocales\n        });\n        body = renderResult.html;\n        pageData = renderResult.renderOpts.pageData;\n        sprRevalidate = renderResult.renderOpts.revalidate;\n        isNotFound = renderResult.renderOpts.isNotFound;\n        isRedirect = renderResult.renderOpts.isRedirect;\n      } else {\n        const origQuery = (0, _url).parse(req.url || '', true).query;\n        const hadTrailingSlash = urlPathname !== '/' && this.nextConfig.trailingSlash;\n        const resolvedUrl = (0, _url).format({\n          pathname: `${resolvedUrlPathname}${hadTrailingSlash ? '/' : ''}`,\n          // make sure to only add query values from original URL\n          query: origQuery\n        });\n        const renderOpts = { ...components,\n          ...opts,\n          isDataReq,\n          resolvedUrl,\n          locale,\n          locales,\n          defaultLocale,\n          // For getServerSideProps and getInitialProps we need to ensure we use the original URL\n          // and not the resolved URL to prevent a hydration mismatch on\n          // asPath\n          resolvedAsPath: hasServerProps || hasGetInitialProps ? (0, _url).format({\n            // we use the original URL pathname less the _next/data prefix if\n            // present\n            pathname: `${urlPathname}${hadTrailingSlash ? '/' : ''}`,\n            query: origQuery\n          }) : resolvedUrl\n        };\n        const renderResult = await (0, _render).renderToHTML(req, res, pathname, query, renderOpts);\n        body = renderResult; // TODO: change this to a different passing mechanism\n\n        pageData = renderOpts.pageData;\n        sprRevalidate = renderOpts.revalidate;\n        isNotFound = renderOpts.isNotFound;\n        isRedirect = renderOpts.isRedirect;\n      }\n\n      let value;\n\n      if (isNotFound) {\n        value = null;\n      } else if (isRedirect) {\n        value = {\n          kind: 'REDIRECT',\n          props: pageData\n        };\n      } else {\n        if (!body) {\n          return null;\n        }\n\n        value = {\n          kind: 'PAGE',\n          html: body,\n          pageData\n        };\n      }\n\n      return {\n        revalidate: sprRevalidate,\n        value\n      };\n    };\n\n    const cacheEntry = await this.responseCache.get(ssgCacheKey, async hasResolved => {\n      const isProduction = !this.renderOpts.dev;\n      const isDynamicPathname = (0, _utils).isDynamicRoute(pathname);\n      const didRespond = hasResolved || (0, _utils1).isResSent(res);\n      const {\n        staticPaths,\n        fallbackMode\n      } = hasStaticPaths ? await this.getStaticPaths(pathname) : {\n        staticPaths: undefined,\n        fallbackMode: false\n      }; // When we did not respond from cache, we need to choose to block on\n      // rendering or return a skeleton.\n      //\n      // * Data requests always block.\n      //\n      // * Blocking mode fallback always blocks.\n      //\n      // * Preview mode toggles all pages to be resolved in a blocking manner.\n      //\n      // * Non-dynamic pages should block (though this is an impossible\n      //   case in production).\n      //\n      // * Dynamic pages should return their skeleton if not defined in\n      //   getStaticPaths, then finish the data request on the client-side.\n      //\n\n      if (this.minimalMode !== true && fallbackMode !== 'blocking' && ssgCacheKey && !didRespond && !isPreviewMode && isDynamicPathname && (isProduction || !staticPaths || !staticPaths.includes( // we use ssgCacheKey here as it is normalized to match the\n      // encoding from getStaticPaths along with including the locale\n      query.amp ? ssgCacheKey.replace(/\\.amp$/, '') : ssgCacheKey))) {\n        if ( // In development, fall through to render to handle missing\n        // getStaticPaths.\n        (isProduction || staticPaths) && // When fallback isn't present, abort this render so we 404\n        fallbackMode !== 'static') {\n          throw new NoFallbackError();\n        }\n\n        if (!isDataReq) {\n          // Production already emitted the fallback as static HTML.\n          if (isProduction) {\n            const html = await this.incrementalCache.getFallback(locale ? `/${locale}${pathname}` : pathname);\n            return {\n              value: {\n                kind: 'PAGE',\n                html: _zenObservable.default.of(html),\n                pageData: {}\n              }\n            };\n          } else {\n            query.__nextFallback = 'true';\n\n            if (isLikeServerless) {\n              prepareServerlessUrl(req, query);\n            }\n\n            const result = await doRender();\n\n            if (!result) {\n              return null;\n            } // Prevent caching this result\n\n\n            delete result.revalidate;\n            return result;\n          }\n        }\n      }\n\n      const result = await doRender();\n\n      if (!result) {\n        return null;\n      }\n\n      return { ...result,\n        revalidate: result.revalidate !== undefined ? result.revalidate :\n        /* default to minimum revalidate (this should be an invariant) */\n        1\n      };\n    });\n\n    if (!cacheEntry) {\n      if (ssgCacheKey) {\n        // A cache entry might not be generated if a response is written\n        // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n        // have a cache key. If we do have a cache key but we don't end up\n        // with a cache entry, then either Next.js or the application has a\n        // bug that needs fixing.\n        throw new Error('invariant: cache entry required but not generated');\n      }\n\n      return null;\n    }\n\n    const {\n      revalidate,\n      value: cachedData\n    } = cacheEntry;\n    const revalidateOptions = typeof revalidate !== 'undefined' && (!this.renderOpts.dev || hasServerProps && !isDataReq) ? {\n      // When the page is 404 cache-control should not be added\n      private: isPreviewMode || is404Page,\n      stateful: !isSSG,\n      revalidate\n    } : undefined;\n\n    if (!cachedData) {\n      if (revalidateOptions) {\n        (0, _sendPayload).setRevalidateHeaders(res, revalidateOptions);\n      }\n\n      if (isDataReq) {\n        res.statusCode = 404;\n        res.end('{\"notFound\":true}');\n        return null;\n      } else {\n        await this.render404(req, res, {\n          pathname,\n          query\n        });\n        return null;\n      }\n    } else if (cachedData.kind === 'REDIRECT') {\n      if (isDataReq) {\n        return {\n          type: 'json',\n          body: _zenObservable.default.of(JSON.stringify(cachedData.props)),\n          revalidateOptions\n        };\n      } else {\n        await handleRedirect(cachedData.props);\n        return null;\n      }\n    } else {\n      return {\n        type: isDataReq ? 'json' : 'html',\n        body: isDataReq ? _zenObservable.default.of(JSON.stringify(cachedData.pageData)) : cachedData.html,\n        revalidateOptions\n      };\n    }\n  }\n\n  async renderToResponse(ctx) {\n    const {\n      res,\n      query,\n      pathname\n    } = ctx;\n    let page = pathname;\n    const bubbleNoFallback = !!query._nextBubbleNoFallback;\n    delete query._nextBubbleNoFallback;\n\n    try {\n      const result = await this.findPageComponents(pathname, query);\n\n      if (result) {\n        try {\n          return await this.renderToResponseWithComponents(ctx, result);\n        } catch (err) {\n          const isNoFallbackError = err instanceof NoFallbackError;\n\n          if (!isNoFallbackError || isNoFallbackError && bubbleNoFallback) {\n            throw err;\n          }\n        }\n      }\n\n      if (this.dynamicRoutes) {\n        for (const dynamicRoute of this.dynamicRoutes) {\n          const params = dynamicRoute.match(pathname);\n\n          if (!params) {\n            continue;\n          }\n\n          const dynamicRouteResult = await this.findPageComponents(dynamicRoute.page, query, params);\n\n          if (dynamicRouteResult) {\n            try {\n              page = dynamicRoute.page;\n              return await this.renderToResponseWithComponents({ ...ctx,\n                pathname: dynamicRoute.page,\n                renderOpts: { ...ctx.renderOpts,\n                  params\n                }\n              }, dynamicRouteResult);\n            } catch (err) {\n              const isNoFallbackError = err instanceof NoFallbackError;\n\n              if (!isNoFallbackError || isNoFallbackError && bubbleNoFallback) {\n                throw err;\n              }\n            }\n          }\n        }\n      }\n    } catch (err) {\n      if (err instanceof NoFallbackError && bubbleNoFallback) {\n        throw err;\n      }\n\n      if (err instanceof _utils1.DecodeError) {\n        res.statusCode = 400;\n        return await this.renderErrorToResponse(ctx, err);\n      }\n\n      res.statusCode = 500;\n      const isWrappedError = err instanceof WrappedBuildError;\n      const response = await this.renderErrorToResponse(ctx, isWrappedError ? err.innerError : err);\n\n      if (!isWrappedError) {\n        if (this.minimalMode || this.renderOpts.dev) {\n          if (err) {\n            err.page = page;\n          }\n\n          throw err;\n        }\n\n        this.logError(err);\n      }\n\n      return response;\n    }\n\n    res.statusCode = 404;\n    return this.renderErrorToResponse(ctx, null);\n  }\n\n  async renderToHTML(req, res, pathname, query = {}) {\n    return this.getStaticHTML(ctx => this.renderToResponse(ctx), {\n      req,\n      res,\n      pathname,\n      query\n    });\n  }\n\n  async renderError(err, req, res, pathname, query = {}, setHeaders = true) {\n    if (setHeaders) {\n      res.setHeader('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate');\n    }\n\n    return this.pipe(async ctx => {\n      const response = await this.renderErrorToResponse(ctx, err);\n\n      if (this.minimalMode && res.statusCode === 500) {\n        throw err;\n      }\n\n      return response;\n    }, {\n      req,\n      res,\n      pathname,\n      query\n    });\n  }\n\n  async renderErrorToResponse(ctx, _err) {\n    const {\n      res,\n      query\n    } = ctx;\n    let err = _err;\n\n    if (this.renderOpts.dev && !err && res.statusCode === 500) {\n      err = new Error('An undefined error was thrown sometime during render... ' + 'See https://nextjs.org/docs/messages/threw-undefined');\n    }\n\n    try {\n      let result = null;\n      const is404 = res.statusCode === 404;\n      let using404Page = false; // use static 404 page if available and is 404 response\n\n      if (is404) {\n        result = await this.findPageComponents('/404', query);\n        using404Page = result !== null;\n      }\n\n      let statusPage = `/${res.statusCode}`;\n\n      if (!result && _constants.STATIC_STATUS_PAGES.includes(statusPage)) {\n        result = await this.findPageComponents(statusPage, query);\n      }\n\n      if (!result) {\n        result = await this.findPageComponents('/_error', query);\n        statusPage = '/_error';\n      }\n\n      if (process.env.NODE_ENV !== 'production' && !using404Page && (await this.hasPage('/_error')) && !(await this.hasPage('/404'))) {\n        this.customErrorNo404Warn();\n      }\n\n      try {\n        return await this.renderToResponseWithComponents({ ...ctx,\n          pathname: statusPage,\n          renderOpts: { ...ctx.renderOpts,\n            err\n          }\n        }, result);\n      } catch (maybeFallbackError) {\n        if (maybeFallbackError instanceof NoFallbackError) {\n          throw new Error('invariant: failed to render error page');\n        }\n\n        throw maybeFallbackError;\n      }\n    } catch (renderToHtmlError) {\n      const isWrappedError = renderToHtmlError instanceof WrappedBuildError;\n\n      if (!isWrappedError) {\n        this.logError(renderToHtmlError);\n      }\n\n      res.statusCode = 500;\n      const fallbackComponents = await this.getFallbackErrorComponents();\n\n      if (fallbackComponents) {\n        return this.renderToResponseWithComponents({ ...ctx,\n          pathname: '/_error',\n          renderOpts: { ...ctx.renderOpts,\n            // We render `renderToHtmlError` here because `err` is\n            // already captured in the stacktrace.\n            err: isWrappedError ? renderToHtmlError.innerError : renderToHtmlError\n          }\n        }, {\n          query,\n          components: fallbackComponents\n        });\n      }\n\n      return {\n        type: 'html',\n        body: _zenObservable.default.of('Internal Server Error')\n      };\n    }\n  }\n\n  async renderErrorToHTML(err, req, res, pathname, query = {}) {\n    return this.getStaticHTML(ctx => this.renderErrorToResponse(ctx, err), {\n      req,\n      res,\n      pathname,\n      query\n    });\n  }\n\n  async getFallbackErrorComponents() {\n    // The development server will provide an implementation for this\n    return null;\n  }\n\n  async render404(req, res, parsedUrl, setHeaders = true) {\n    const url = req.url;\n    const {\n      pathname,\n      query\n    } = parsedUrl ? parsedUrl : (0, _url).parse(url, true);\n    const {\n      i18n\n    } = this.nextConfig;\n\n    if (i18n) {\n      query.__nextLocale = query.__nextLocale || i18n.defaultLocale;\n      query.__nextDefaultLocale = query.__nextDefaultLocale || i18n.defaultLocale;\n    }\n\n    res.statusCode = 404;\n    return this.renderError(null, req, res, pathname, query, setHeaders);\n  }\n\n  async serveStatic(req, res, path, parsedUrl) {\n    if (!this.isServeableUrl(path)) {\n      return this.render404(req, res, parsedUrl);\n    }\n\n    if (!(req.method === 'GET' || req.method === 'HEAD')) {\n      res.statusCode = 405;\n      res.setHeader('Allow', ['GET', 'HEAD']);\n      return this.renderError(null, req, res, path);\n    }\n\n    try {\n      await (0, _serveStatic).serveStatic(req, res, path);\n    } catch (err) {\n      if (err.code === 'ENOENT' || err.statusCode === 404) {\n        this.render404(req, res, parsedUrl);\n      } else if (err.statusCode === 412) {\n        res.statusCode = 412;\n        return this.renderError(err, req, res, path);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  getFilesystemPaths() {\n    if (this._validFilesystemPathSet) {\n      return this._validFilesystemPathSet;\n    }\n\n    const pathUserFilesStatic = (0, _path).join(this.dir, 'static');\n    let userFilesStatic = [];\n\n    if (this.hasStaticDir && _fs.default.existsSync(pathUserFilesStatic)) {\n      userFilesStatic = (0, _recursiveReaddirSync).recursiveReadDirSync(pathUserFilesStatic).map(f => (0, _path).join('.', 'static', f));\n    }\n\n    let userFilesPublic = [];\n\n    if (this.publicDir && _fs.default.existsSync(this.publicDir)) {\n      userFilesPublic = (0, _recursiveReaddirSync).recursiveReadDirSync(this.publicDir).map(f => (0, _path).join('.', 'public', f));\n    }\n\n    let nextFilesStatic = [];\n    nextFilesStatic = !this.minimalMode ? (0, _recursiveReaddirSync).recursiveReadDirSync((0, _path).join(this.distDir, 'static')).map(f => (0, _path).join('.', (0, _path).relative(this.dir, this.distDir), 'static', f)) : [];\n    return this._validFilesystemPathSet = new Set([...nextFilesStatic, ...userFilesPublic, ...userFilesStatic]);\n  }\n\n  isServeableUrl(untrustedFileUrl) {\n    // This method mimics what the version of `send` we use does:\n    // 1. decodeURIComponent:\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L989\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L518-L522\n    // 2. resolve:\n    //    https://github.com/pillarjs/send/blob/de073ed3237ade9ff71c61673a34474b30e5d45b/index.js#L561\n    let decodedUntrustedFilePath;\n\n    try {\n      // (1) Decode the URL so we have the proper file name\n      decodedUntrustedFilePath = decodeURIComponent(untrustedFileUrl);\n    } catch {\n      return false;\n    } // (2) Resolve \"up paths\" to determine real request\n\n\n    const untrustedFilePath = (0, _path).resolve(decodedUntrustedFilePath); // don't allow null bytes anywhere in the file path\n\n    if (untrustedFilePath.indexOf('\\x00') !== -1) {\n      return false;\n    } // Check if .next/static, static and public are in the path.\n    // If not the path is not available.\n\n\n    if ((untrustedFilePath.startsWith((0, _path).join(this.distDir, 'static') + _path.sep) || untrustedFilePath.startsWith((0, _path).join(this.dir, 'static') + _path.sep) || untrustedFilePath.startsWith((0, _path).join(this.dir, 'public') + _path.sep)) === false) {\n      return false;\n    } // Check against the real filesystem paths\n\n\n    const filesystemUrls = this.getFilesystemPaths();\n    const resolved = (0, _path).relative(this.dir, untrustedFilePath);\n    return filesystemUrls.has(resolved);\n  }\n\n  readBuildId() {\n    const buildIdFile = (0, _path).join(this.distDir, _constants.BUILD_ID_FILE);\n\n    try {\n      return _fs.default.readFileSync(buildIdFile, 'utf8').trim();\n    } catch (err) {\n      if (!_fs.default.existsSync(buildIdFile)) {\n        throw new Error(`Could not find a production build in the '${this.distDir}' directory. Try building your app with 'next build' before starting the production server. https://nextjs.org/docs/messages/production-start-no-build-id`);\n      }\n\n      throw err;\n    }\n  }\n\n  get _isLikeServerless() {\n    return (0, _config).isTargetLikeServerless(this.nextConfig.target);\n  }\n\n}\n\nexports.default = Server;\n\nfunction prepareServerlessUrl(req, query) {\n  const curUrl = (0, _url).parse(req.url, true);\n  req.url = (0, _url).format({ ...curUrl,\n    search: undefined,\n    query: { ...curUrl.query,\n      ...query\n    }\n  });\n}\n\nclass NoFallbackError extends Error {}\n\nclass WrappedBuildError extends Error {\n  constructor(innerError) {\n    super();\n    this.innerError = innerError;\n  }\n\n}\n\nexports.WrappedBuildError = WrappedBuildError;","map":{"version":3,"sources":["../../server/next-server.ts"],"names":[],"mappings":"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","sourcesContent":["import compression from 'next/dist/compiled/compression'\nimport fs from 'fs'\nimport chalk from 'chalk'\nimport { IncomingMessage, ServerResponse } from 'http'\nimport Proxy from 'next/dist/compiled/http-proxy'\nimport { join, relative, resolve, sep } from 'path'\nimport {\n  parse as parseQs,\n  stringify as stringifyQs,\n  ParsedUrlQuery,\n} from 'querystring'\nimport { format as formatUrl, parse as parseUrl, UrlWithParsedQuery } from 'url'\nimport Observable from 'next/dist/compiled/zen-observable'\nimport { PrerenderManifest } from '../build'\nimport {\n  getRedirectStatus,\n  Header,\n  Redirect,\n  Rewrite,\n  RouteType,\n  CustomRoutes,\n  modifyRouteRegex,\n} from '../lib/load-custom-routes'\nimport {\n  BUILD_ID_FILE,\n  CLIENT_PUBLIC_FILES_PATH,\n  CLIENT_STATIC_FILES_PATH,\n  CLIENT_STATIC_FILES_RUNTIME,\n  PAGES_MANIFEST,\n  PERMANENT_REDIRECT_STATUS,\n  PRERENDER_MANIFEST,\n  ROUTES_MANIFEST,\n  SERVERLESS_DIRECTORY,\n  SERVER_DIRECTORY,\n  STATIC_STATUS_PAGES,\n  TEMPORARY_REDIRECT_STATUS,\n} from '../shared/lib/constants'\nimport {\n  getRouteMatcher,\n  getRouteRegex,\n  getSortedRoutes,\n  isDynamicRoute,\n} from '../shared/lib/router/utils'\nimport * as envConfig from '../shared/lib/runtime-config'\nimport {\n  DecodeError,\n  isResSent,\n  NextApiRequest,\n  NextApiResponse,\n  normalizeRepeatedSlashes,\n} from '../shared/lib/utils'\nimport {\n  apiResolver,\n  setLazyProp,\n  getCookieParser,\n  tryGetPreviewData,\n  __ApiPreviewProps,\n} from './api-utils'\nimport { DomainLocale, isTargetLikeServerless, NextConfig } from './config'\nimport pathMatch from '../shared/lib/router/utils/path-match'\nimport { recursiveReadDirSync } from './lib/recursive-readdir-sync'\nimport { loadComponents, LoadComponentsReturnType } from './load-components'\nimport { normalizePagePath } from './normalize-page-path'\nimport { RenderOpts, RenderOptsPartial, renderToHTML } from './render'\nimport { getPagePath, requireFontManifest } from './require'\nimport Router, {\n  DynamicRoutes,\n  PageChecker,\n  Params,\n  route,\n  Route,\n} from './router'\nimport prepareDestination, {\n  compileNonPath,\n} from '../shared/lib/router/utils/prepare-destination'\nimport { sendRenderResult, setRevalidateHeaders } from './send-payload'\nimport { serveStatic } from './serve-static'\nimport { IncrementalCache } from './incremental-cache'\nimport { execOnce } from '../shared/lib/utils'\nimport { isBlockedPage, RenderResult, resultsToString } from './utils'\nimport { loadEnvConfig } from '@next/env'\nimport './node-polyfill-fetch'\nimport { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin'\nimport { removePathTrailingSlash } from '../client/normalize-trailing-slash'\nimport getRouteFromAssetPath from '../shared/lib/router/utils/get-route-from-asset-path'\nimport { FontManifest } from './font-utils'\nimport { denormalizePagePath } from './denormalize-page-path'\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\nimport * as Log from '../build/output/log'\nimport { detectDomainLocale } from '../shared/lib/i18n/detect-domain-locale'\nimport escapePathDelimiters from '../shared/lib/router/utils/escape-path-delimiters'\nimport { getUtils } from '../build/webpack/loaders/next-serverless-loader/utils'\nimport { PreviewData } from 'next/types'\nimport ResponseCache, {\n  ResponseCacheEntry,\n  ResponseCacheValue,\n} from './response-cache'\nimport { NextConfigComplete } from './config-shared'\nimport { parseNextUrl } from '../shared/lib/router/utils/parse-next-url'\n\nconst getCustomRouteMatcher = pathMatch(true)\n\ntype Middleware = (\n  req: IncomingMessage,\n  res: ServerResponse,\n  next: (err?: Error) => void\n) => void\n\nexport type FindComponentsResult = {\n  components: LoadComponentsReturnType\n  query: ParsedUrlQuery\n}\n\ntype DynamicRouteItem = {\n  page: string\n  match: ReturnType<typeof getRouteMatcher>\n}\n\nexport type ServerConstructor = {\n  /**\n   * Where the Next project is located - @default '.'\n   */\n  dir?: string\n  /**\n   * Hide error messages containing server information - @default false\n   */\n  quiet?: boolean\n  /**\n   * Object what you would use in next.config.js - @default {}\n   */\n  conf?: NextConfig | null\n  dev?: boolean\n  customServer?: boolean\n}\n\ntype RequestContext = {\n  req: IncomingMessage\n  res: ServerResponse\n  pathname: string\n  query: ParsedUrlQuery\n  renderOpts: RenderOptsPartial\n}\n\nexport default class Server {\n  protected dir: string\n  protected quiet: boolean\n  protected nextConfig: NextConfigComplete\n  protected distDir: string\n  protected pagesDir?: string\n  protected publicDir: string\n  protected hasStaticDir: boolean\n  protected serverBuildDir: string\n  protected pagesManifest?: PagesManifest\n  protected buildId: string\n  protected minimalMode: boolean\n  protected renderOpts: {\n    poweredByHeader: boolean\n    buildId: string\n    generateEtags: boolean\n    runtimeConfig?: { [key: string]: any }\n    assetPrefix?: string\n    canonicalBase: string\n    dev?: boolean\n    previewProps: __ApiPreviewProps\n    customServer?: boolean\n    ampOptimizerConfig?: { [key: string]: any }\n    basePath: string\n    optimizeFonts: boolean\n    images: string\n    fontManifest: FontManifest\n    optimizeImages: boolean\n    disableOptimizedLoading?: boolean\n    optimizeCss: any\n    locale?: string\n    locales?: string[]\n    defaultLocale?: string\n    domainLocales?: DomainLocale[]\n    distDir: string\n    concurrentFeatures?: boolean\n  }\n  private compression?: Middleware\n  private incrementalCache: IncrementalCache\n  private responseCache: ResponseCache\n  protected router: Router\n  protected dynamicRoutes?: DynamicRoutes\n  protected customRoutes: CustomRoutes\n\n  public constructor({\n    dir = '.',\n    quiet = false,\n    conf,\n    dev = false,\n    minimalMode = false,\n    customServer = true,\n  }: ServerConstructor & { conf: NextConfig; minimalMode?: boolean }) {\n    this.dir = resolve(dir)\n    this.quiet = quiet\n    loadEnvConfig(this.dir, dev, Log)\n\n    this.nextConfig = conf as NextConfigComplete\n\n    this.distDir = join(this.dir, this.nextConfig.distDir)\n    this.publicDir = join(this.dir, CLIENT_PUBLIC_FILES_PATH)\n    this.hasStaticDir = !minimalMode && fs.existsSync(join(this.dir, 'static'))\n\n    // Only serverRuntimeConfig needs the default\n    // publicRuntimeConfig gets it's default in client/index.js\n    const {\n      serverRuntimeConfig = {},\n      publicRuntimeConfig,\n      assetPrefix,\n      generateEtags,\n      compress,\n    } = this.nextConfig\n\n    this.buildId = this.readBuildId()\n    this.minimalMode = minimalMode\n\n    this.renderOpts = {\n      poweredByHeader: this.nextConfig.poweredByHeader,\n      canonicalBase: this.nextConfig.amp.canonicalBase || '',\n      buildId: this.buildId,\n      generateEtags,\n      previewProps: this.getPreviewProps(),\n      customServer: customServer === true ? true : undefined,\n      ampOptimizerConfig: this.nextConfig.experimental.amp?.optimizer,\n      basePath: this.nextConfig.basePath,\n      images: JSON.stringify(this.nextConfig.images),\n      optimizeFonts: !!this.nextConfig.optimizeFonts && !dev,\n      fontManifest:\n        this.nextConfig.optimizeFonts && !dev\n          ? requireFontManifest(this.distDir, this._isLikeServerless)\n          : null,\n      optimizeImages: !!this.nextConfig.experimental.optimizeImages,\n      optimizeCss: this.nextConfig.experimental.optimizeCss,\n      disableOptimizedLoading:\n        this.nextConfig.experimental.disableOptimizedLoading,\n      domainLocales: this.nextConfig.i18n?.domains,\n      distDir: this.distDir,\n      concurrentFeatures: this.nextConfig.experimental.concurrentFeatures,\n    }\n\n    // Only the `publicRuntimeConfig` key is exposed to the client side\n    // It'll be rendered as part of __NEXT_DATA__ on the client side\n    if (Object.keys(publicRuntimeConfig).length > 0) {\n      this.renderOpts.runtimeConfig = publicRuntimeConfig\n    }\n\n    if (compress && this.nextConfig.target === 'server') {\n      this.compression = compression() as Middleware\n    }\n\n    // Initialize next/config with the environment configuration\n    envConfig.setConfig({\n      serverRuntimeConfig,\n      publicRuntimeConfig,\n    })\n\n    this.serverBuildDir = join(\n      this.distDir,\n      this._isLikeServerless ? SERVERLESS_DIRECTORY : SERVER_DIRECTORY\n    )\n    const pagesManifestPath = join(this.serverBuildDir, PAGES_MANIFEST)\n\n    if (!dev) {\n      this.pagesManifest = require(pagesManifestPath)\n    }\n\n    this.customRoutes = this.getCustomRoutes()\n    this.router = new Router(this.generateRoutes())\n    this.setAssetPrefix(assetPrefix)\n\n    this.incrementalCache = new IncrementalCache({\n      dev,\n      distDir: this.distDir,\n      pagesDir: join(\n        this.distDir,\n        this._isLikeServerless ? SERVERLESS_DIRECTORY : SERVER_DIRECTORY,\n        'pages'\n      ),\n      locales: this.nextConfig.i18n?.locales,\n      max: this.nextConfig.experimental.isrMemoryCacheSize,\n      flushToDisk: !minimalMode && this.nextConfig.experimental.isrFlushToDisk,\n    })\n    this.responseCache = new ResponseCache(this.incrementalCache)\n\n    /**\n     * This sets environment variable to be used at the time of SSR by head.tsx.\n     * Using this from process.env allows targeting both serverless and SSR by calling\n     * `process.env.__NEXT_OPTIMIZE_IMAGES`.\n     * TODO(atcastle@): Remove this when experimental.optimizeImages are being cleaned up.\n     */\n    if (this.renderOpts.optimizeFonts) {\n      process.env.__NEXT_OPTIMIZE_FONTS = JSON.stringify(true)\n    }\n    if (this.renderOpts.optimizeImages) {\n      process.env.__NEXT_OPTIMIZE_IMAGES = JSON.stringify(true)\n    }\n    if (this.renderOpts.optimizeCss) {\n      process.env.__NEXT_OPTIMIZE_CSS = JSON.stringify(true)\n    }\n  }\n\n  public logError(err: Error): void {\n    if (this.quiet) return\n    console.error(err)\n  }\n\n  private async handleRequest(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl?: UrlWithParsedQuery\n  ): Promise<void> {\n    const urlParts = (req.url || '').split('?')\n    const urlNoQuery = urlParts[0]\n\n    if (urlNoQuery?.match(/(\\\\|\\/\\/)/)) {\n      const cleanUrl = normalizeRepeatedSlashes(req.url!)\n      res.setHeader('Location', cleanUrl)\n      res.setHeader('Refresh', `0;url=${cleanUrl}`)\n      res.statusCode = 308\n      res.end(cleanUrl)\n      return\n    }\n\n    setLazyProp({ req: req as any }, 'cookies', getCookieParser(req.headers))\n\n    // Parse url if parsedUrl not provided\n    if (!parsedUrl || typeof parsedUrl !== 'object') {\n      const url: any = req.url\n      parsedUrl = parseUrl(url, true)\n    }\n    const { basePath, i18n } = this.nextConfig\n\n    // Parse the querystring ourselves if the user doesn't handle querystring parsing\n    if (typeof parsedUrl.query === 'string') {\n      parsedUrl.query = parseQs(parsedUrl.query)\n    }\n    ;(req as any).__NEXT_INIT_QUERY = Object.assign({}, parsedUrl.query)\n\n    const url = parseNextUrl({\n      headers: req.headers,\n      nextConfig: this.nextConfig,\n      url: req.url?.replace(/^\\/+/, '/'),\n    })\n\n    if (url.basePath) {\n      ;(req as any)._nextHadBasePath = true\n      req.url = req.url!.replace(basePath, '') || '/'\n    }\n\n    if (\n      this.minimalMode &&\n      req.headers['x-matched-path'] &&\n      typeof req.headers['x-matched-path'] === 'string'\n    ) {\n      const reqUrlIsDataUrl = req.url?.includes('/_next/data')\n      const matchedPathIsDataUrl =\n        req.headers['x-matched-path']?.includes('/_next/data')\n      const isDataUrl = reqUrlIsDataUrl || matchedPathIsDataUrl\n\n      let parsedPath = parseUrl(\n        isDataUrl ? req.url! : (req.headers['x-matched-path'] as string),\n        true\n      )\n      const { pathname, query } = parsedPath\n      let matchedPathname = pathname as string\n\n      let matchedPathnameNoExt = isDataUrl\n        ? matchedPathname.replace(/\\.json$/, '')\n        : matchedPathname\n\n      if (i18n) {\n        const localePathResult = normalizeLocalePath(\n          matchedPathname || '/',\n          i18n.locales\n        )\n\n        if (localePathResult.detectedLocale) {\n          parsedUrl.query.__nextLocale = localePathResult.detectedLocale\n        }\n      }\n\n      if (isDataUrl) {\n        matchedPathname = denormalizePagePath(matchedPathname)\n        matchedPathnameNoExt = denormalizePagePath(matchedPathnameNoExt)\n      }\n\n      const pageIsDynamic = isDynamicRoute(matchedPathnameNoExt)\n      const combinedRewrites: Rewrite[] = []\n\n      combinedRewrites.push(...this.customRoutes.rewrites.beforeFiles)\n      combinedRewrites.push(...this.customRoutes.rewrites.afterFiles)\n      combinedRewrites.push(...this.customRoutes.rewrites.fallback)\n\n      const utils = getUtils({\n        pageIsDynamic,\n        page: matchedPathnameNoExt,\n        i18n: this.nextConfig.i18n,\n        basePath: this.nextConfig.basePath,\n        rewrites: combinedRewrites,\n      })\n\n      utils.handleRewrites(req, parsedUrl)\n\n      // interpolate dynamic params and normalize URL if needed\n      if (pageIsDynamic) {\n        let params: ParsedUrlQuery | false = {}\n\n        Object.assign(parsedUrl.query, query)\n        const paramsResult = utils.normalizeDynamicRouteParams(parsedUrl.query)\n\n        if (paramsResult.hasValidParams) {\n          params = paramsResult.params\n        } else if (req.headers['x-now-route-matches']) {\n          const opts: Record<string, string> = {}\n          params = utils.getParamsFromRouteMatches(\n            req,\n            opts,\n            (parsedUrl.query.__nextLocale as string | undefined) || ''\n          )\n\n          if (opts.locale) {\n            parsedUrl.query.__nextLocale = opts.locale\n          }\n        } else {\n          params = utils.dynamicRouteMatcher!(matchedPathnameNoExt)\n        }\n\n        if (params) {\n          params = utils.normalizeDynamicRouteParams(params).params\n\n          matchedPathname = utils.interpolateDynamicPath(\n            matchedPathname,\n            params\n          )\n          req.url = utils.interpolateDynamicPath(req.url!, params)\n        }\n\n        if (reqUrlIsDataUrl && matchedPathIsDataUrl) {\n          req.url = formatUrl({\n            ...parsedPath,\n            pathname: matchedPathname,\n          })\n        }\n\n        Object.assign(parsedUrl.query, params)\n        utils.normalizeVercelUrl(req, true)\n      }\n\n      parsedUrl.pathname = `${basePath || ''}${\n        matchedPathname === '/' && basePath ? '' : matchedPathname\n      }`\n    }\n\n    ;(req as any).__nextHadTrailingSlash = url.locale?.trailingSlash\n    if (url.locale?.domain) {\n      ;(req as any).__nextIsLocaleDomain = true\n    }\n\n    if (url.locale?.path.detectedLocale) {\n      req.url = formatUrl(url)\n      ;(req as any).__nextStrippedLocale = true\n      if (url.pathname === '/api' || url.pathname.startsWith('/api/')) {\n        return this.render404(req, res, parsedUrl)\n      }\n    }\n\n    if (!this.minimalMode || !parsedUrl.query.__nextLocale) {\n      if (url?.locale?.locale) {\n        parsedUrl.query.__nextLocale = url.locale.locale\n      }\n    }\n\n    if (url?.locale?.defaultLocale) {\n      parsedUrl.query.__nextDefaultLocale = url.locale.defaultLocale\n    }\n\n    if (url.locale?.redirect) {\n      res.setHeader('Location', url.locale.redirect)\n      res.statusCode = TEMPORARY_REDIRECT_STATUS\n      res.end()\n      return\n    }\n\n    res.statusCode = 200\n    try {\n      return await this.run(req, res, parsedUrl)\n    } catch (err) {\n      if (this.minimalMode || this.renderOpts.dev) {\n        throw err\n      }\n      this.logError(err)\n      res.statusCode = 500\n      res.end('Internal Server Error')\n    }\n  }\n\n  public getRequestHandler() {\n    return this.handleRequest.bind(this)\n  }\n\n  public setAssetPrefix(prefix?: string): void {\n    this.renderOpts.assetPrefix = prefix ? prefix.replace(/\\/$/, '') : ''\n  }\n\n  // Backwards compatibility\n  public async prepare(): Promise<void> {}\n\n  // Backwards compatibility\n  protected async close(): Promise<void> {}\n\n  protected setImmutableAssetCacheControl(res: ServerResponse): void {\n    res.setHeader('Cache-Control', 'public, max-age=31536000, immutable')\n  }\n\n  protected getCustomRoutes(): CustomRoutes {\n    const customRoutes = require(join(this.distDir, ROUTES_MANIFEST))\n    let rewrites: CustomRoutes['rewrites']\n\n    // rewrites can be stored as an array when an array is\n    // returned in next.config.js so massage them into\n    // the expected object format\n    if (Array.isArray(customRoutes.rewrites)) {\n      rewrites = {\n        beforeFiles: [],\n        afterFiles: customRoutes.rewrites,\n        fallback: [],\n      }\n    } else {\n      rewrites = customRoutes.rewrites\n    }\n    return Object.assign(customRoutes, { rewrites })\n  }\n\n  private _cachedPreviewManifest: PrerenderManifest | undefined\n  protected getPrerenderManifest(): PrerenderManifest {\n    if (this._cachedPreviewManifest) {\n      return this._cachedPreviewManifest\n    }\n    const manifest = require(join(this.distDir, PRERENDER_MANIFEST))\n    return (this._cachedPreviewManifest = manifest)\n  }\n\n  protected getPreviewProps(): __ApiPreviewProps {\n    return this.getPrerenderManifest().preview\n  }\n\n  protected generateRoutes(): {\n    basePath: string\n    headers: Route[]\n    rewrites: {\n      beforeFiles: Route[]\n      afterFiles: Route[]\n      fallback: Route[]\n    }\n    fsRoutes: Route[]\n    redirects: Route[]\n    catchAllRoute: Route\n    pageChecker: PageChecker\n    useFileSystemPublicRoutes: boolean\n    dynamicRoutes: DynamicRoutes | undefined\n    locales: string[]\n  } {\n    const server: Server = this\n    const publicRoutes = fs.existsSync(this.publicDir)\n      ? this.generatePublicRoutes()\n      : []\n\n    const staticFilesRoute = this.hasStaticDir\n      ? [\n          {\n            // It's very important to keep this route's param optional.\n            // (but it should support as many params as needed, separated by '/')\n            // Otherwise this will lead to a pretty simple DOS attack.\n            // See more: https://github.com/vercel/next.js/issues/2617\n            match: route('/static/:path*'),\n            name: 'static catchall',\n            fn: async (req, res, params, parsedUrl) => {\n              const p = join(this.dir, 'static', ...params.path)\n              await this.serveStatic(req, res, p, parsedUrl)\n              return {\n                finished: true,\n              }\n            },\n          } as Route,\n        ]\n      : []\n\n    const fsRoutes: Route[] = [\n      {\n        match: route('/_next/static/:path*'),\n        type: 'route',\n        name: '_next/static catchall',\n        fn: async (req, res, params, parsedUrl) => {\n          // make sure to 404 for /_next/static itself\n          if (!params.path) {\n            await this.render404(req, res, parsedUrl)\n            return {\n              finished: true,\n            }\n          }\n\n          if (\n            params.path[0] === CLIENT_STATIC_FILES_RUNTIME ||\n            params.path[0] === 'chunks' ||\n            params.path[0] === 'css' ||\n            params.path[0] === 'image' ||\n            params.path[0] === 'media' ||\n            params.path[0] === this.buildId ||\n            params.path[0] === 'pages' ||\n            params.path[1] === 'pages'\n          ) {\n            this.setImmutableAssetCacheControl(res)\n          }\n          const p = join(\n            this.distDir,\n            CLIENT_STATIC_FILES_PATH,\n            ...(params.path || [])\n          )\n          await this.serveStatic(req, res, p, parsedUrl)\n          return {\n            finished: true,\n          }\n        },\n      },\n      {\n        match: route('/_next/data/:path*'),\n        type: 'route',\n        name: '_next/data catchall',\n        fn: async (req, res, params, _parsedUrl) => {\n          // Make sure to 404 for /_next/data/ itself and\n          // we also want to 404 if the buildId isn't correct\n          if (!params.path || params.path[0] !== this.buildId) {\n            await this.render404(req, res, _parsedUrl)\n            return {\n              finished: true,\n            }\n          }\n          // remove buildId from URL\n          params.path.shift()\n\n          // show 404 if it doesn't end with .json\n          if (!params.path[params.path.length - 1].endsWith('.json')) {\n            await this.render404(req, res, _parsedUrl)\n            return {\n              finished: true,\n            }\n          }\n\n          // re-create page's pathname\n          let pathname = `/${params.path.join('/')}`\n          pathname = getRouteFromAssetPath(pathname, '.json')\n\n          const { i18n } = this.nextConfig\n\n          if (i18n) {\n            const { host } = req?.headers || {}\n            // remove port from host and remove port if present\n            const hostname = host?.split(':')[0].toLowerCase()\n            const localePathResult = normalizeLocalePath(pathname, i18n.locales)\n            const { defaultLocale } =\n              detectDomainLocale(i18n.domains, hostname) || {}\n\n            let detectedLocale = ''\n\n            if (localePathResult.detectedLocale) {\n              pathname = localePathResult.pathname\n              detectedLocale = localePathResult.detectedLocale\n            }\n\n            _parsedUrl.query.__nextLocale = detectedLocale!\n            _parsedUrl.query.__nextDefaultLocale =\n              defaultLocale || i18n.defaultLocale\n\n            if (!detectedLocale) {\n              _parsedUrl.query.__nextLocale =\n                _parsedUrl.query.__nextDefaultLocale\n              await this.render404(req, res, _parsedUrl)\n              return { finished: true }\n            }\n          }\n\n          const parsedUrl = parseUrl(pathname, true)\n\n          await this.render(\n            req,\n            res,\n            pathname,\n            { ..._parsedUrl.query, _nextDataReq: '1' },\n            parsedUrl\n          )\n          return {\n            finished: true,\n          }\n        },\n      },\n      {\n        match: route('/_next/image'),\n        type: 'route',\n        name: '_next/image catchall',\n        fn: (req, res, _params, parsedUrl) => {\n          if (this.minimalMode) {\n            res.statusCode = 400\n            res.end('Bad Request')\n            return {\n              finished: true,\n            }\n          }\n          const { imageOptimizer } =\n            require('./image-optimizer') as typeof import('./image-optimizer')\n\n          return imageOptimizer(\n            server,\n            req,\n            res,\n            parsedUrl,\n            server.nextConfig,\n            server.distDir,\n            this.renderOpts.dev\n          )\n        },\n      },\n      {\n        match: route('/_next/:path*'),\n        type: 'route',\n        name: '_next catchall',\n        // This path is needed because `render()` does a check for `/_next` and the calls the routing again\n        fn: async (req, res, _params, parsedUrl) => {\n          await this.render404(req, res, parsedUrl)\n          return {\n            finished: true,\n          }\n        },\n      },\n      ...publicRoutes,\n      ...staticFilesRoute,\n    ]\n\n    const restrictedRedirectPaths = ['/_next'].map((p) =>\n      this.nextConfig.basePath ? `${this.nextConfig.basePath}${p}` : p\n    )\n\n    const getCustomRoute = (\n      r: Rewrite | Redirect | Header,\n      type: RouteType\n    ) => {\n      const match = getCustomRouteMatcher(\n        r.source,\n        !(r as any).internal\n          ? (regex: string) =>\n              modifyRouteRegex(\n                regex,\n                type === 'redirect' ? restrictedRedirectPaths : undefined\n              )\n          : undefined\n      )\n\n      return {\n        ...r,\n        type,\n        match,\n        name: type,\n        fn: async (_req, _res, _params, _parsedUrl) => ({ finished: false }),\n      } as Route & Rewrite & Header\n    }\n\n    // Headers come very first\n    const headers = this.minimalMode\n      ? []\n      : this.customRoutes.headers.map((r) => {\n          const headerRoute = getCustomRoute(r, 'header')\n          return {\n            match: headerRoute.match,\n            has: headerRoute.has,\n            type: headerRoute.type,\n            name: `${headerRoute.type} ${headerRoute.source} header route`,\n            fn: async (_req, res, params, _parsedUrl) => {\n              const hasParams = Object.keys(params).length > 0\n\n              for (const header of (headerRoute as Header).headers) {\n                let { key, value } = header\n                if (hasParams) {\n                  key = compileNonPath(key, params)\n                  value = compileNonPath(value, params)\n                }\n                res.setHeader(key, value)\n              }\n              return { finished: false }\n            },\n          } as Route\n        })\n\n    // since initial query values are decoded by querystring.parse\n    // we need to re-encode them here but still allow passing through\n    // values from rewrites/redirects\n    const stringifyQuery = (req: IncomingMessage, query: ParsedUrlQuery) => {\n      const initialQueryValues = Object.values((req as any).__NEXT_INIT_QUERY)\n\n      return stringifyQs(query, undefined, undefined, {\n        encodeURIComponent(value) {\n          if (initialQueryValues.some((val) => val === value)) {\n            return encodeURIComponent(value)\n          }\n          return value\n        },\n      })\n    }\n\n    const redirects = this.minimalMode\n      ? []\n      : this.customRoutes.redirects.map((redirect) => {\n          const redirectRoute = getCustomRoute(redirect, 'redirect')\n          return {\n            internal: redirectRoute.internal,\n            type: redirectRoute.type,\n            match: redirectRoute.match,\n            has: redirectRoute.has,\n            statusCode: redirectRoute.statusCode,\n            name: `Redirect route ${redirectRoute.source}`,\n            fn: async (req, res, params, parsedUrl) => {\n              const { parsedDestination } = prepareDestination(\n                redirectRoute.destination,\n                params,\n                parsedUrl.query,\n                false\n              )\n\n              const { query } = parsedDestination\n              delete (parsedDestination as any).query\n\n              parsedDestination.search = stringifyQuery(req, query)\n\n              let updatedDestination = formatUrl(parsedDestination)\n\n              if (updatedDestination.startsWith('/')) {\n                updatedDestination =\n                  normalizeRepeatedSlashes(updatedDestination)\n              }\n\n              res.setHeader('Location', updatedDestination)\n              res.statusCode = getRedirectStatus(redirectRoute as Redirect)\n\n              // Since IE11 doesn't support the 308 header add backwards\n              // compatibility using refresh header\n              if (res.statusCode === 308) {\n                res.setHeader('Refresh', `0;url=${updatedDestination}`)\n              }\n\n              res.end(updatedDestination)\n              return {\n                finished: true,\n              }\n            },\n          } as Route\n        })\n\n    const buildRewrite = (rewrite: Rewrite, check = true) => {\n      const rewriteRoute = getCustomRoute(rewrite, 'rewrite')\n      return {\n        ...rewriteRoute,\n        check,\n        type: rewriteRoute.type,\n        name: `Rewrite route ${rewriteRoute.source}`,\n        match: rewriteRoute.match,\n        fn: async (req, res, params, parsedUrl) => {\n          const { newUrl, parsedDestination } = prepareDestination(\n            rewriteRoute.destination,\n            params,\n            parsedUrl.query,\n            true\n          )\n\n          // external rewrite, proxy it\n          if (parsedDestination.protocol) {\n            const { query } = parsedDestination\n            delete (parsedDestination as any).query\n            parsedDestination.search = stringifyQuery(req, query)\n\n            const target = formatUrl(parsedDestination)\n            const proxy = new Proxy({\n              target,\n              changeOrigin: true,\n              ignorePath: true,\n              xfwd: true,\n              proxyTimeout: 30_000, // limit proxying to 30 seconds\n            })\n\n            await new Promise((proxyResolve, proxyReject) => {\n              let finished = false\n\n              proxy.on('proxyReq', (proxyReq) => {\n                proxyReq.on('close', () => {\n                  if (!finished) {\n                    finished = true\n                    proxyResolve(true)\n                  }\n                })\n              })\n              proxy.on('error', (err) => {\n                if (!finished) {\n                  finished = true\n                  proxyReject(err)\n                }\n              })\n              proxy.web(req, res)\n            })\n\n            return {\n              finished: true,\n            }\n          }\n          ;(req as any)._nextRewroteUrl = newUrl\n          ;(req as any)._nextDidRewrite =\n            (req as any)._nextRewroteUrl !== req.url\n\n          return {\n            finished: false,\n            pathname: newUrl,\n            query: parsedDestination.query,\n          }\n        },\n      } as Route\n    }\n\n    let beforeFiles: Route[] = []\n    let afterFiles: Route[] = []\n    let fallback: Route[] = []\n\n    if (!this.minimalMode) {\n      if (Array.isArray(this.customRoutes.rewrites)) {\n        afterFiles = this.customRoutes.rewrites.map((r) => buildRewrite(r))\n      } else {\n        beforeFiles = this.customRoutes.rewrites.beforeFiles.map((r) =>\n          buildRewrite(r, false)\n        )\n        afterFiles = this.customRoutes.rewrites.afterFiles.map((r) =>\n          buildRewrite(r)\n        )\n        fallback = this.customRoutes.rewrites.fallback.map((r) =>\n          buildRewrite(r)\n        )\n      }\n    }\n\n    const catchAllRoute: Route = {\n      match: route('/:path*'),\n      type: 'route',\n      name: 'Catchall render',\n      fn: async (req, res, _params, parsedUrl) => {\n        let { pathname, query } = parsedUrl\n        if (!pathname) {\n          throw new Error('pathname is undefined')\n        }\n\n        // next.js core assumes page path without trailing slash\n        pathname = removePathTrailingSlash(pathname)\n\n        if (this.nextConfig.i18n) {\n          const localePathResult = normalizeLocalePath(\n            pathname,\n            this.nextConfig.i18n?.locales\n          )\n\n          if (localePathResult.detectedLocale) {\n            pathname = localePathResult.pathname\n            parsedUrl.query.__nextLocale = localePathResult.detectedLocale\n          }\n        }\n        const bubbleNoFallback = !!query._nextBubbleNoFallback\n\n        if (pathname === '/api' || pathname.startsWith('/api/')) {\n          delete query._nextBubbleNoFallback\n\n          const handled = await this.handleApiRequest(\n            req as NextApiRequest,\n            res as NextApiResponse,\n            pathname,\n            query\n          )\n          if (handled) {\n            return { finished: true }\n          }\n        }\n\n        try {\n          await this.render(req, res, pathname, query, parsedUrl)\n\n          return {\n            finished: true,\n          }\n        } catch (err) {\n          if (err instanceof NoFallbackError && bubbleNoFallback) {\n            return {\n              finished: false,\n            }\n          }\n          throw err\n        }\n      },\n    }\n\n    const { useFileSystemPublicRoutes } = this.nextConfig\n\n    if (useFileSystemPublicRoutes) {\n      this.dynamicRoutes = this.getDynamicRoutes()\n    }\n\n    return {\n      headers,\n      fsRoutes,\n      rewrites: {\n        beforeFiles,\n        afterFiles,\n        fallback,\n      },\n      redirects,\n      catchAllRoute,\n      useFileSystemPublicRoutes,\n      dynamicRoutes: this.dynamicRoutes,\n      basePath: this.nextConfig.basePath,\n      pageChecker: this.hasPage.bind(this),\n      locales: this.nextConfig.i18n?.locales || [],\n    }\n  }\n\n  private async getPagePath(\n    pathname: string,\n    locales?: string[]\n  ): Promise<string> {\n    return getPagePath(\n      pathname,\n      this.distDir,\n      this._isLikeServerless,\n      this.renderOpts.dev,\n      locales\n    )\n  }\n\n  protected async hasPage(pathname: string): Promise<boolean> {\n    let found = false\n    try {\n      found = !!(await this.getPagePath(\n        pathname,\n        this.nextConfig.i18n?.locales\n      ))\n    } catch (_) {}\n\n    return found\n  }\n\n  protected async _beforeCatchAllRender(\n    _req: IncomingMessage,\n    _res: ServerResponse,\n    _params: Params,\n    _parsedUrl: UrlWithParsedQuery\n  ): Promise<boolean> {\n    return false\n  }\n\n  // Used to build API page in development\n  protected async ensureApiPage(_pathname: string): Promise<void> {}\n\n  /**\n   * Resolves `API` request, in development builds on demand\n   * @param req http request\n   * @param res http response\n   * @param pathname path of request\n   */\n  private async handleApiRequest(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery\n  ): Promise<boolean> {\n    let page = pathname\n    let params: Params | boolean = false\n    let pageFound = await this.hasPage(page)\n\n    if (!pageFound && this.dynamicRoutes) {\n      for (const dynamicRoute of this.dynamicRoutes) {\n        params = dynamicRoute.match(pathname)\n        if (dynamicRoute.page.startsWith('/api') && params) {\n          page = dynamicRoute.page\n          pageFound = true\n          break\n        }\n      }\n    }\n\n    if (!pageFound) {\n      return false\n    }\n    // Make sure the page is built before getting the path\n    // or else it won't be in the manifest yet\n    await this.ensureApiPage(page)\n\n    let builtPagePath\n    try {\n      builtPagePath = await this.getPagePath(page)\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        return false\n      }\n      throw err\n    }\n\n    const pageModule = await require(builtPagePath)\n    query = { ...query, ...params }\n\n    delete query.__nextLocale\n    delete query.__nextDefaultLocale\n\n    if (!this.renderOpts.dev && this._isLikeServerless) {\n      if (typeof pageModule.default === 'function') {\n        prepareServerlessUrl(req, query)\n        await pageModule.default(req, res)\n        return true\n      }\n    }\n\n    await apiResolver(\n      req,\n      res,\n      query,\n      pageModule,\n      this.renderOpts.previewProps,\n      this.minimalMode,\n      this.renderOpts.dev,\n      page\n    )\n    return true\n  }\n\n  protected generatePublicRoutes(): Route[] {\n    const publicFiles = new Set(\n      recursiveReadDirSync(this.publicDir).map((p) =>\n        encodeURI(p.replace(/\\\\/g, '/'))\n      )\n    )\n\n    return [\n      {\n        match: route('/:path*'),\n        name: 'public folder catchall',\n        fn: async (req, res, params, parsedUrl) => {\n          const pathParts: string[] = params.path || []\n          const { basePath } = this.nextConfig\n\n          // if basePath is defined require it be present\n          if (basePath) {\n            const basePathParts = basePath.split('/')\n            // remove first empty value\n            basePathParts.shift()\n\n            if (\n              !basePathParts.every((part: string, idx: number) => {\n                return part === pathParts[idx]\n              })\n            ) {\n              return { finished: false }\n            }\n\n            pathParts.splice(0, basePathParts.length)\n          }\n\n          let path = `/${pathParts.join('/')}`\n\n          if (!publicFiles.has(path)) {\n            // In `next-dev-server.ts`, we ensure encoded paths match\n            // decoded paths on the filesystem. So we need do the\n            // opposite here: make sure decoded paths match encoded.\n            path = encodeURI(path)\n          }\n\n          if (publicFiles.has(path)) {\n            await this.serveStatic(\n              req,\n              res,\n              join(this.publicDir, ...pathParts),\n              parsedUrl\n            )\n            return {\n              finished: true,\n            }\n          }\n          return {\n            finished: false,\n          }\n        },\n      } as Route,\n    ]\n  }\n\n  protected getDynamicRoutes(): Array<DynamicRouteItem> {\n    const addedPages = new Set<string>()\n\n    return getSortedRoutes(\n      Object.keys(this.pagesManifest!).map(\n        (page) =>\n          normalizeLocalePath(page, this.nextConfig.i18n?.locales).pathname\n      )\n    )\n      .map((page) => {\n        if (addedPages.has(page) || !isDynamicRoute(page)) return null\n        addedPages.add(page)\n        return {\n          page,\n          match: getRouteMatcher(getRouteRegex(page)),\n        }\n      })\n      .filter((item): item is DynamicRouteItem => Boolean(item))\n  }\n\n  private handleCompression(req: IncomingMessage, res: ServerResponse): void {\n    if (this.compression) {\n      this.compression(req, res, () => {})\n    }\n  }\n\n  protected async run(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<void> {\n    this.handleCompression(req, res)\n\n    try {\n      const matched = await this.router.execute(req, res, parsedUrl)\n      if (matched) {\n        return\n      }\n    } catch (err) {\n      if (err instanceof DecodeError) {\n        res.statusCode = 400\n        return this.renderError(null, req, res, '/_error', {})\n      }\n      throw err\n    }\n\n    await this.render404(req, res, parsedUrl)\n  }\n\n  private async pipe(\n    fn: (ctx: RequestContext) => Promise<ResponsePayload | null>,\n    partialContext: {\n      req: IncomingMessage\n      res: ServerResponse\n      pathname: string\n      query: ParsedUrlQuery\n    }\n  ): Promise<void> {\n    // TODO: Determine when dynamic HTML is allowed\n    const requireStaticHTML = true\n    const ctx = {\n      ...partialContext,\n      renderOpts: {\n        ...this.renderOpts,\n        requireStaticHTML,\n      },\n    } as const\n    const payload = await fn(ctx)\n    if (payload === null) {\n      return\n    }\n    const { req, res } = ctx\n    const { body, type, revalidateOptions } = payload\n    if (!isResSent(res)) {\n      const { generateEtags, poweredByHeader, dev } = this.renderOpts\n      if (dev) {\n        // In dev, we should not cache pages for any reason.\n        res.setHeader('Cache-Control', 'no-store, must-revalidate')\n      }\n      return sendRenderResult({\n        req,\n        res,\n        resultOrPayload: requireStaticHTML\n          ? await resultsToString([body])\n          : body,\n        type,\n        generateEtags,\n        poweredByHeader,\n        options: revalidateOptions,\n      })\n    }\n  }\n\n  private async getStaticHTML(\n    fn: (ctx: RequestContext) => Promise<ResponsePayload | null>,\n    partialContext: {\n      req: IncomingMessage\n      res: ServerResponse\n      pathname: string\n      query: ParsedUrlQuery\n    }\n  ): Promise<string | null> {\n    const payload = await fn({\n      ...partialContext,\n      renderOpts: {\n        ...this.renderOpts,\n        requireStaticHTML: true,\n      },\n    })\n    if (payload === null) {\n      return null\n    }\n    return resultsToString([payload.body])\n  }\n\n  public async render(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {},\n    parsedUrl?: UrlWithParsedQuery\n  ): Promise<void> {\n    if (!pathname.startsWith('/')) {\n      console.warn(\n        `Cannot render page with path \"${pathname}\", did you mean \"/${pathname}\"?. See more info here: https://nextjs.org/docs/messages/render-no-starting-slash`\n      )\n    }\n\n    if (\n      this.renderOpts.customServer &&\n      pathname === '/index' &&\n      !(await this.hasPage('/index'))\n    ) {\n      // maintain backwards compatibility for custom server\n      // (see custom-server integration tests)\n      pathname = '/'\n    }\n\n    const url: any = req.url\n\n    // we allow custom servers to call render for all URLs\n    // so check if we need to serve a static _next file or not.\n    // we don't modify the URL for _next/data request but still\n    // call render so we special case this to prevent an infinite loop\n    if (\n      !this.minimalMode &&\n      !query._nextDataReq &&\n      (url.match(/^\\/_next\\//) ||\n        (this.hasStaticDir && url.match(/^\\/static\\//)))\n    ) {\n      return this.handleRequest(req, res, parsedUrl)\n    }\n\n    // Custom server users can run `app.render()` which needs compression.\n    if (this.renderOpts.customServer) {\n      this.handleCompression(req, res)\n    }\n\n    if (isBlockedPage(pathname)) {\n      return this.render404(req, res, parsedUrl)\n    }\n\n    return this.pipe((ctx) => this.renderToResponse(ctx), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  protected async findPageComponents(\n    pathname: string,\n    query: ParsedUrlQuery = {},\n    params: Params | null = null\n  ): Promise<FindComponentsResult | null> {\n    let paths = [\n      // try serving a static AMP version first\n      query.amp ? normalizePagePath(pathname) + '.amp' : null,\n      pathname,\n    ].filter(Boolean)\n\n    if (query.__nextLocale) {\n      paths = [\n        ...paths.map(\n          (path) => `/${query.__nextLocale}${path === '/' ? '' : path}`\n        ),\n        ...paths,\n      ]\n    }\n\n    for (const pagePath of paths) {\n      try {\n        const components = await loadComponents(\n          this.distDir,\n          pagePath!,\n          !this.renderOpts.dev && this._isLikeServerless\n        )\n\n        if (\n          query.__nextLocale &&\n          typeof components.Component === 'string' &&\n          !pagePath?.startsWith(`/${query.__nextLocale}`)\n        ) {\n          // if loading an static HTML file the locale is required\n          // to be present since all HTML files are output under their locale\n          continue\n        }\n\n        return {\n          components,\n          query: {\n            ...(components.getStaticProps\n              ? {\n                  amp: query.amp,\n                  _nextDataReq: query._nextDataReq,\n                  __nextLocale: query.__nextLocale,\n                  __nextDefaultLocale: query.__nextDefaultLocale,\n                }\n              : query),\n            ...(params || {}),\n          },\n        }\n      } catch (err) {\n        if (err.code !== 'ENOENT') throw err\n      }\n    }\n    return null\n  }\n\n  protected async getStaticPaths(pathname: string): Promise<{\n    staticPaths: string[] | undefined\n    fallbackMode: 'static' | 'blocking' | false\n  }> {\n    // `staticPaths` is intentionally set to `undefined` as it should've\n    // been caught when checking disk data.\n    const staticPaths = undefined\n\n    // Read whether or not fallback should exist from the manifest.\n    const fallbackField =\n      this.getPrerenderManifest().dynamicRoutes[pathname].fallback\n\n    return {\n      staticPaths,\n      fallbackMode:\n        typeof fallbackField === 'string'\n          ? 'static'\n          : fallbackField === null\n          ? 'blocking'\n          : false,\n    }\n  }\n\n  private async renderToResponseWithComponents(\n    { req, res, pathname, renderOpts: opts }: RequestContext,\n    { components, query }: FindComponentsResult\n  ): Promise<ResponsePayload | null> {\n    const is404Page = pathname === '/404'\n    const is500Page = pathname === '/500'\n\n    const isLikeServerless =\n      typeof components.Component === 'object' &&\n      typeof (components.Component as any).renderReqToHTML === 'function'\n    const isSSG = !!components.getStaticProps\n    const hasServerProps = !!components.getServerSideProps\n    const hasStaticPaths = !!components.getStaticPaths\n    const hasGetInitialProps = !!(components.Component as any).getInitialProps\n\n    // Toggle whether or not this is a Data request\n    const isDataReq = !!query._nextDataReq && (isSSG || hasServerProps)\n    delete query._nextDataReq\n\n    // we need to ensure the status code if /404 is visited directly\n    if (is404Page && !isDataReq) {\n      res.statusCode = 404\n    }\n\n    // ensure correct status is set when visiting a status page\n    // directly e.g. /500\n    if (STATIC_STATUS_PAGES.includes(pathname)) {\n      res.statusCode = parseInt(pathname.substr(1), 10)\n    }\n\n    // handle static page\n    if (typeof components.Component === 'string') {\n      return {\n        type: 'html',\n        // TODO: Static pages should be written as chunks\n        body: Observable.of(components.Component),\n      }\n    }\n\n    if (!query.amp) {\n      delete query.amp\n    }\n\n    const locale = query.__nextLocale as string\n    const defaultLocale = isSSG\n      ? this.nextConfig.i18n?.defaultLocale\n      : (query.__nextDefaultLocale as string)\n\n    const { i18n } = this.nextConfig\n    const locales = i18n?.locales\n\n    let previewData: PreviewData\n    let isPreviewMode = false\n\n    if (hasServerProps || isSSG) {\n      previewData = tryGetPreviewData(req, res, this.renderOpts.previewProps)\n      isPreviewMode = previewData !== false\n    }\n\n    // Compute the iSSG cache key. We use the rewroteUrl since\n    // pages with fallback: false are allowed to be rewritten to\n    // and we need to look up the path by the rewritten path\n    let urlPathname = parseUrl(req.url || '').pathname || '/'\n\n    let resolvedUrlPathname = (req as any)._nextRewroteUrl\n      ? (req as any)._nextRewroteUrl\n      : urlPathname\n\n    urlPathname = removePathTrailingSlash(urlPathname)\n    resolvedUrlPathname = normalizeLocalePath(\n      removePathTrailingSlash(resolvedUrlPathname),\n      this.nextConfig.i18n?.locales\n    ).pathname\n\n    const stripNextDataPath = (path: string) => {\n      if (path.includes(this.buildId)) {\n        const splitPath = path.substring(\n          path.indexOf(this.buildId) + this.buildId.length\n        )\n\n        path = denormalizePagePath(splitPath.replace(/\\.json$/, ''))\n      }\n\n      if (this.nextConfig.i18n) {\n        return normalizeLocalePath(path, locales).pathname\n      }\n      return path\n    }\n\n    const handleRedirect = (pageData: any) => {\n      const redirect = {\n        destination: pageData.pageProps.__N_REDIRECT,\n        statusCode: pageData.pageProps.__N_REDIRECT_STATUS,\n        basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH,\n      }\n      const statusCode = getRedirectStatus(redirect)\n      const { basePath } = this.nextConfig\n\n      if (\n        basePath &&\n        redirect.basePath !== false &&\n        redirect.destination.startsWith('/')\n      ) {\n        redirect.destination = `${basePath}${redirect.destination}`\n      }\n\n      if (redirect.destination.startsWith('/')) {\n        redirect.destination = normalizeRepeatedSlashes(redirect.destination)\n      }\n\n      if (statusCode === PERMANENT_REDIRECT_STATUS) {\n        res.setHeader('Refresh', `0;url=${redirect.destination}`)\n      }\n\n      res.statusCode = statusCode\n      res.setHeader('Location', redirect.destination)\n      res.end()\n    }\n\n    // remove /_next/data prefix from urlPathname so it matches\n    // for direct page visit and /_next/data visit\n    if (isDataReq) {\n      resolvedUrlPathname = stripNextDataPath(resolvedUrlPathname)\n      urlPathname = stripNextDataPath(urlPathname)\n    }\n\n    let ssgCacheKey =\n      isPreviewMode || !isSSG || this.minimalMode\n        ? null // Preview mode bypasses the cache\n        : `${locale ? `/${locale}` : ''}${\n            (pathname === '/' || resolvedUrlPathname === '/') && locale\n              ? ''\n              : resolvedUrlPathname\n          }${query.amp ? '.amp' : ''}`\n\n    if ((is404Page || is500Page) && isSSG) {\n      ssgCacheKey = `${locale ? `/${locale}` : ''}${pathname}${\n        query.amp ? '.amp' : ''\n      }`\n    }\n\n    if (ssgCacheKey) {\n      // we only encode path delimiters for path segments from\n      // getStaticPaths so we need to attempt decoding the URL\n      // to match against and only escape the path delimiters\n      // this allows non-ascii values to be handled e.g. Japanese characters\n\n      // TODO: investigate adding this handling for non-SSG pages so\n      // non-ascii names work there also\n      ssgCacheKey = ssgCacheKey\n        .split('/')\n        .map((seg) => {\n          try {\n            seg = escapePathDelimiters(decodeURIComponent(seg), true)\n          } catch (_) {\n            // An improperly encoded URL was provided\n            throw new DecodeError('failed to decode param')\n          }\n          return seg\n        })\n        .join('/')\n    }\n\n    const doRender: () => Promise<ResponseCacheEntry | null> = async () => {\n      let pageData: any\n      let body: RenderResult | null\n      let sprRevalidate: number | false\n      let isNotFound: boolean | undefined\n      let isRedirect: boolean | undefined\n\n      // handle serverless\n      if (isLikeServerless) {\n        const renderResult = await (\n          components.Component as any\n        ).renderReqToHTML(req, res, 'passthrough', {\n          locale,\n          locales,\n          defaultLocale,\n          optimizeCss: this.renderOpts.optimizeCss,\n          distDir: this.distDir,\n          fontManifest: this.renderOpts.fontManifest,\n          domainLocales: this.renderOpts.domainLocales,\n        })\n\n        body = renderResult.html\n        pageData = renderResult.renderOpts.pageData\n        sprRevalidate = renderResult.renderOpts.revalidate\n        isNotFound = renderResult.renderOpts.isNotFound\n        isRedirect = renderResult.renderOpts.isRedirect\n      } else {\n        const origQuery = parseUrl(req.url || '', true).query\n        const hadTrailingSlash =\n          urlPathname !== '/' && this.nextConfig.trailingSlash\n\n        const resolvedUrl = formatUrl({\n          pathname: `${resolvedUrlPathname}${hadTrailingSlash ? '/' : ''}`,\n          // make sure to only add query values from original URL\n          query: origQuery,\n        })\n\n        const renderOpts: RenderOpts = {\n          ...components,\n          ...opts,\n          isDataReq,\n          resolvedUrl,\n          locale,\n          locales,\n          defaultLocale,\n          // For getServerSideProps and getInitialProps we need to ensure we use the original URL\n          // and not the resolved URL to prevent a hydration mismatch on\n          // asPath\n          resolvedAsPath:\n            hasServerProps || hasGetInitialProps\n              ? formatUrl({\n                  // we use the original URL pathname less the _next/data prefix if\n                  // present\n                  pathname: `${urlPathname}${hadTrailingSlash ? '/' : ''}`,\n                  query: origQuery,\n                })\n              : resolvedUrl,\n        }\n\n        const renderResult = await renderToHTML(\n          req,\n          res,\n          pathname,\n          query,\n          renderOpts\n        )\n\n        body = renderResult\n        // TODO: change this to a different passing mechanism\n        pageData = (renderOpts as any).pageData\n        sprRevalidate = (renderOpts as any).revalidate\n        isNotFound = (renderOpts as any).isNotFound\n        isRedirect = (renderOpts as any).isRedirect\n      }\n\n      let value: ResponseCacheValue | null\n      if (isNotFound) {\n        value = null\n      } else if (isRedirect) {\n        value = { kind: 'REDIRECT', props: pageData }\n      } else {\n        if (!body) {\n          return null\n        }\n        value = { kind: 'PAGE', html: body, pageData }\n      }\n      return { revalidate: sprRevalidate, value }\n    }\n\n    const cacheEntry = await this.responseCache.get(\n      ssgCacheKey,\n      async (hasResolved) => {\n        const isProduction = !this.renderOpts.dev\n        const isDynamicPathname = isDynamicRoute(pathname)\n        const didRespond = hasResolved || isResSent(res)\n\n        const { staticPaths, fallbackMode } = hasStaticPaths\n          ? await this.getStaticPaths(pathname)\n          : { staticPaths: undefined, fallbackMode: false }\n\n        // When we did not respond from cache, we need to choose to block on\n        // rendering or return a skeleton.\n        //\n        // * Data requests always block.\n        //\n        // * Blocking mode fallback always blocks.\n        //\n        // * Preview mode toggles all pages to be resolved in a blocking manner.\n        //\n        // * Non-dynamic pages should block (though this is an impossible\n        //   case in production).\n        //\n        // * Dynamic pages should return their skeleton if not defined in\n        //   getStaticPaths, then finish the data request on the client-side.\n        //\n        if (\n          this.minimalMode !== true &&\n          fallbackMode !== 'blocking' &&\n          ssgCacheKey &&\n          !didRespond &&\n          !isPreviewMode &&\n          isDynamicPathname &&\n          // Development should trigger fallback when the path is not in\n          // `getStaticPaths`\n          (isProduction ||\n            !staticPaths ||\n            !staticPaths.includes(\n              // we use ssgCacheKey here as it is normalized to match the\n              // encoding from getStaticPaths along with including the locale\n              query.amp ? ssgCacheKey.replace(/\\.amp$/, '') : ssgCacheKey\n            ))\n        ) {\n          if (\n            // In development, fall through to render to handle missing\n            // getStaticPaths.\n            (isProduction || staticPaths) &&\n            // When fallback isn't present, abort this render so we 404\n            fallbackMode !== 'static'\n          ) {\n            throw new NoFallbackError()\n          }\n\n          if (!isDataReq) {\n            // Production already emitted the fallback as static HTML.\n            if (isProduction) {\n              const html = await this.incrementalCache.getFallback(\n                locale ? `/${locale}${pathname}` : pathname\n              )\n              return {\n                value: {\n                  kind: 'PAGE',\n                  html: Observable.of(html),\n                  pageData: {},\n                },\n              }\n            }\n            // We need to generate the fallback on-demand for development.\n            else {\n              query.__nextFallback = 'true'\n              if (isLikeServerless) {\n                prepareServerlessUrl(req, query)\n              }\n              const result = await doRender()\n              if (!result) {\n                return null\n              }\n              // Prevent caching this result\n              delete result.revalidate\n              return result\n            }\n          }\n        }\n\n        const result = await doRender()\n        if (!result) {\n          return null\n        }\n        return {\n          ...result,\n          revalidate:\n            result.revalidate !== undefined\n              ? result.revalidate\n              : /* default to minimum revalidate (this should be an invariant) */ 1,\n        }\n      }\n    )\n\n    if (!cacheEntry) {\n      if (ssgCacheKey) {\n        // A cache entry might not be generated if a response is written\n        // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n        // have a cache key. If we do have a cache key but we don't end up\n        // with a cache entry, then either Next.js or the application has a\n        // bug that needs fixing.\n        throw new Error('invariant: cache entry required but not generated')\n      }\n      return null\n    }\n\n    const { revalidate, value: cachedData } = cacheEntry\n    const revalidateOptions: any =\n      typeof revalidate !== 'undefined' &&\n      (!this.renderOpts.dev || (hasServerProps && !isDataReq))\n        ? {\n            // When the page is 404 cache-control should not be added\n            private: isPreviewMode || is404Page,\n            stateful: !isSSG,\n            revalidate,\n          }\n        : undefined\n\n    if (!cachedData) {\n      if (revalidateOptions) {\n        setRevalidateHeaders(res, revalidateOptions)\n      }\n      if (isDataReq) {\n        res.statusCode = 404\n        res.end('{\"notFound\":true}')\n        return null\n      } else {\n        await this.render404(req, res, {\n          pathname,\n          query,\n        } as UrlWithParsedQuery)\n        return null\n      }\n    } else if (cachedData.kind === 'REDIRECT') {\n      if (isDataReq) {\n        return {\n          type: 'json',\n          body: Observable.of(JSON.stringify(cachedData.props)),\n          revalidateOptions,\n        }\n      } else {\n        await handleRedirect(cachedData.props)\n        return null\n      }\n    } else {\n      return {\n        type: isDataReq ? 'json' : 'html',\n        body: isDataReq\n          ? Observable.of(JSON.stringify(cachedData.pageData))\n          : cachedData.html,\n        revalidateOptions,\n      }\n    }\n  }\n\n  private async renderToResponse(\n    ctx: RequestContext\n  ): Promise<ResponsePayload | null> {\n    const { res, query, pathname } = ctx\n    let page = pathname\n    const bubbleNoFallback = !!query._nextBubbleNoFallback\n    delete query._nextBubbleNoFallback\n\n    try {\n      const result = await this.findPageComponents(pathname, query)\n      if (result) {\n        try {\n          return await this.renderToResponseWithComponents(ctx, result)\n        } catch (err) {\n          const isNoFallbackError = err instanceof NoFallbackError\n\n          if (!isNoFallbackError || (isNoFallbackError && bubbleNoFallback)) {\n            throw err\n          }\n        }\n      }\n\n      if (this.dynamicRoutes) {\n        for (const dynamicRoute of this.dynamicRoutes) {\n          const params = dynamicRoute.match(pathname)\n          if (!params) {\n            continue\n          }\n\n          const dynamicRouteResult = await this.findPageComponents(\n            dynamicRoute.page,\n            query,\n            params\n          )\n          if (dynamicRouteResult) {\n            try {\n              page = dynamicRoute.page\n              return await this.renderToResponseWithComponents(\n                {\n                  ...ctx,\n                  pathname: dynamicRoute.page,\n                  renderOpts: {\n                    ...ctx.renderOpts,\n                    params,\n                  },\n                },\n                dynamicRouteResult\n              )\n            } catch (err) {\n              const isNoFallbackError = err instanceof NoFallbackError\n\n              if (\n                !isNoFallbackError ||\n                (isNoFallbackError && bubbleNoFallback)\n              ) {\n                throw err\n              }\n            }\n          }\n        }\n      }\n    } catch (err) {\n      if (err instanceof NoFallbackError && bubbleNoFallback) {\n        throw err\n      }\n      if (err instanceof DecodeError) {\n        res.statusCode = 400\n        return await this.renderErrorToResponse(ctx, err)\n      }\n\n      res.statusCode = 500\n      const isWrappedError = err instanceof WrappedBuildError\n      const response = await this.renderErrorToResponse(\n        ctx,\n        isWrappedError ? err.innerError : err\n      )\n\n      if (!isWrappedError) {\n        if (this.minimalMode || this.renderOpts.dev) {\n          if (err) {\n            err.page = page\n          }\n          throw err\n        }\n        this.logError(err)\n      }\n      return response\n    }\n    res.statusCode = 404\n    return this.renderErrorToResponse(ctx, null)\n  }\n\n  public async renderToHTML(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return this.getStaticHTML((ctx) => this.renderToResponse(ctx), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  public async renderError(\n    err: Error | null,\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {},\n    setHeaders = true\n  ): Promise<void> {\n    if (setHeaders) {\n      res.setHeader(\n        'Cache-Control',\n        'no-cache, no-store, max-age=0, must-revalidate'\n      )\n    }\n\n    return this.pipe(\n      async (ctx) => {\n        const response = await this.renderErrorToResponse(ctx, err)\n        if (this.minimalMode && res.statusCode === 500) {\n          throw err\n        }\n        return response\n      },\n      { req, res, pathname, query }\n    )\n  }\n\n  private customErrorNo404Warn = execOnce(() => {\n    console.warn(\n      chalk.bold.yellow(`Warning: `) +\n        chalk.yellow(\n          `You have added a custom /_error page without a custom /404 page. This prevents the 404 page from being auto statically optimized.\\nSee here for info: https://nextjs.org/docs/messages/custom-error-no-custom-404`\n        )\n    )\n  })\n\n  private async renderErrorToResponse(\n    ctx: RequestContext,\n    _err: Error | null\n  ): Promise<ResponsePayload | null> {\n    const { res, query } = ctx\n    let err = _err\n    if (this.renderOpts.dev && !err && res.statusCode === 500) {\n      err = new Error(\n        'An undefined error was thrown sometime during render... ' +\n          'See https://nextjs.org/docs/messages/threw-undefined'\n      )\n    }\n    try {\n      let result: null | FindComponentsResult = null\n\n      const is404 = res.statusCode === 404\n      let using404Page = false\n\n      // use static 404 page if available and is 404 response\n      if (is404) {\n        result = await this.findPageComponents('/404', query)\n        using404Page = result !== null\n      }\n      let statusPage = `/${res.statusCode}`\n\n      if (!result && STATIC_STATUS_PAGES.includes(statusPage)) {\n        result = await this.findPageComponents(statusPage, query)\n      }\n\n      if (!result) {\n        result = await this.findPageComponents('/_error', query)\n        statusPage = '/_error'\n      }\n\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        !using404Page &&\n        (await this.hasPage('/_error')) &&\n        !(await this.hasPage('/404'))\n      ) {\n        this.customErrorNo404Warn()\n      }\n\n      try {\n        return await this.renderToResponseWithComponents(\n          {\n            ...ctx,\n            pathname: statusPage,\n            renderOpts: {\n              ...ctx.renderOpts,\n              err,\n            },\n          },\n          result!\n        )\n      } catch (maybeFallbackError) {\n        if (maybeFallbackError instanceof NoFallbackError) {\n          throw new Error('invariant: failed to render error page')\n        }\n        throw maybeFallbackError\n      }\n    } catch (renderToHtmlError) {\n      const isWrappedError = renderToHtmlError instanceof WrappedBuildError\n      if (!isWrappedError) {\n        this.logError(renderToHtmlError)\n      }\n      res.statusCode = 500\n      const fallbackComponents = await this.getFallbackErrorComponents()\n\n      if (fallbackComponents) {\n        return this.renderToResponseWithComponents(\n          {\n            ...ctx,\n            pathname: '/_error',\n            renderOpts: {\n              ...ctx.renderOpts,\n              // We render `renderToHtmlError` here because `err` is\n              // already captured in the stacktrace.\n              err: isWrappedError\n                ? renderToHtmlError.innerError\n                : renderToHtmlError,\n            },\n          },\n          {\n            query,\n            components: fallbackComponents,\n          }\n        )\n      }\n      return {\n        type: 'html',\n        body: Observable.of('Internal Server Error'),\n      }\n    }\n  }\n\n  public async renderErrorToHTML(\n    err: Error | null,\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return this.getStaticHTML((ctx) => this.renderErrorToResponse(ctx, err), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  protected async getFallbackErrorComponents(): Promise<LoadComponentsReturnType | null> {\n    // The development server will provide an implementation for this\n    return null\n  }\n\n  public async render404(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl?: UrlWithParsedQuery,\n    setHeaders = true\n  ): Promise<void> {\n    const url: any = req.url\n    const { pathname, query } = parsedUrl ? parsedUrl : parseUrl(url, true)\n    const { i18n } = this.nextConfig\n\n    if (i18n) {\n      query.__nextLocale = query.__nextLocale || i18n.defaultLocale\n      query.__nextDefaultLocale =\n        query.__nextDefaultLocale || i18n.defaultLocale\n    }\n\n    res.statusCode = 404\n    return this.renderError(null, req, res, pathname!, query, setHeaders)\n  }\n\n  public async serveStatic(\n    req: IncomingMessage,\n    res: ServerResponse,\n    path: string,\n    parsedUrl?: UrlWithParsedQuery\n  ): Promise<void> {\n    if (!this.isServeableUrl(path)) {\n      return this.render404(req, res, parsedUrl)\n    }\n\n    if (!(req.method === 'GET' || req.method === 'HEAD')) {\n      res.statusCode = 405\n      res.setHeader('Allow', ['GET', 'HEAD'])\n      return this.renderError(null, req, res, path)\n    }\n\n    try {\n      await serveStatic(req, res, path)\n    } catch (err) {\n      if (err.code === 'ENOENT' || err.statusCode === 404) {\n        this.render404(req, res, parsedUrl)\n      } else if (err.statusCode === 412) {\n        res.statusCode = 412\n        return this.renderError(err, req, res, path)\n      } else {\n        throw err\n      }\n    }\n  }\n\n  private _validFilesystemPathSet: Set<string> | null = null\n  private getFilesystemPaths(): Set<string> {\n    if (this._validFilesystemPathSet) {\n      return this._validFilesystemPathSet\n    }\n\n    const pathUserFilesStatic = join(this.dir, 'static')\n    let userFilesStatic: string[] = []\n    if (this.hasStaticDir && fs.existsSync(pathUserFilesStatic)) {\n      userFilesStatic = recursiveReadDirSync(pathUserFilesStatic).map((f) =>\n        join('.', 'static', f)\n      )\n    }\n\n    let userFilesPublic: string[] = []\n    if (this.publicDir && fs.existsSync(this.publicDir)) {\n      userFilesPublic = recursiveReadDirSync(this.publicDir).map((f) =>\n        join('.', 'public', f)\n      )\n    }\n\n    let nextFilesStatic: string[] = []\n    nextFilesStatic = !this.minimalMode\n      ? recursiveReadDirSync(join(this.distDir, 'static')).map((f) =>\n          join('.', relative(this.dir, this.distDir), 'static', f)\n        )\n      : []\n\n    return (this._validFilesystemPathSet = new Set<string>([\n      ...nextFilesStatic,\n      ...userFilesPublic,\n      ...userFilesStatic,\n    ]))\n  }\n\n  protected isServeableUrl(untrustedFileUrl: string): boolean {\n    // This method mimics what the version of `send` we use does:\n    // 1. decodeURIComponent:\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L989\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L518-L522\n    // 2. resolve:\n    //    https://github.com/pillarjs/send/blob/de073ed3237ade9ff71c61673a34474b30e5d45b/index.js#L561\n\n    let decodedUntrustedFilePath: string\n    try {\n      // (1) Decode the URL so we have the proper file name\n      decodedUntrustedFilePath = decodeURIComponent(untrustedFileUrl)\n    } catch {\n      return false\n    }\n\n    // (2) Resolve \"up paths\" to determine real request\n    const untrustedFilePath = resolve(decodedUntrustedFilePath)\n\n    // don't allow null bytes anywhere in the file path\n    if (untrustedFilePath.indexOf('\\0') !== -1) {\n      return false\n    }\n\n    // Check if .next/static, static and public are in the path.\n    // If not the path is not available.\n    if (\n      (untrustedFilePath.startsWith(join(this.distDir, 'static') + sep) ||\n        untrustedFilePath.startsWith(join(this.dir, 'static') + sep) ||\n        untrustedFilePath.startsWith(join(this.dir, 'public') + sep)) === false\n    ) {\n      return false\n    }\n\n    // Check against the real filesystem paths\n    const filesystemUrls = this.getFilesystemPaths()\n    const resolved = relative(this.dir, untrustedFilePath)\n    return filesystemUrls.has(resolved)\n  }\n\n  protected readBuildId(): string {\n    const buildIdFile = join(this.distDir, BUILD_ID_FILE)\n    try {\n      return fs.readFileSync(buildIdFile, 'utf8').trim()\n    } catch (err) {\n      if (!fs.existsSync(buildIdFile)) {\n        throw new Error(\n          `Could not find a production build in the '${this.distDir}' directory. Try building your app with 'next build' before starting the production server. https://nextjs.org/docs/messages/production-start-no-build-id`\n        )\n      }\n\n      throw err\n    }\n  }\n\n  protected get _isLikeServerless(): boolean {\n    return isTargetLikeServerless(this.nextConfig.target)\n  }\n}\n\nfunction prepareServerlessUrl(\n  req: IncomingMessage,\n  query: ParsedUrlQuery\n): void {\n  const curUrl = parseUrl(req.url!, true)\n  req.url = formatUrl({\n    ...curUrl,\n    search: undefined,\n    query: {\n      ...curUrl.query,\n      ...query,\n    },\n  })\n}\n\nclass NoFallbackError extends Error {}\n\n// Internal wrapper around build errors at development\n// time, to prevent us from propagating or logging them\nexport class WrappedBuildError extends Error {\n  innerError: Error\n\n  constructor(innerError: Error) {\n    super()\n    this.innerError = innerError\n  }\n}\n\ntype ResponsePayload = {\n  type: 'html' | 'json'\n  body: RenderResult\n  revalidateOptions?: any\n}\n"]},"metadata":{},"sourceType":"script"}