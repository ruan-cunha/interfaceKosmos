{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _webpack = require(\"next/dist/compiled/webpack/webpack\");\n\nvar _fontUtils = require(\"../../../server/font-utils\");\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _cssnanoSimple = _interopRequireDefault(require(\"cssnano-simple\"));\n\nvar _constants = require(\"../../../shared/lib/constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction minifyCss(css) {\n  return (0, _postcss).default([(0, _cssnanoSimple).default({\n    excludeAll: true,\n    discardComments: true,\n    normalizeWhitespace: {\n      exclude: false\n    }\n  }, _postcss.default)]).process(css, {\n    from: undefined\n  }).then(res => res.css);\n}\n\nclass FontStylesheetGatheringPlugin {\n  constructor({\n    isLikeServerless\n  }) {\n    this.gatheredStylesheets = [];\n    this.manifestContent = [];\n\n    this.parserHandler = factory => {\n      const JS_TYPES = ['auto', 'esm', 'dynamic']; // Do an extra walk per module and add interested visitors to the walk.\n\n      for (const type of JS_TYPES) {\n        factory.hooks.parser.for('javascript/' + type).tap(this.constructor.name, parser => {\n          /**\n          * Webpack fun facts:\n          * `parser.hooks.call.for` cannot catch calls for user defined identifiers like `__jsx`\n          * it can only detect calls for native objects like `window`, `this`, `eval` etc.\n          * In order to be able to catch calls of variables like `__jsx`, first we need to catch them as\n          * Identifier and then return `BasicEvaluatedExpression` whose `id` and `type` webpack matches to\n          * invoke hook for call.\n          * See: https://github.com/webpack/webpack/blob/webpack-4/lib/Parser.js#L1931-L1932.\n          */\n          parser.hooks.evaluate.for('Identifier').tap(this.constructor.name, node => {\n            var ref, ref1; // We will only optimize fonts from first party code.\n\n            if (parser === null || parser === void 0 ? void 0 : (ref = parser.state) === null || ref === void 0 ? void 0 : (ref1 = ref.module) === null || ref1 === void 0 ? void 0 : ref1.resource.includes('node_modules')) {\n              return;\n            }\n\n            let result;\n\n            if (node.name === '_jsx' || node.name === '__jsx') {\n              result = new _webpack.BasicEvaluatedExpression(); // @ts-ignore\n\n              result.setRange(node.range);\n              result.setExpression(node);\n              result.setIdentifier(node.name); // This was added webpack 5.\n\n              if (_webpack.isWebpack5) {\n                result.getMembers = () => [];\n              }\n            }\n\n            return result;\n          });\n\n          const jsxNodeHandler = node => {\n            if (node.arguments.length !== 2) {\n              // A font link tag has only two arguments rel=stylesheet and href='...'\n              return;\n            }\n\n            if (!isNodeCreatingLinkElement(node)) {\n              return;\n            } // node.arguments[0] is the name of the tag and [1] are the props.\n\n\n            const arg1 = node.arguments[1];\n            const propsNode = arg1.type === 'ObjectExpression' ? arg1 : undefined;\n            const props = {};\n\n            if (propsNode) {\n              propsNode.properties.forEach(prop => {\n                if (prop.type !== 'Property') {\n                  return;\n                }\n\n                if (prop.key.type === 'Identifier' && prop.value.type === 'Literal') {\n                  props[prop.key.name] = prop.value.value;\n                }\n              });\n            }\n\n            if (!props.rel || props.rel !== 'stylesheet' || !props.href || !_constants.OPTIMIZED_FONT_PROVIDERS.some(({\n              url\n            }) => props.href.startsWith(url))) {\n              return false;\n            }\n\n            this.gatheredStylesheets.push(props.href);\n\n            if (_webpack.isWebpack5) {\n              var ref5, ref6;\n              const buildInfo = parser === null || parser === void 0 ? void 0 : (ref5 = parser.state) === null || ref5 === void 0 ? void 0 : (ref6 = ref5.module) === null || ref6 === void 0 ? void 0 : ref6.buildInfo;\n\n              if (buildInfo) {\n                buildInfo.valueDependencies.set(_constants.FONT_MANIFEST, this.gatheredStylesheets);\n              }\n            }\n          }; // React JSX transform:\n\n\n          parser.hooks.call.for('_jsx').tap(this.constructor.name, jsxNodeHandler); // Next.js JSX transform:\n\n          parser.hooks.call.for('__jsx').tap(this.constructor.name, jsxNodeHandler); // New React JSX transform:\n\n          parser.hooks.call.for('imported var').tap(this.constructor.name, jsxNodeHandler);\n        });\n      }\n    };\n\n    this.isLikeServerless = isLikeServerless;\n  }\n\n  apply(compiler) {\n    this.compiler = compiler;\n    compiler.hooks.normalModuleFactory.tap(this.constructor.name, this.parserHandler);\n    compiler.hooks.make.tapAsync(this.constructor.name, (compilation, cb) => {\n      if (this.isLikeServerless) {\n        /**\n        * Inline font manifest for serverless case only.\n        * For target: server drive the manifest through physical file and less of webpack magic.\n        */\n        const mainTemplate = compilation.mainTemplate;\n        mainTemplate.hooks.requireExtensions.tap(this.constructor.name, source => {\n          return `${source}\n                // Font manifest declaration\n                ${_webpack.isWebpack5 ? '__webpack_require__' : mainTemplate.requireFn}.__NEXT_FONT_MANIFEST__ = ${JSON.stringify(this.manifestContent)};\n            // Enable feature:\n            process.env.__NEXT_OPTIMIZE_FONTS = JSON.stringify(true);`;\n        });\n      }\n\n      compilation.hooks.finishModules.tapAsync(this.constructor.name, async (modules, modulesFinished) => {\n        let fontStylesheets = this.gatheredStylesheets;\n\n        if (_webpack.isWebpack5) {\n          const fontUrls = new Set();\n          modules.forEach(module => {\n            var ref7, ref8;\n            const fontDependencies = module === null || module === void 0 ? void 0 : (ref7 = module.buildInfo) === null || ref7 === void 0 ? void 0 : (ref8 = ref7.valueDependencies) === null || ref8 === void 0 ? void 0 : ref8.get(_constants.FONT_MANIFEST);\n\n            if (fontDependencies) {\n              fontDependencies.forEach(v => fontUrls.add(v));\n            }\n          });\n          fontStylesheets = Array.from(fontUrls);\n        }\n\n        const fontDefinitionPromises = fontStylesheets.map(url => (0, _fontUtils).getFontDefinitionFromNetwork(url));\n        this.manifestContent = [];\n\n        for (let promiseIndex in fontDefinitionPromises) {\n          const css = await fontDefinitionPromises[promiseIndex];\n\n          if (css) {\n            const content = await minifyCss(css);\n            this.manifestContent.push({\n              url: fontStylesheets[promiseIndex],\n              content\n            });\n          }\n        }\n\n        if (!_webpack.isWebpack5) {\n          compilation.assets[_constants.FONT_MANIFEST] = new _webpack.sources.RawSource(JSON.stringify(this.manifestContent, null, '  '));\n        }\n\n        modulesFinished();\n      });\n      cb();\n    });\n\n    if (_webpack.isWebpack5) {\n      compiler.hooks.make.tap(this.constructor.name, compilation => {\n        // @ts-ignore TODO: Remove ignore when webpack 5 is stable\n        compilation.hooks.processAssets.tap({\n          name: this.constructor.name,\n          // @ts-ignore TODO: Remove ignore when webpack 5 is stable\n          stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS\n        }, assets => {\n          assets['../' + _constants.FONT_MANIFEST] = new _webpack.sources.RawSource(JSON.stringify(this.manifestContent, null, '  '));\n        });\n      });\n    }\n  }\n\n}\n\nexports.FontStylesheetGatheringPlugin = FontStylesheetGatheringPlugin;\n\nfunction isNodeCreatingLinkElement(node) {\n  const callee = node.callee;\n\n  if (callee.type !== 'Identifier') {\n    return false;\n  }\n\n  const componentNode = node.arguments[0];\n\n  if (componentNode.type !== 'Literal') {\n    return false;\n  } // React has pragma: _jsx.\n  // Next has pragma: __jsx.\n\n\n  return (callee.name === '_jsx' || callee.name === '__jsx') && componentNode.value === 'link';\n}","map":{"version":3,"sources":["../../../../build/webpack/plugins/font-stylesheet-gathering-plugin.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  webpack,\n  BasicEvaluatedExpression,\n  isWebpack5,\n  sources,\n} from 'next/dist/compiled/webpack/webpack'\nimport { namedTypes } from 'ast-types'\nimport {\n  getFontDefinitionFromNetwork,\n  FontManifest,\n} from '../../../server/font-utils'\nimport postcss from 'postcss'\nimport minifier from 'cssnano-simple'\nimport {\n  FONT_MANIFEST,\n  OPTIMIZED_FONT_PROVIDERS,\n} from '../../../shared/lib/constants'\n\nfunction minifyCss(css: string): Promise<string> {\n  return postcss([\n    minifier(\n      {\n        excludeAll: true,\n        discardComments: true,\n        normalizeWhitespace: { exclude: false },\n      },\n      postcss\n    ),\n  ])\n    .process(css, { from: undefined })\n    .then((res) => res.css)\n}\n\nexport class FontStylesheetGatheringPlugin {\n  compiler?: webpack.Compiler\n  gatheredStylesheets: Array<string> = []\n  manifestContent: FontManifest = []\n  isLikeServerless: boolean\n\n  constructor({ isLikeServerless }: { isLikeServerless: boolean }) {\n    this.isLikeServerless = isLikeServerless\n  }\n\n  private parserHandler = (\n    factory: webpack.compilation.NormalModuleFactory\n  ): void => {\n    const JS_TYPES = ['auto', 'esm', 'dynamic']\n    // Do an extra walk per module and add interested visitors to the walk.\n    for (const type of JS_TYPES) {\n      factory.hooks.parser\n        .for('javascript/' + type)\n        .tap(this.constructor.name, (parser: any) => {\n          /**\n           * Webpack fun facts:\n           * `parser.hooks.call.for` cannot catch calls for user defined identifiers like `__jsx`\n           * it can only detect calls for native objects like `window`, `this`, `eval` etc.\n           * In order to be able to catch calls of variables like `__jsx`, first we need to catch them as\n           * Identifier and then return `BasicEvaluatedExpression` whose `id` and `type` webpack matches to\n           * invoke hook for call.\n           * See: https://github.com/webpack/webpack/blob/webpack-4/lib/Parser.js#L1931-L1932.\n           */\n          parser.hooks.evaluate\n            .for('Identifier')\n            .tap(this.constructor.name, (node: namedTypes.Identifier) => {\n              // We will only optimize fonts from first party code.\n              if (parser?.state?.module?.resource.includes('node_modules')) {\n                return\n              }\n              let result\n              if (node.name === '_jsx' || node.name === '__jsx') {\n                result = new BasicEvaluatedExpression()\n                // @ts-ignore\n                result.setRange(node.range)\n                result.setExpression(node)\n                result.setIdentifier(node.name)\n\n                // This was added webpack 5.\n                if (isWebpack5) {\n                  result.getMembers = () => []\n                }\n              }\n              return result\n            })\n\n          const jsxNodeHandler = (node: namedTypes.CallExpression) => {\n            if (node.arguments.length !== 2) {\n              // A font link tag has only two arguments rel=stylesheet and href='...'\n              return\n            }\n            if (!isNodeCreatingLinkElement(node)) {\n              return\n            }\n\n            // node.arguments[0] is the name of the tag and [1] are the props.\n            const arg1 = node.arguments[1]\n\n            const propsNode =\n              arg1.type === 'ObjectExpression'\n                ? (arg1 as namedTypes.ObjectExpression)\n                : undefined\n            const props: { [key: string]: string } = {}\n            if (propsNode) {\n              propsNode.properties.forEach((prop) => {\n                if (prop.type !== 'Property') {\n                  return\n                }\n                if (\n                  prop.key.type === 'Identifier' &&\n                  prop.value.type === 'Literal'\n                ) {\n                  props[prop.key.name] = prop.value.value as string\n                }\n              })\n            }\n\n            if (\n              !props.rel ||\n              props.rel !== 'stylesheet' ||\n              !props.href ||\n              !OPTIMIZED_FONT_PROVIDERS.some(({ url }) =>\n                props.href.startsWith(url)\n              )\n            ) {\n              return false\n            }\n\n            this.gatheredStylesheets.push(props.href)\n\n            if (isWebpack5) {\n              const buildInfo = parser?.state?.module?.buildInfo\n\n              if (buildInfo) {\n                buildInfo.valueDependencies.set(\n                  FONT_MANIFEST,\n                  this.gatheredStylesheets\n                )\n              }\n            }\n          }\n\n          // React JSX transform:\n          parser.hooks.call\n            .for('_jsx')\n            .tap(this.constructor.name, jsxNodeHandler)\n          // Next.js JSX transform:\n          parser.hooks.call\n            .for('__jsx')\n            .tap(this.constructor.name, jsxNodeHandler)\n          // New React JSX transform:\n          parser.hooks.call\n            .for('imported var')\n            .tap(this.constructor.name, jsxNodeHandler)\n        })\n    }\n  }\n\n  public apply(compiler: webpack.Compiler) {\n    this.compiler = compiler\n    compiler.hooks.normalModuleFactory.tap(\n      this.constructor.name,\n      this.parserHandler\n    )\n    compiler.hooks.make.tapAsync(this.constructor.name, (compilation, cb) => {\n      if (this.isLikeServerless) {\n        /**\n         * Inline font manifest for serverless case only.\n         * For target: server drive the manifest through physical file and less of webpack magic.\n         */\n        const mainTemplate = compilation.mainTemplate\n        mainTemplate.hooks.requireExtensions.tap(\n          this.constructor.name,\n          (source: string) => {\n            return `${source}\n                // Font manifest declaration\n                ${\n                  isWebpack5 ? '__webpack_require__' : mainTemplate.requireFn\n                }.__NEXT_FONT_MANIFEST__ = ${JSON.stringify(\n              this.manifestContent\n            )};\n            // Enable feature:\n            process.env.__NEXT_OPTIMIZE_FONTS = JSON.stringify(true);`\n          }\n        )\n      }\n      compilation.hooks.finishModules.tapAsync(\n        this.constructor.name,\n        async (modules: any, modulesFinished: Function) => {\n          let fontStylesheets = this.gatheredStylesheets\n\n          if (isWebpack5) {\n            const fontUrls = new Set<string>()\n            modules.forEach((module: any) => {\n              const fontDependencies =\n                module?.buildInfo?.valueDependencies?.get(FONT_MANIFEST)\n              if (fontDependencies) {\n                fontDependencies.forEach((v: string) => fontUrls.add(v))\n              }\n            })\n\n            fontStylesheets = Array.from(fontUrls)\n          }\n\n          const fontDefinitionPromises = fontStylesheets.map((url) =>\n            getFontDefinitionFromNetwork(url)\n          )\n\n          this.manifestContent = []\n          for (let promiseIndex in fontDefinitionPromises) {\n            const css = await fontDefinitionPromises[promiseIndex]\n\n            if (css) {\n              const content = await minifyCss(css)\n              this.manifestContent.push({\n                url: fontStylesheets[promiseIndex],\n                content,\n              })\n            }\n          }\n          if (!isWebpack5) {\n            compilation.assets[FONT_MANIFEST] = new sources.RawSource(\n              JSON.stringify(this.manifestContent, null, '  ')\n            )\n          }\n          modulesFinished()\n        }\n      )\n      cb()\n    })\n\n    if (isWebpack5) {\n      compiler.hooks.make.tap(this.constructor.name, (compilation) => {\n        // @ts-ignore TODO: Remove ignore when webpack 5 is stable\n        compilation.hooks.processAssets.tap(\n          {\n            name: this.constructor.name,\n            // @ts-ignore TODO: Remove ignore when webpack 5 is stable\n            stage: webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS,\n          },\n          (assets: any) => {\n            assets['../' + FONT_MANIFEST] = new sources.RawSource(\n              JSON.stringify(this.manifestContent, null, '  ')\n            )\n          }\n        )\n      })\n    }\n  }\n}\n\nfunction isNodeCreatingLinkElement(node: namedTypes.CallExpression) {\n  const callee = node.callee as namedTypes.Identifier\n  if (callee.type !== 'Identifier') {\n    return false\n  }\n  const componentNode = node.arguments[0] as namedTypes.Literal\n  if (componentNode.type !== 'Literal') {\n    return false\n  }\n  // React has pragma: _jsx.\n  // Next has pragma: __jsx.\n  return (\n    (callee.name === '_jsx' || callee.name === '__jsx') &&\n    componentNode.value === 'link'\n  )\n}\n"]},"metadata":{},"sourceType":"script"}