{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchHas = matchHas;\nexports.compileNonPath = compileNonPath;\nexports.default = prepareDestination;\nexports.getSafeParamName = void 0;\n\nvar _parseUrl = require(\"./parse-url\");\n\nvar pathToRegexp = _interopRequireWildcard(require(\"next/dist/compiled/path-to-regexp\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nconst getSafeParamName = paramName => {\n  let newParamName = '';\n\n  for (let i = 0; i < paramName.length; i++) {\n    const charCode = paramName.charCodeAt(i);\n\n    if (charCode > 64 && charCode < 91 || charCode > 96 && charCode < 123 // a-z\n    ) {\n      newParamName += paramName[i];\n    }\n  }\n\n  return newParamName;\n};\n\nexports.getSafeParamName = getSafeParamName;\n\nfunction matchHas(req, has, query) {\n  const params = {};\n  const allMatch = has.every(hasItem => {\n    let value;\n    let key = hasItem.key;\n\n    switch (hasItem.type) {\n      case 'header':\n        {\n          key = key.toLowerCase();\n          value = req.headers[key];\n          break;\n        }\n\n      case 'cookie':\n        {\n          value = req.cookies[hasItem.key];\n          break;\n        }\n\n      case 'query':\n        {\n          value = query[key];\n          break;\n        }\n\n      case 'host':\n        {\n          const {\n            host\n          } = (req === null || req === void 0 ? void 0 : req.headers) || {}; // remove port from host if present\n\n          const hostname = host === null || host === void 0 ? void 0 : host.split(':')[0].toLowerCase();\n          value = hostname;\n          break;\n        }\n\n      default:\n        {\n          break;\n        }\n    }\n\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key)] = value;\n      return true;\n    } else if (value) {\n      const matcher = new RegExp(`^${hasItem.value}$`);\n      const matches = value.match(matcher);\n\n      if (matches) {\n        if (matches.groups) {\n          Object.keys(matches.groups).forEach(groupKey => {\n            params[groupKey] = matches.groups[groupKey];\n          });\n        } else if (hasItem.type === 'host' && matches[0]) {\n          params.host = matches[0];\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  });\n\n  if (allMatch) {\n    return params;\n  }\n\n  return false;\n}\n\nfunction compileNonPath(value, params) {\n  if (!value.includes(':')) {\n    return value;\n  }\n\n  for (const key of Object.keys(params)) {\n    if (value.includes(`:${key}`)) {\n      value = value.replace(new RegExp(`:${key}\\\\*`, 'g'), `:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\\\?`, 'g'), `:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\\\w)`, 'g'), `--ESCAPED_PARAM_COLON${key}`);\n    }\n  }\n\n  value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*'); // the value needs to start with a forward-slash to be compiled\n  // correctly\n\n  return pathToRegexp.compile(`/${value}`, {\n    validate: false\n  })(params).substr(1);\n}\n\nfunction prepareDestination(destination, params, query, appendParamsToQuery) {\n  // clone query so we don't modify the original\n  query = Object.assign({}, query);\n  const hadLocale = query.__nextLocale;\n  delete query.__nextLocale;\n  delete query.__nextDefaultLocale;\n  const parsedDestination = (0, _parseUrl).parseUrl(destination);\n  const destQuery = parsedDestination.query;\n  const destPath = `${parsedDestination.pathname}${parsedDestination.hash || ''}`;\n  const destPathParamKeys = [];\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);\n  const destPathParams = destPathParamKeys.map(key => key.name);\n  let destinationCompiler = pathToRegexp.compile(destPath, // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  let newUrl; // update any params in query values\n\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    if (Array.isArray(strOrArray)) {\n      destQuery[key] = strOrArray.map(value => compileNonPath(value, params));\n    } else {\n      destQuery[key] = compileNonPath(strOrArray, params);\n    }\n  } // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n\n\n  let paramKeys = Object.keys(params); // remove internal param for i18n\n\n  if (hadLocale) {\n    paramKeys = paramKeys.filter(name => name !== 'nextInternalLocale');\n  }\n\n  if (appendParamsToQuery && !paramKeys.some(key1 => destPathParams.includes(key1))) {\n    for (const key1 of paramKeys) {\n      if (!(key1 in destQuery)) {\n        destQuery[key1] = params[key1];\n      }\n    }\n  }\n\n  try {\n    newUrl = destinationCompiler(params);\n    const [pathname, hash] = newUrl.split('#');\n    parsedDestination.pathname = pathname;\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`);\n    }\n\n    throw err;\n  } // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n\n\n  parsedDestination.query = { ...query,\n    ...parsedDestination.query\n  };\n  return {\n    newUrl,\n    parsedDestination\n  };\n}","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/prepare-destination.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { ParsedUrlQuery } from 'querystring'\nimport { parseUrl } from './parse-url'\nimport * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\nimport type { RouteHas } from '../../../../lib/load-custom-routes'\n\ntype Params = { [param: string]: any }\n\n// ensure only a-zA-Z are used for param names for proper interpolating\n// with path-to-regexp\nexport const getSafeParamName = (paramName: string) => {\n  let newParamName = ''\n\n  for (let i = 0; i < paramName.length; i++) {\n    const charCode = paramName.charCodeAt(i)\n\n    if (\n      (charCode > 64 && charCode < 91) || // A-Z\n      (charCode > 96 && charCode < 123) // a-z\n    ) {\n      newParamName += paramName[i]\n    }\n  }\n  return newParamName\n}\n\nexport function matchHas(\n  req: IncomingMessage,\n  has: RouteHas[],\n  query: Params\n): false | Params {\n  const params: Params = {}\n\n  const allMatch = has.every((hasItem) => {\n    let value: undefined | string\n    let key = hasItem.key\n\n    switch (hasItem.type) {\n      case 'header': {\n        key = key!.toLowerCase()\n        value = req.headers[key] as string\n        break\n      }\n      case 'cookie': {\n        value = (req as any).cookies[hasItem.key]\n        break\n      }\n      case 'query': {\n        value = query[key!]\n        break\n      }\n      case 'host': {\n        const { host } = req?.headers || {}\n        // remove port from host if present\n        const hostname = host?.split(':')[0].toLowerCase()\n        value = hostname\n        break\n      }\n      default: {\n        break\n      }\n    }\n\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key!)] = value\n      return true\n    } else if (value) {\n      const matcher = new RegExp(`^${hasItem.value}$`)\n      const matches = value.match(matcher)\n\n      if (matches) {\n        if (matches.groups) {\n          Object.keys(matches.groups).forEach((groupKey) => {\n            params[groupKey] = matches.groups![groupKey]\n          })\n        } else if (hasItem.type === 'host' && matches[0]) {\n          params.host = matches[0]\n        }\n        return true\n      }\n    }\n    return false\n  })\n\n  if (allMatch) {\n    return params\n  }\n  return false\n}\n\nexport function compileNonPath(value: string, params: Params): string {\n  if (!value.includes(':')) {\n    return value\n  }\n\n  for (const key of Object.keys(params)) {\n    if (value.includes(`:${key}`)) {\n      value = value\n        .replace(\n          new RegExp(`:${key}\\\\*`, 'g'),\n          `:${key}--ESCAPED_PARAM_ASTERISKS`\n        )\n        .replace(\n          new RegExp(`:${key}\\\\?`, 'g'),\n          `:${key}--ESCAPED_PARAM_QUESTION`\n        )\n        .replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`)\n        .replace(\n          new RegExp(`:${key}(?!\\\\w)`, 'g'),\n          `--ESCAPED_PARAM_COLON${key}`\n        )\n    }\n  }\n  value = value\n    .replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1')\n    .replace(/--ESCAPED_PARAM_PLUS/g, '+')\n    .replace(/--ESCAPED_PARAM_COLON/g, ':')\n    .replace(/--ESCAPED_PARAM_QUESTION/g, '?')\n    .replace(/--ESCAPED_PARAM_ASTERISKS/g, '*')\n\n  // the value needs to start with a forward-slash to be compiled\n  // correctly\n  return pathToRegexp\n    .compile(`/${value}`, { validate: false })(params)\n    .substr(1)\n}\n\nexport default function prepareDestination(\n  destination: string,\n  params: Params,\n  query: ParsedUrlQuery,\n  appendParamsToQuery: boolean\n) {\n  // clone query so we don't modify the original\n  query = Object.assign({}, query)\n  const hadLocale = query.__nextLocale\n  delete query.__nextLocale\n  delete query.__nextDefaultLocale\n\n  const parsedDestination = parseUrl(destination)\n  const destQuery = parsedDestination.query\n  const destPath = `${parsedDestination.pathname!}${\n    parsedDestination.hash || ''\n  }`\n  const destPathParamKeys: pathToRegexp.Key[] = []\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys)\n\n  const destPathParams = destPathParamKeys.map((key) => key.name)\n\n  let destinationCompiler = pathToRegexp.compile(\n    destPath,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n  let newUrl\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    if (Array.isArray(strOrArray)) {\n      destQuery[key] = strOrArray.map((value) => compileNonPath(value, params))\n    } else {\n      destQuery[key] = compileNonPath(strOrArray, params)\n    }\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  let paramKeys = Object.keys(params)\n\n  // remove internal param for i18n\n  if (hadLocale) {\n    paramKeys = paramKeys.filter((name) => name !== 'nextInternalLocale')\n  }\n\n  if (\n    appendParamsToQuery &&\n    !paramKeys.some((key) => destPathParams.includes(key))\n  ) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key]\n      }\n    }\n  }\n\n  try {\n    newUrl = destinationCompiler(params)\n\n    const [pathname, hash] = newUrl.split('#')\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    delete (parsedDestination as any).search\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    parsedDestination,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}