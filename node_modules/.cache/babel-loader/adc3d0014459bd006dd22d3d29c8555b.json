{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.batcher = batcher;\nexports.default = void 0;\n\nvar _asyncRetry = _interopRequireDefault(require(\"next/dist/compiled/async-retry\"));\n\nvar _crypto = require(\"crypto\");\n\nvar _nodeFetch = _interopRequireDefault(require(\"node-fetch\"));\n\nvar Log = _interopRequireWildcard(require(\"../../../build/output/log\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nlet traceId;\nlet batch;\nconst localEndpoint = {\n  serviceName: 'nextjs',\n  ipv4: '127.0.0.1',\n  port: 9411\n};\nconst zipkinUrl = `http://${localEndpoint.ipv4}:${localEndpoint.port}`;\nconst zipkinAPI = `${zipkinUrl}/api/v2/spans`;\n\nfunction batcher(reportEvents) {\n  const events = []; // Promise queue to ensure events are always sent on flushAll\n\n  const queue = new Set();\n  return {\n    flushAll: async () => {\n      await Promise.all(queue);\n\n      if (events.length > 0) {\n        await reportEvents(events);\n        events.length = 0;\n      }\n    },\n    report: event => {\n      events.push(event);\n\n      if (events.length > 100) {\n        const evts = events.slice();\n        events.length = 0;\n        const report = reportEvents(evts);\n        queue.add(report);\n        report.then(() => queue.delete(report));\n      }\n    }\n  };\n}\n\nconst reportToLocalHost = (name, duration, timestamp, id, parentId, attrs) => {\n  if (!traceId) {\n    traceId = process.env.TRACE_ID || (0, _crypto).randomBytes(8).toString('hex');\n    Log.info(`Zipkin trace will be available on ${zipkinUrl}/zipkin/traces/${traceId}`);\n  }\n\n  if (!batch) {\n    batch = batcher(events => {\n      // Ensure ECONNRESET error is retried 3 times before erroring out\n      return (0, _asyncRetry).default(() => // Send events to zipkin\n      (0, _nodeFetch).default(zipkinAPI, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(events)\n      }), {\n        minTimeout: 500,\n        retries: 3,\n        factor: 1\n      }).catch(console.log);\n    });\n  }\n\n  batch.report({\n    traceId,\n    parentId,\n    name,\n    id,\n    timestamp,\n    duration,\n    localEndpoint,\n    tags: attrs\n  });\n};\n\nvar _default = {\n  flushAll: () => batch ? batch.flushAll() : undefined,\n  report: reportToLocalHost\n};\nexports.default = _default;","map":{"version":3,"sources":["../../../../telemetry/trace/report/to-zipkin.ts"],"names":[],"mappings":"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","sourcesContent":["import retry from 'next/dist/compiled/async-retry'\nimport { randomBytes } from 'crypto'\nimport fetch from 'node-fetch'\nimport * as Log from '../../../build/output/log'\n\nlet traceId: string\nlet batch: ReturnType<typeof batcher> | undefined\n\nconst localEndpoint = {\n  serviceName: 'nextjs',\n  ipv4: '127.0.0.1',\n  port: 9411,\n}\nconst zipkinUrl = `http://${localEndpoint.ipv4}:${localEndpoint.port}`\nconst zipkinAPI = `${zipkinUrl}/api/v2/spans`\n\ntype Event = {\n  traceId: string\n  parentId?: string\n  name: string\n  id: string\n  timestamp: number\n  duration: number\n  localEndpoint?: typeof localEndpoint\n  tags?: Object\n}\n\n// Batch events as zipkin allows for multiple events to be sent in one go\nexport function batcher(reportEvents: (evts: Event[]) => Promise<void>) {\n  const events: Event[] = []\n  // Promise queue to ensure events are always sent on flushAll\n  const queue = new Set()\n  return {\n    flushAll: async () => {\n      await Promise.all(queue)\n      if (events.length > 0) {\n        await reportEvents(events)\n        events.length = 0\n      }\n    },\n    report: (event: Event) => {\n      events.push(event)\n\n      if (events.length > 100) {\n        const evts = events.slice()\n        events.length = 0\n        const report = reportEvents(evts)\n        queue.add(report)\n        report.then(() => queue.delete(report))\n      }\n    },\n  }\n}\n\nconst reportToLocalHost = (\n  name: string,\n  duration: number,\n  timestamp: number,\n  id: string,\n  parentId?: string,\n  attrs?: Object\n) => {\n  if (!traceId) {\n    traceId = process.env.TRACE_ID || randomBytes(8).toString('hex')\n    Log.info(\n      `Zipkin trace will be available on ${zipkinUrl}/zipkin/traces/${traceId}`\n    )\n  }\n\n  if (!batch) {\n    batch = batcher((events) => {\n      // Ensure ECONNRESET error is retried 3 times before erroring out\n      return retry(\n        () =>\n          // Send events to zipkin\n          fetch(zipkinAPI, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(events),\n          }),\n        { minTimeout: 500, retries: 3, factor: 1 }\n      ).catch(console.log)\n    })\n  }\n\n  batch.report({\n    traceId,\n    parentId,\n    name,\n    id,\n    timestamp,\n    duration,\n    localEndpoint,\n    tags: attrs,\n  })\n}\n\nexport default {\n  flushAll: () => (batch ? batch.flushAll() : undefined),\n  report: reportToLocalHost,\n}\n"]},"metadata":{},"sourceType":"script"}