{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst getWatcherManager = require(\"./getWatcherManager\");\n\nconst LinkResolver = require(\"./LinkResolver\");\n\nconst EventEmitter = require(\"events\").EventEmitter;\n\nconst globToRegExp = require(\"glob-to-regexp\");\n\nconst watchEventSource = require(\"./watchEventSource\");\n\nlet EXISTANCE_ONLY_TIME_ENTRY; // lazy required\n\nconst EMPTY_ARRAY = [];\nconst EMPTY_OPTIONS = {};\n\nfunction addWatchersToSet(watchers, set) {\n  for (const w of watchers) {\n    if (w !== true && !set.has(w.directoryWatcher)) {\n      set.add(w.directoryWatcher);\n      addWatchersToSet(w.directoryWatcher.directories.values(), set);\n    }\n  }\n}\n\nconst stringToRegexp = ignored => {\n  const source = globToRegExp(ignored, {\n    globstar: true,\n    extended: true\n  }).source;\n  const matchingStart = source.slice(0, source.length - 1) + \"(?:$|\\\\/)\";\n  return matchingStart;\n};\n\nconst ignoredToRegexp = ignored => {\n  if (Array.isArray(ignored)) {\n    return new RegExp(ignored.map(i => stringToRegexp(i)).join(\"|\"));\n  } else if (typeof ignored === \"string\") {\n    return new RegExp(stringToRegexp(ignored));\n  } else if (ignored instanceof RegExp) {\n    return ignored;\n  } else if (ignored) {\n    throw new Error(`Invalid option for 'ignored': ${ignored}`);\n  } else {\n    return undefined;\n  }\n};\n\nconst normalizeOptions = options => {\n  return {\n    followSymlinks: !!options.followSymlinks,\n    ignored: ignoredToRegexp(options.ignored),\n    poll: options.poll\n  };\n};\n\nconst normalizeCache = new WeakMap();\n\nconst cachedNormalizeOptions = options => {\n  const cacheEntry = normalizeCache.get(options);\n  if (cacheEntry !== undefined) return cacheEntry;\n  const normalized = normalizeOptions(options);\n  normalizeCache.set(options, normalized);\n  return normalized;\n};\n\nclass Watchpack extends EventEmitter {\n  constructor(options) {\n    super();\n    if (!options) options = EMPTY_OPTIONS;\n    this.options = options;\n    this.aggregateTimeout = typeof options.aggregateTimeout === \"number\" ? options.aggregateTimeout : 200;\n    this.watcherOptions = cachedNormalizeOptions(options);\n    this.watcherManager = getWatcherManager(this.watcherOptions);\n    this.fileWatchers = new Map();\n    this.directoryWatchers = new Map();\n    this.startTime = undefined;\n    this.paused = false;\n    this.aggregatedChanges = new Set();\n    this.aggregatedRemovals = new Set();\n    this.aggregateTimer = undefined;\n    this._onTimeout = this._onTimeout.bind(this);\n  }\n\n  watch(arg1, arg2, arg3) {\n    let files, directories, missing, startTime;\n\n    if (!arg2) {\n      ({\n        files = EMPTY_ARRAY,\n        directories = EMPTY_ARRAY,\n        missing = EMPTY_ARRAY,\n        startTime\n      } = arg1);\n    } else {\n      files = arg1;\n      directories = arg2;\n      missing = EMPTY_ARRAY;\n      startTime = arg3;\n    }\n\n    this.paused = false;\n    const oldFileWatchers = this.fileWatchers;\n    const oldDirectoryWatchers = this.directoryWatchers;\n    const ignored = this.watcherOptions.ignored;\n    const filter = ignored ? path => !ignored.test(path.replace(/\\\\/g, \"/\")) : () => true;\n\n    const addToMap = (map, key, item) => {\n      const list = map.get(key);\n\n      if (list === undefined) {\n        map.set(key, [item]);\n      } else {\n        list.push(item);\n      }\n    };\n\n    const fileWatchersNeeded = new Map();\n    const directoryWatchersNeeded = new Map();\n    const missingFiles = new Set();\n\n    if (this.watcherOptions.followSymlinks) {\n      const resolver = new LinkResolver();\n\n      for (const file of files) {\n        if (filter(file)) {\n          for (const innerFile of resolver.resolve(file)) {\n            if (file === innerFile || filter(innerFile)) {\n              addToMap(fileWatchersNeeded, innerFile, file);\n            }\n          }\n        }\n      }\n\n      for (const file of missing) {\n        if (filter(file)) {\n          for (const innerFile of resolver.resolve(file)) {\n            if (file === innerFile || filter(innerFile)) {\n              missingFiles.add(file);\n              addToMap(fileWatchersNeeded, innerFile, file);\n            }\n          }\n        }\n      }\n\n      for (const dir of directories) {\n        if (filter(dir)) {\n          let first = true;\n\n          for (const innerItem of resolver.resolve(dir)) {\n            if (filter(innerItem)) {\n              addToMap(first ? directoryWatchersNeeded : fileWatchersNeeded, innerItem, dir);\n            }\n\n            first = false;\n          }\n        }\n      }\n    } else {\n      for (const file of files) {\n        if (filter(file)) {\n          addToMap(fileWatchersNeeded, file, file);\n        }\n      }\n\n      for (const file of missing) {\n        if (filter(file)) {\n          missingFiles.add(file);\n          addToMap(fileWatchersNeeded, file, file);\n        }\n      }\n\n      for (const dir of directories) {\n        if (filter(dir)) {\n          addToMap(directoryWatchersNeeded, dir, dir);\n        }\n      }\n    }\n\n    const newFileWatchers = new Map();\n    const newDirectoryWatchers = new Map();\n\n    const setupFileWatcher = (watcher, key, files) => {\n      watcher.on(\"initial-missing\", type => {\n        for (const file of files) {\n          if (!missingFiles.has(file)) this._onRemove(file, file, type);\n        }\n      });\n      watcher.on(\"change\", (mtime, type) => {\n        for (const file of files) {\n          this._onChange(file, mtime, file, type);\n        }\n      });\n      watcher.on(\"remove\", type => {\n        for (const file of files) {\n          this._onRemove(file, file, type);\n        }\n      });\n      newFileWatchers.set(key, watcher);\n    };\n\n    const setupDirectoryWatcher = (watcher, key, directories) => {\n      watcher.on(\"initial-missing\", type => {\n        for (const item of directories) {\n          this._onRemove(item, item, type);\n        }\n      });\n      watcher.on(\"change\", (file, mtime, type) => {\n        for (const item of directories) {\n          this._onChange(item, mtime, file, type);\n        }\n      });\n      watcher.on(\"remove\", type => {\n        for (const item of directories) {\n          this._onRemove(item, item, type);\n        }\n      });\n      newDirectoryWatchers.set(key, watcher);\n    }; // Close unneeded old watchers\n\n\n    const fileWatchersToClose = [];\n    const directoryWatchersToClose = [];\n\n    for (const [key, w] of oldFileWatchers) {\n      if (!fileWatchersNeeded.has(key)) {\n        w.close();\n      } else {\n        fileWatchersToClose.push(w);\n      }\n    }\n\n    for (const [key, w] of oldDirectoryWatchers) {\n      if (!directoryWatchersNeeded.has(key)) {\n        w.close();\n      } else {\n        directoryWatchersToClose.push(w);\n      }\n    } // Create new watchers and install handlers on these watchers\n\n\n    watchEventSource.batch(() => {\n      for (const [key, files] of fileWatchersNeeded) {\n        const watcher = this.watcherManager.watchFile(key, startTime);\n\n        if (watcher) {\n          setupFileWatcher(watcher, key, files);\n        }\n      }\n\n      for (const [key, directories] of directoryWatchersNeeded) {\n        const watcher = this.watcherManager.watchDirectory(key, startTime);\n\n        if (watcher) {\n          setupDirectoryWatcher(watcher, key, directories);\n        }\n      }\n    }); // Close old watchers\n\n    for (const w of fileWatchersToClose) w.close();\n\n    for (const w of directoryWatchersToClose) w.close(); // Store watchers\n\n\n    this.fileWatchers = newFileWatchers;\n    this.directoryWatchers = newDirectoryWatchers;\n    this.startTime = startTime;\n  }\n\n  close() {\n    this.paused = true;\n    if (this.aggregateTimer) clearTimeout(this.aggregateTimer);\n\n    for (const w of this.fileWatchers.values()) w.close();\n\n    for (const w of this.directoryWatchers.values()) w.close();\n\n    this.fileWatchers.clear();\n    this.directoryWatchers.clear();\n  }\n\n  pause() {\n    this.paused = true;\n    if (this.aggregateTimer) clearTimeout(this.aggregateTimer);\n  }\n\n  getTimes() {\n    const directoryWatchers = new Set();\n    addWatchersToSet(this.fileWatchers.values(), directoryWatchers);\n    addWatchersToSet(this.directoryWatchers.values(), directoryWatchers);\n    const obj = Object.create(null);\n\n    for (const w of directoryWatchers) {\n      const times = w.getTimes();\n\n      for (const file of Object.keys(times)) obj[file] = times[file];\n    }\n\n    return obj;\n  }\n\n  getTimeInfoEntries() {\n    if (EXISTANCE_ONLY_TIME_ENTRY === undefined) {\n      EXISTANCE_ONLY_TIME_ENTRY = require(\"./DirectoryWatcher\").EXISTANCE_ONLY_TIME_ENTRY;\n    }\n\n    const directoryWatchers = new Set();\n    addWatchersToSet(this.fileWatchers.values(), directoryWatchers);\n    addWatchersToSet(this.directoryWatchers.values(), directoryWatchers);\n    const map = new Map();\n\n    for (const w of directoryWatchers) {\n      const times = w.getTimeInfoEntries();\n\n      for (const [path, entry] of times) {\n        if (map.has(path)) {\n          if (entry === EXISTANCE_ONLY_TIME_ENTRY) continue;\n          const value = map.get(path);\n          if (value === entry) continue;\n\n          if (value !== EXISTANCE_ONLY_TIME_ENTRY) {\n            map.set(path, Object.assign({}, value, entry));\n            continue;\n          }\n        }\n\n        map.set(path, entry);\n      }\n    }\n\n    return map;\n  }\n\n  _onChange(item, mtime, file, type) {\n    file = file || item;\n    if (this.paused) return;\n    this.emit(\"change\", file, mtime, type);\n    if (this.aggregateTimer) clearTimeout(this.aggregateTimer);\n    this.aggregatedRemovals.delete(item);\n    this.aggregatedChanges.add(item);\n    this.aggregateTimer = setTimeout(this._onTimeout, this.aggregateTimeout);\n  }\n\n  _onRemove(item, file, type) {\n    file = file || item;\n    if (this.paused) return;\n    this.emit(\"remove\", file, type);\n    if (this.aggregateTimer) clearTimeout(this.aggregateTimer);\n    this.aggregatedChanges.delete(item);\n    this.aggregatedRemovals.add(item);\n    this.aggregateTimer = setTimeout(this._onTimeout, this.aggregateTimeout);\n  }\n\n  _onTimeout() {\n    this.aggregateTimer = undefined;\n    const changes = this.aggregatedChanges;\n    const removals = this.aggregatedRemovals;\n    this.aggregatedChanges = new Set();\n    this.aggregatedRemovals = new Set();\n    this.emit(\"aggregated\", changes, removals);\n  }\n\n}\n\nmodule.exports = Watchpack;","map":{"version":3,"sources":["C:/xampp/public_html/vamo/interface2/node_modules/watchpack/lib/watchpack.js"],"names":["getWatcherManager","require","LinkResolver","EventEmitter","globToRegExp","watchEventSource","EXISTANCE_ONLY_TIME_ENTRY","EMPTY_ARRAY","EMPTY_OPTIONS","addWatchersToSet","watchers","set","w","has","directoryWatcher","add","directories","values","stringToRegexp","ignored","source","globstar","extended","matchingStart","slice","length","ignoredToRegexp","Array","isArray","RegExp","map","i","join","Error","undefined","normalizeOptions","options","followSymlinks","poll","normalizeCache","WeakMap","cachedNormalizeOptions","cacheEntry","get","normalized","Watchpack","constructor","aggregateTimeout","watcherOptions","watcherManager","fileWatchers","Map","directoryWatchers","startTime","paused","aggregatedChanges","Set","aggregatedRemovals","aggregateTimer","_onTimeout","bind","watch","arg1","arg2","arg3","files","missing","oldFileWatchers","oldDirectoryWatchers","filter","path","test","replace","addToMap","key","item","list","push","fileWatchersNeeded","directoryWatchersNeeded","missingFiles","resolver","file","innerFile","resolve","dir","first","innerItem","newFileWatchers","newDirectoryWatchers","setupFileWatcher","watcher","on","type","_onRemove","mtime","_onChange","setupDirectoryWatcher","fileWatchersToClose","directoryWatchersToClose","close","batch","watchFile","watchDirectory","clearTimeout","clear","pause","getTimes","obj","Object","create","times","keys","getTimeInfoEntries","entry","value","assign","emit","delete","setTimeout","changes","removals","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst getWatcherManager = require(\"./getWatcherManager\");\nconst LinkResolver = require(\"./LinkResolver\");\nconst EventEmitter = require(\"events\").EventEmitter;\nconst globToRegExp = require(\"glob-to-regexp\");\nconst watchEventSource = require(\"./watchEventSource\");\n\nlet EXISTANCE_ONLY_TIME_ENTRY; // lazy required\n\nconst EMPTY_ARRAY = [];\nconst EMPTY_OPTIONS = {};\n\nfunction addWatchersToSet(watchers, set) {\n\tfor (const w of watchers) {\n\t\tif (w !== true && !set.has(w.directoryWatcher)) {\n\t\t\tset.add(w.directoryWatcher);\n\t\t\taddWatchersToSet(w.directoryWatcher.directories.values(), set);\n\t\t}\n\t}\n}\n\nconst stringToRegexp = ignored => {\n\tconst source = globToRegExp(ignored, { globstar: true, extended: true })\n\t\t.source;\n\tconst matchingStart = source.slice(0, source.length - 1) + \"(?:$|\\\\/)\";\n\treturn matchingStart;\n};\n\nconst ignoredToRegexp = ignored => {\n\tif (Array.isArray(ignored)) {\n\t\treturn new RegExp(ignored.map(i => stringToRegexp(i)).join(\"|\"));\n\t} else if (typeof ignored === \"string\") {\n\t\treturn new RegExp(stringToRegexp(ignored));\n\t} else if (ignored instanceof RegExp) {\n\t\treturn ignored;\n\t} else if (ignored) {\n\t\tthrow new Error(`Invalid option for 'ignored': ${ignored}`);\n\t} else {\n\t\treturn undefined;\n\t}\n};\n\nconst normalizeOptions = options => {\n\treturn {\n\t\tfollowSymlinks: !!options.followSymlinks,\n\t\tignored: ignoredToRegexp(options.ignored),\n\t\tpoll: options.poll\n\t};\n};\n\nconst normalizeCache = new WeakMap();\nconst cachedNormalizeOptions = options => {\n\tconst cacheEntry = normalizeCache.get(options);\n\tif (cacheEntry !== undefined) return cacheEntry;\n\tconst normalized = normalizeOptions(options);\n\tnormalizeCache.set(options, normalized);\n\treturn normalized;\n};\n\nclass Watchpack extends EventEmitter {\n\tconstructor(options) {\n\t\tsuper();\n\t\tif (!options) options = EMPTY_OPTIONS;\n\t\tthis.options = options;\n\t\tthis.aggregateTimeout =\n\t\t\ttypeof options.aggregateTimeout === \"number\"\n\t\t\t\t? options.aggregateTimeout\n\t\t\t\t: 200;\n\t\tthis.watcherOptions = cachedNormalizeOptions(options);\n\t\tthis.watcherManager = getWatcherManager(this.watcherOptions);\n\t\tthis.fileWatchers = new Map();\n\t\tthis.directoryWatchers = new Map();\n\t\tthis.startTime = undefined;\n\t\tthis.paused = false;\n\t\tthis.aggregatedChanges = new Set();\n\t\tthis.aggregatedRemovals = new Set();\n\t\tthis.aggregateTimer = undefined;\n\t\tthis._onTimeout = this._onTimeout.bind(this);\n\t}\n\n\twatch(arg1, arg2, arg3) {\n\t\tlet files, directories, missing, startTime;\n\t\tif (!arg2) {\n\t\t\t({\n\t\t\t\tfiles = EMPTY_ARRAY,\n\t\t\t\tdirectories = EMPTY_ARRAY,\n\t\t\t\tmissing = EMPTY_ARRAY,\n\t\t\t\tstartTime\n\t\t\t} = arg1);\n\t\t} else {\n\t\t\tfiles = arg1;\n\t\t\tdirectories = arg2;\n\t\t\tmissing = EMPTY_ARRAY;\n\t\t\tstartTime = arg3;\n\t\t}\n\t\tthis.paused = false;\n\t\tconst oldFileWatchers = this.fileWatchers;\n\t\tconst oldDirectoryWatchers = this.directoryWatchers;\n\t\tconst ignored = this.watcherOptions.ignored;\n\t\tconst filter = ignored\n\t\t\t? path => !ignored.test(path.replace(/\\\\/g, \"/\"))\n\t\t\t: () => true;\n\t\tconst addToMap = (map, key, item) => {\n\t\t\tconst list = map.get(key);\n\t\t\tif (list === undefined) {\n\t\t\t\tmap.set(key, [item]);\n\t\t\t} else {\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t};\n\t\tconst fileWatchersNeeded = new Map();\n\t\tconst directoryWatchersNeeded = new Map();\n\t\tconst missingFiles = new Set();\n\t\tif (this.watcherOptions.followSymlinks) {\n\t\t\tconst resolver = new LinkResolver();\n\t\t\tfor (const file of files) {\n\t\t\t\tif (filter(file)) {\n\t\t\t\t\tfor (const innerFile of resolver.resolve(file)) {\n\t\t\t\t\t\tif (file === innerFile || filter(innerFile)) {\n\t\t\t\t\t\t\taddToMap(fileWatchersNeeded, innerFile, file);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const file of missing) {\n\t\t\t\tif (filter(file)) {\n\t\t\t\t\tfor (const innerFile of resolver.resolve(file)) {\n\t\t\t\t\t\tif (file === innerFile || filter(innerFile)) {\n\t\t\t\t\t\t\tmissingFiles.add(file);\n\t\t\t\t\t\t\taddToMap(fileWatchersNeeded, innerFile, file);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const dir of directories) {\n\t\t\t\tif (filter(dir)) {\n\t\t\t\t\tlet first = true;\n\t\t\t\t\tfor (const innerItem of resolver.resolve(dir)) {\n\t\t\t\t\t\tif (filter(innerItem)) {\n\t\t\t\t\t\t\taddToMap(\n\t\t\t\t\t\t\t\tfirst ? directoryWatchersNeeded : fileWatchersNeeded,\n\t\t\t\t\t\t\t\tinnerItem,\n\t\t\t\t\t\t\t\tdir\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const file of files) {\n\t\t\t\tif (filter(file)) {\n\t\t\t\t\taddToMap(fileWatchersNeeded, file, file);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const file of missing) {\n\t\t\t\tif (filter(file)) {\n\t\t\t\t\tmissingFiles.add(file);\n\t\t\t\t\taddToMap(fileWatchersNeeded, file, file);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const dir of directories) {\n\t\t\t\tif (filter(dir)) {\n\t\t\t\t\taddToMap(directoryWatchersNeeded, dir, dir);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst newFileWatchers = new Map();\n\t\tconst newDirectoryWatchers = new Map();\n\t\tconst setupFileWatcher = (watcher, key, files) => {\n\t\t\twatcher.on(\"initial-missing\", type => {\n\t\t\t\tfor (const file of files) {\n\t\t\t\t\tif (!missingFiles.has(file)) this._onRemove(file, file, type);\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"change\", (mtime, type) => {\n\t\t\t\tfor (const file of files) {\n\t\t\t\t\tthis._onChange(file, mtime, file, type);\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"remove\", type => {\n\t\t\t\tfor (const file of files) {\n\t\t\t\t\tthis._onRemove(file, file, type);\n\t\t\t\t}\n\t\t\t});\n\t\t\tnewFileWatchers.set(key, watcher);\n\t\t};\n\t\tconst setupDirectoryWatcher = (watcher, key, directories) => {\n\t\t\twatcher.on(\"initial-missing\", type => {\n\t\t\t\tfor (const item of directories) {\n\t\t\t\t\tthis._onRemove(item, item, type);\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"change\", (file, mtime, type) => {\n\t\t\t\tfor (const item of directories) {\n\t\t\t\t\tthis._onChange(item, mtime, file, type);\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"remove\", type => {\n\t\t\t\tfor (const item of directories) {\n\t\t\t\t\tthis._onRemove(item, item, type);\n\t\t\t\t}\n\t\t\t});\n\t\t\tnewDirectoryWatchers.set(key, watcher);\n\t\t};\n\t\t// Close unneeded old watchers\n\t\tconst fileWatchersToClose = [];\n\t\tconst directoryWatchersToClose = [];\n\t\tfor (const [key, w] of oldFileWatchers) {\n\t\t\tif (!fileWatchersNeeded.has(key)) {\n\t\t\t\tw.close();\n\t\t\t} else {\n\t\t\t\tfileWatchersToClose.push(w);\n\t\t\t}\n\t\t}\n\t\tfor (const [key, w] of oldDirectoryWatchers) {\n\t\t\tif (!directoryWatchersNeeded.has(key)) {\n\t\t\t\tw.close();\n\t\t\t} else {\n\t\t\t\tdirectoryWatchersToClose.push(w);\n\t\t\t}\n\t\t}\n\t\t// Create new watchers and install handlers on these watchers\n\t\twatchEventSource.batch(() => {\n\t\t\tfor (const [key, files] of fileWatchersNeeded) {\n\t\t\t\tconst watcher = this.watcherManager.watchFile(key, startTime);\n\t\t\t\tif (watcher) {\n\t\t\t\t\tsetupFileWatcher(watcher, key, files);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const [key, directories] of directoryWatchersNeeded) {\n\t\t\t\tconst watcher = this.watcherManager.watchDirectory(key, startTime);\n\t\t\t\tif (watcher) {\n\t\t\t\t\tsetupDirectoryWatcher(watcher, key, directories);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t// Close old watchers\n\t\tfor (const w of fileWatchersToClose) w.close();\n\t\tfor (const w of directoryWatchersToClose) w.close();\n\t\t// Store watchers\n\t\tthis.fileWatchers = newFileWatchers;\n\t\tthis.directoryWatchers = newDirectoryWatchers;\n\t\tthis.startTime = startTime;\n\t}\n\n\tclose() {\n\t\tthis.paused = true;\n\t\tif (this.aggregateTimer) clearTimeout(this.aggregateTimer);\n\t\tfor (const w of this.fileWatchers.values()) w.close();\n\t\tfor (const w of this.directoryWatchers.values()) w.close();\n\t\tthis.fileWatchers.clear();\n\t\tthis.directoryWatchers.clear();\n\t}\n\n\tpause() {\n\t\tthis.paused = true;\n\t\tif (this.aggregateTimer) clearTimeout(this.aggregateTimer);\n\t}\n\n\tgetTimes() {\n\t\tconst directoryWatchers = new Set();\n\t\taddWatchersToSet(this.fileWatchers.values(), directoryWatchers);\n\t\taddWatchersToSet(this.directoryWatchers.values(), directoryWatchers);\n\t\tconst obj = Object.create(null);\n\t\tfor (const w of directoryWatchers) {\n\t\t\tconst times = w.getTimes();\n\t\t\tfor (const file of Object.keys(times)) obj[file] = times[file];\n\t\t}\n\t\treturn obj;\n\t}\n\n\tgetTimeInfoEntries() {\n\t\tif (EXISTANCE_ONLY_TIME_ENTRY === undefined) {\n\t\t\tEXISTANCE_ONLY_TIME_ENTRY = require(\"./DirectoryWatcher\")\n\t\t\t\t.EXISTANCE_ONLY_TIME_ENTRY;\n\t\t}\n\t\tconst directoryWatchers = new Set();\n\t\taddWatchersToSet(this.fileWatchers.values(), directoryWatchers);\n\t\taddWatchersToSet(this.directoryWatchers.values(), directoryWatchers);\n\t\tconst map = new Map();\n\t\tfor (const w of directoryWatchers) {\n\t\t\tconst times = w.getTimeInfoEntries();\n\t\t\tfor (const [path, entry] of times) {\n\t\t\t\tif (map.has(path)) {\n\t\t\t\t\tif (entry === EXISTANCE_ONLY_TIME_ENTRY) continue;\n\t\t\t\t\tconst value = map.get(path);\n\t\t\t\t\tif (value === entry) continue;\n\t\t\t\t\tif (value !== EXISTANCE_ONLY_TIME_ENTRY) {\n\t\t\t\t\t\tmap.set(path, Object.assign({}, value, entry));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap.set(path, entry);\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\n\t_onChange(item, mtime, file, type) {\n\t\tfile = file || item;\n\t\tif (this.paused) return;\n\t\tthis.emit(\"change\", file, mtime, type);\n\t\tif (this.aggregateTimer) clearTimeout(this.aggregateTimer);\n\t\tthis.aggregatedRemovals.delete(item);\n\t\tthis.aggregatedChanges.add(item);\n\t\tthis.aggregateTimer = setTimeout(this._onTimeout, this.aggregateTimeout);\n\t}\n\n\t_onRemove(item, file, type) {\n\t\tfile = file || item;\n\t\tif (this.paused) return;\n\t\tthis.emit(\"remove\", file, type);\n\t\tif (this.aggregateTimer) clearTimeout(this.aggregateTimer);\n\t\tthis.aggregatedChanges.delete(item);\n\t\tthis.aggregatedRemovals.add(item);\n\t\tthis.aggregateTimer = setTimeout(this._onTimeout, this.aggregateTimeout);\n\t}\n\n\t_onTimeout() {\n\t\tthis.aggregateTimer = undefined;\n\t\tconst changes = this.aggregatedChanges;\n\t\tconst removals = this.aggregatedRemovals;\n\t\tthis.aggregatedChanges = new Set();\n\t\tthis.aggregatedRemovals = new Set();\n\t\tthis.emit(\"aggregated\", changes, removals);\n\t}\n}\n\nmodule.exports = Watchpack;\n"]},"metadata":{},"sourceType":"script"}