{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectPages = collectPages;\nexports.printTreeView = printTreeView;\nexports.printCustomRoutes = printCustomRoutes;\nexports.computeFromManifest = computeFromManifest;\nexports.difference = difference;\nexports.getJsPageSizeInKb = getJsPageSizeInKb;\nexports.buildStaticPaths = buildStaticPaths;\nexports.isPageStatic = isPageStatic;\nexports.hasCustomGetInitialProps = hasCustomGetInitialProps;\nexports.getNamedExports = getNamedExports;\nexports.detectConflictingPaths = detectConflictingPaths;\nexports.getCssFilePaths = getCssFilePaths;\n\nrequire(\"../server/node-polyfill-fetch\");\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _gzipSize = _interopRequireDefault(require(\"next/dist/compiled/gzip-size\"));\n\nvar _textTable = _interopRequireDefault(require(\"next/dist/compiled/text-table\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _fs = require(\"fs\");\n\nvar _reactIs = require(\"react-is\");\n\nvar _stripAnsi = _interopRequireDefault(require(\"next/dist/compiled/strip-ansi\"));\n\nvar _constants = require(\"../lib/constants\");\n\nvar _prettyBytes = _interopRequireDefault(require(\"../lib/pretty-bytes\"));\n\nvar _recursiveReaddir = require(\"../lib/recursive-readdir\");\n\nvar _utils = require(\"../shared/lib/router/utils\");\n\nvar _isDynamic = require(\"../shared/lib/router/utils/is-dynamic\");\n\nvar _escapePathDelimiters = _interopRequireDefault(require(\"../shared/lib/router/utils/escape-path-delimiters\"));\n\nvar _findPageFile = require(\"../server/lib/find-page-file\");\n\nvar _normalizePagePath = require(\"../server/normalize-page-path\");\n\nvar _normalizeTrailingSlash = require(\"../client/normalize-trailing-slash\");\n\nvar _normalizeLocalePath = require(\"../shared/lib/i18n/normalize-locale-path\");\n\nvar Log = _interopRequireWildcard(require(\"./output/log\"));\n\nvar _loadComponents = require(\"../server/load-components\");\n\nvar _trace = require(\"../telemetry/trace\");\n\nvar _config = require(\"../server/config\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nconst fileGzipStats = {};\n\nconst fsStatGzip = file => {\n  const cached = fileGzipStats[file];\n  if (cached) return cached;\n  return fileGzipStats[file] = _gzipSize.default.file(file);\n};\n\nconst fileSize = async file => (await _fs.promises.stat(file)).size;\n\nconst fileStats = {};\n\nconst fsStat = file => {\n  const cached = fileStats[file];\n  if (cached) return cached;\n  return fileStats[file] = fileSize(file);\n};\n\nfunction collectPages(directory, pageExtensions) {\n  return (0, _recursiveReaddir).recursiveReadDir(directory, new RegExp(`\\\\.(?:${pageExtensions.join('|')})$`));\n}\n\nasync function printTreeView(list, pageInfos, serverless, {\n  distPath,\n  buildId,\n  pagesDir,\n  pageExtensions,\n  buildManifest,\n  useStatic404,\n  gzipSize = true\n}) {\n  const getPrettySize = _size => {\n    const size = (0, _prettyBytes).default(_size); // green for 0-130kb\n\n    if (_size < 130 * 1000) return _chalk.default.green(size); // yellow for 130-170kb\n\n    if (_size < 170 * 1000) return _chalk.default.yellow(size); // red for >= 170kb\n\n    return _chalk.default.red.bold(size);\n  };\n\n  const MIN_DURATION = 300;\n\n  const getPrettyDuration = _duration => {\n    const duration = `${_duration} ms`; // green for 300-1000ms\n\n    if (_duration < 1000) return _chalk.default.green(duration); // yellow for 1000-2000ms\n\n    if (_duration < 2000) return _chalk.default.yellow(duration); // red for >= 2000ms\n\n    return _chalk.default.red.bold(duration);\n  };\n\n  const getCleanName = fileName => fileName // Trim off `static/`\n  .replace(/^static\\//, '') // Re-add `static/` for root files\n  .replace(/^<buildId>/, 'static') // Remove file hash\n  .replace(/(?:^|[.-])([0-9a-z]{6})[0-9a-z]{14}(?=\\.)/, '.$1');\n\n  const messages = [['Page', 'Size', 'First Load JS'].map(entry => _chalk.default.underline(entry))];\n  const hasCustomApp = await (0, _findPageFile).findPageFile(pagesDir, '/_app', pageExtensions);\n  pageInfos.set('/404', { ...(pageInfos.get('/404') || pageInfos.get('/_error')),\n    static: useStatic404\n  });\n\n  if (!list.includes('/404')) {\n    list = [...list, '/404'];\n  }\n\n  const sizeData = await computeFromManifest(buildManifest, distPath, gzipSize, pageInfos);\n  const pageList = list.slice().filter(e => !(e === '/_document' || e === '/_error' || !hasCustomApp && e === '/_app')).sort((a, b) => a.localeCompare(b));\n  pageList.forEach((item, i, arr) => {\n    var ref, ref1, ref2;\n    const symbol = i === 0 ? arr.length === 1 ? '─' : '┌' : i === arr.length - 1 ? '└' : '├';\n    const pageInfo = pageInfos.get(item);\n    const ampFirst = buildManifest.ampFirstPages.includes(item);\n    const totalDuration = ((pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.pageDuration) || 0) + ((pageInfo === null || pageInfo === void 0 ? void 0 : (ref = pageInfo.ssgPageDurations) === null || ref === void 0 ? void 0 : ref.reduce((a, b) => a + (b || 0), 0)) || 0);\n    messages.push([`${symbol} ${item === '/_app' ? ' ' : (pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.static) ? '○' : (pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.isSsg) ? '●' : 'λ'} ${(pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.initialRevalidateSeconds) ? `${item} (ISR: ${pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.initialRevalidateSeconds} Seconds)` : item}${totalDuration > MIN_DURATION ? ` (${getPrettyDuration(totalDuration)})` : ''}`, pageInfo ? ampFirst ? _chalk.default.cyan('AMP') : pageInfo.size >= 0 ? (0, _prettyBytes).default(pageInfo.size) : '' : '', pageInfo ? ampFirst ? _chalk.default.cyan('AMP') : pageInfo.size >= 0 ? getPrettySize(pageInfo.totalSize) : '' : '']);\n    const uniqueCssFiles = ((ref1 = buildManifest.pages[item]) === null || ref1 === void 0 ? void 0 : ref1.filter(file => file.endsWith('.css') && sizeData.uniqueFiles.includes(file))) || [];\n\n    if (uniqueCssFiles.length > 0) {\n      const contSymbol = i === arr.length - 1 ? ' ' : '├';\n      uniqueCssFiles.forEach((file, index, {\n        length\n      }) => {\n        const innerSymbol = index === length - 1 ? '└' : '├';\n        messages.push([`${contSymbol}   ${innerSymbol} ${getCleanName(file)}`, (0, _prettyBytes).default(sizeData.sizeUniqueFiles[file]), '']);\n      });\n    }\n\n    if (pageInfo === null || pageInfo === void 0 ? void 0 : (ref2 = pageInfo.ssgPageRoutes) === null || ref2 === void 0 ? void 0 : ref2.length) {\n      const totalRoutes = pageInfo.ssgPageRoutes.length;\n      const contSymbol = i === arr.length - 1 ? ' ' : '├';\n      let routes;\n\n      if (pageInfo.ssgPageDurations && pageInfo.ssgPageDurations.some(d => d > MIN_DURATION)) {\n        const previewPages = totalRoutes === 8 ? 8 : Math.min(totalRoutes, 7);\n        const routesWithDuration = pageInfo.ssgPageRoutes.map((route, idx) => ({\n          route,\n          duration: pageInfo.ssgPageDurations[idx] || 0\n        })).sort(({\n          duration: a\n        }, {\n          duration: b\n        }) => // Sort by duration\n        // keep too small durations in original order at the end\n        a <= MIN_DURATION && b <= MIN_DURATION ? 0 : b - a);\n        routes = routesWithDuration.slice(0, previewPages);\n        const remainingRoutes = routesWithDuration.slice(previewPages);\n\n        if (remainingRoutes.length) {\n          const remaining = remainingRoutes.length;\n          const avgDuration = Math.round(remainingRoutes.reduce((total, {\n            duration\n          }) => total + duration, 0) / remainingRoutes.length);\n          routes.push({\n            route: `[+${remaining} more paths]`,\n            duration: 0,\n            avgDuration\n          });\n        }\n      } else {\n        const previewPages = totalRoutes === 4 ? 4 : Math.min(totalRoutes, 3);\n        routes = pageInfo.ssgPageRoutes.slice(0, previewPages).map(route => ({\n          route,\n          duration: 0\n        }));\n\n        if (totalRoutes > previewPages) {\n          const remaining = totalRoutes - previewPages;\n          routes.push({\n            route: `[+${remaining} more paths]`,\n            duration: 0\n          });\n        }\n      }\n\n      routes.forEach(({\n        route,\n        duration,\n        avgDuration\n      }, index, {\n        length\n      }) => {\n        const innerSymbol = index === length - 1 ? '└' : '├';\n        messages.push([`${contSymbol}   ${innerSymbol} ${route}${duration > MIN_DURATION ? ` (${getPrettyDuration(duration)})` : ''}${avgDuration && avgDuration > MIN_DURATION ? ` (avg ${getPrettyDuration(avgDuration)})` : ''}`, '', '']);\n      });\n    }\n  });\n  const sharedFilesSize = sizeData.sizeCommonFiles;\n  const sharedFiles = sizeData.sizeCommonFile;\n  messages.push(['+ First Load JS shared by all', getPrettySize(sharedFilesSize), '']);\n  const sharedFileKeys = Object.keys(sharedFiles);\n  const sharedCssFiles = [];\n  [...sharedFileKeys.filter(file => {\n    if (file.endsWith('.css')) {\n      sharedCssFiles.push(file);\n      return false;\n    }\n\n    return true;\n  }).map(e => e.replace(buildId, '<buildId>')).sort(), ...sharedCssFiles.map(e => e.replace(buildId, '<buildId>')).sort()].forEach((fileName, index, {\n    length\n  }) => {\n    const innerSymbol = index === length - 1 ? '└' : '├';\n    const originalName = fileName.replace('<buildId>', buildId);\n    const cleanName = getCleanName(fileName);\n    messages.push([`  ${innerSymbol} ${cleanName}`, (0, _prettyBytes).default(sharedFiles[originalName]), '']);\n  });\n  console.log((0, _textTable).default(messages, {\n    align: ['l', 'l', 'r'],\n    stringLength: str => (0, _stripAnsi).default(str).length\n  }));\n  console.log();\n  console.log((0, _textTable).default([['λ', serverless ? '(Lambda)' : '(Server)', `server-side renders at runtime (uses ${_chalk.default.cyan('getInitialProps')} or ${_chalk.default.cyan('getServerSideProps')})`], ['○', '(Static)', 'automatically rendered as static HTML (uses no initial props)'], ['●', '(SSG)', `automatically generated as static HTML + JSON (uses ${_chalk.default.cyan('getStaticProps')})`], ['', '(ISR)', `incremental static regeneration (uses revalidate in ${_chalk.default.cyan('getStaticProps')})`]], {\n    align: ['l', 'l', 'l'],\n    stringLength: str => (0, _stripAnsi).default(str).length\n  }));\n  console.log();\n}\n\nfunction printCustomRoutes({\n  redirects,\n  rewrites,\n  headers\n}) {\n  const printRoutes = (routes, type) => {\n    const isRedirects = type === 'Redirects';\n    const isHeaders = type === 'Headers';\n    console.log(_chalk.default.underline(type));\n    console.log();\n    /*\n    ┌ source\n    ├ permanent/statusCode\n    └ destination\n    */\n\n    const routesStr = routes.map(route => {\n      let routeStr = `┌ source: ${route.source}\\n`;\n\n      if (!isHeaders) {\n        const r = route;\n        routeStr += `${isRedirects ? '├' : '└'} destination: ${r.destination}\\n`;\n      }\n\n      if (isRedirects) {\n        const r = route;\n        routeStr += `└ ${r.statusCode ? `status: ${r.statusCode}` : `permanent: ${r.permanent}`}\\n`;\n      }\n\n      if (isHeaders) {\n        const r = route;\n        routeStr += `└ headers:\\n`;\n\n        for (let i = 0; i < r.headers.length; i++) {\n          const header = r.headers[i];\n          const last = i === headers.length - 1;\n          routeStr += `  ${last ? '└' : '├'} ${header.key}: ${header.value}\\n`;\n        }\n      }\n\n      return routeStr;\n    }).join('\\n');\n    console.log(routesStr, '\\n');\n  };\n\n  if (redirects.length) {\n    printRoutes(redirects, 'Redirects');\n  }\n\n  if (headers.length) {\n    printRoutes(headers, 'Headers');\n  }\n\n  const combinedRewrites = [...rewrites.beforeFiles, ...rewrites.afterFiles, ...rewrites.fallback];\n\n  if (combinedRewrites.length) {\n    printRoutes(combinedRewrites, 'Rewrites');\n  }\n}\n\nlet cachedBuildManifest;\nlet lastCompute;\nlet lastComputePageInfo;\n\nasync function computeFromManifest(manifest, distPath, gzipSize = true, pageInfos) {\n  if (Object.is(cachedBuildManifest, manifest) && lastComputePageInfo === !!pageInfos) {\n    return lastCompute;\n  }\n\n  let expected = 0;\n  const files = new Map();\n  Object.keys(manifest.pages).forEach(key => {\n    if (pageInfos) {\n      const pageInfo = pageInfos.get(key); // don't include AMP pages since they don't rely on shared bundles\n      // AMP First pages are not under the pageInfos key\n\n      if (pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.isHybridAmp) {\n        return;\n      }\n    }\n\n    ++expected;\n    manifest.pages[key].forEach(file => {\n      if (key === '/_app') {\n        files.set(file, Infinity);\n      } else if (files.has(file)) {\n        files.set(file, files.get(file) + 1);\n      } else {\n        files.set(file, 1);\n      }\n    });\n  });\n  const getSize = gzipSize ? fsStatGzip : fsStat;\n  const commonFiles = [...files.entries()].filter(([, len]) => len === expected || len === Infinity).map(([f]) => f);\n  const uniqueFiles = [...files.entries()].filter(([, len]) => len === 1).map(([f]) => f);\n  let stats;\n\n  try {\n    stats = await Promise.all(commonFiles.map(async f => [f, await getSize(_path.default.join(distPath, f))]));\n  } catch (_) {\n    stats = [];\n  }\n\n  let uniqueStats;\n\n  try {\n    uniqueStats = await Promise.all(uniqueFiles.map(async f => [f, await getSize(_path.default.join(distPath, f))]));\n  } catch (_) {\n    uniqueStats = [];\n  }\n\n  lastCompute = {\n    commonFiles,\n    uniqueFiles,\n    sizeUniqueFiles: uniqueStats.reduce((obj, n) => Object.assign(obj, {\n      [n[0]]: n[1]\n    }), {}),\n    sizeCommonFile: stats.reduce((obj, n) => Object.assign(obj, {\n      [n[0]]: n[1]\n    }), {}),\n    sizeCommonFiles: stats.reduce((size, [f, stat]) => {\n      if (f.endsWith('.css')) return size;\n      return size + stat;\n    }, 0)\n  };\n  cachedBuildManifest = manifest;\n  lastComputePageInfo = !!pageInfos;\n  return lastCompute;\n}\n\nfunction difference(main, sub) {\n  const a = new Set(main);\n  const b = new Set(sub);\n  return [...a].filter(x => !b.has(x));\n}\n\nfunction intersect(main, sub) {\n  const a = new Set(main);\n  const b = new Set(sub);\n  return [...new Set([...a].filter(x => b.has(x)))];\n}\n\nfunction sum(a) {\n  return a.reduce((size, stat) => size + stat, 0);\n}\n\nasync function getJsPageSizeInKb(page, distPath, buildManifest, gzipSize = true, computedManifestData) {\n  const data = computedManifestData || (await computeFromManifest(buildManifest, distPath, gzipSize));\n\n  const fnFilterJs = entry => entry.endsWith('.js');\n\n  const pageFiles = (buildManifest.pages[(0, _normalizePagePath).denormalizePagePath(page)] || []).filter(fnFilterJs);\n  const appFiles = (buildManifest.pages['/_app'] || []).filter(fnFilterJs);\n\n  const fnMapRealPath = dep => `${distPath}/${dep}`;\n\n  const allFilesReal = [...new Set([...pageFiles, ...appFiles])].map(fnMapRealPath);\n  const selfFilesReal = difference(intersect(pageFiles, data.uniqueFiles), data.commonFiles).map(fnMapRealPath);\n  const getSize = gzipSize ? fsStatGzip : fsStat;\n\n  try {\n    // Doesn't use `Promise.all`, as we'd double compute duplicate files. This\n    // function is memoized, so the second one will instantly resolve.\n    const allFilesSize = sum(await Promise.all(allFilesReal.map(getSize)));\n    const selfFilesSize = sum(await Promise.all(selfFilesReal.map(getSize)));\n    return [selfFilesSize, allFilesSize];\n  } catch (_) {}\n\n  return [-1, -1];\n}\n\nasync function buildStaticPaths(page, getStaticPaths, locales, defaultLocale) {\n  const prerenderPaths = new Set();\n  const encodedPrerenderPaths = new Set();\n\n  const _routeRegex = (0, _utils).getRouteRegex(page);\n\n  const _routeMatcher = (0, _utils).getRouteMatcher(_routeRegex); // Get the default list of allowed params.\n\n\n  const _validParamKeys = Object.keys(_routeMatcher(page));\n\n  const staticPathsResult = await getStaticPaths({\n    locales,\n    defaultLocale\n  });\n  const expectedReturnVal = `Expected: { paths: [], fallback: boolean }\\n` + `See here for more info: https://nextjs.org/docs/messages/invalid-getstaticpaths-value`;\n\n  if (!staticPathsResult || typeof staticPathsResult !== 'object' || Array.isArray(staticPathsResult)) {\n    throw new Error(`Invalid value returned from getStaticPaths in ${page}. Received ${typeof staticPathsResult} ${expectedReturnVal}`);\n  }\n\n  const invalidStaticPathKeys = Object.keys(staticPathsResult).filter(key => !(key === 'paths' || key === 'fallback'));\n\n  if (invalidStaticPathKeys.length > 0) {\n    throw new Error(`Extra keys returned from getStaticPaths in ${page} (${invalidStaticPathKeys.join(', ')}) ${expectedReturnVal}`);\n  }\n\n  if (!(typeof staticPathsResult.fallback === 'boolean' || staticPathsResult.fallback === 'blocking')) {\n    throw new Error(`The \\`fallback\\` key must be returned from getStaticPaths in ${page}.\\n` + expectedReturnVal);\n  }\n\n  const toPrerender = staticPathsResult.paths;\n\n  if (!Array.isArray(toPrerender)) {\n    throw new Error(`Invalid \\`paths\\` value returned from getStaticPaths in ${page}.\\n` + `\\`paths\\` must be an array of strings or objects of shape { params: [key: string]: string }`);\n  }\n\n  toPrerender.forEach(entry => {\n    // For a string-provided path, we must make sure it matches the dynamic\n    // route.\n    if (typeof entry === 'string') {\n      entry = (0, _normalizeTrailingSlash).removePathTrailingSlash(entry);\n      const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(entry, locales);\n      let cleanedEntry = entry;\n\n      if (localePathResult.detectedLocale) {\n        cleanedEntry = entry.substr(localePathResult.detectedLocale.length + 1);\n      } else if (defaultLocale) {\n        entry = `/${defaultLocale}${entry}`;\n      }\n\n      const result = _routeMatcher(cleanedEntry);\n\n      if (!result) {\n        throw new Error(`The provided path \\`${cleanedEntry}\\` does not match the page: \\`${page}\\`.`);\n      } // If leveraging the string paths variant the entry should already be\n      // encoded so we decode the segments ensuring we only escape path\n      // delimiters\n\n\n      prerenderPaths.add(entry.split('/').map(segment => (0, _escapePathDelimiters).default(decodeURIComponent(segment), true)).join('/'));\n      encodedPrerenderPaths.add(entry);\n    } else {\n      const invalidKeys = Object.keys(entry).filter(key => key !== 'params' && key !== 'locale');\n\n      if (invalidKeys.length) {\n        throw new Error(`Additional keys were returned from \\`getStaticPaths\\` in page \"${page}\". ` + `URL Parameters intended for this dynamic route must be nested under the \\`params\\` key, i.e.:` + `\\n\\n\\treturn { params: { ${_validParamKeys.map(k => `${k}: ...`).join(', ')} } }` + `\\n\\nKeys that need to be moved: ${invalidKeys.join(', ')}.\\n`);\n      }\n\n      const {\n        params = {}\n      } = entry;\n      let builtPage = page;\n      let encodedBuiltPage = page;\n\n      _validParamKeys.forEach(validParamKey => {\n        const {\n          repeat,\n          optional\n        } = _routeRegex.groups[validParamKey];\n        let paramValue = params[validParamKey];\n\n        if (optional && params.hasOwnProperty(validParamKey) && (paramValue === null || paramValue === undefined || paramValue === false)) {\n          paramValue = [];\n        }\n\n        if (repeat && !Array.isArray(paramValue) || !repeat && typeof paramValue !== 'string') {\n          throw new Error(`A required parameter (${validParamKey}) was not provided as ${repeat ? 'an array' : 'a string'} in getStaticPaths for ${page}`);\n        }\n\n        let replaced = `[${repeat ? '...' : ''}${validParamKey}]`;\n\n        if (optional) {\n          replaced = `[${replaced}]`;\n        }\n\n        builtPage = builtPage.replace(replaced, repeat ? paramValue.map(segment => (0, _escapePathDelimiters).default(segment, true)).join('/') : (0, _escapePathDelimiters).default(paramValue, true)).replace(/(?!^)\\/$/, '');\n        encodedBuiltPage = encodedBuiltPage.replace(replaced, repeat ? paramValue.map(encodeURIComponent).join('/') : encodeURIComponent(paramValue)).replace(/(?!^)\\/$/, '');\n      });\n\n      if (entry.locale && !(locales === null || locales === void 0 ? void 0 : locales.includes(entry.locale))) {\n        throw new Error(`Invalid locale returned from getStaticPaths for ${page}, the locale ${entry.locale} is not specified in next.config.js`);\n      }\n\n      const curLocale = entry.locale || defaultLocale || '';\n      prerenderPaths.add(`${curLocale ? `/${curLocale}` : ''}${curLocale && builtPage === '/' ? '' : builtPage}`);\n      encodedPrerenderPaths.add(`${curLocale ? `/${curLocale}` : ''}${curLocale && encodedBuiltPage === '/' ? '' : encodedBuiltPage}`);\n    }\n  });\n  return {\n    paths: [...prerenderPaths],\n    fallback: staticPathsResult.fallback,\n    encodedPaths: [...encodedPrerenderPaths]\n  };\n}\n\nasync function isPageStatic(page, distDir, serverless, runtimeEnvConfig, httpAgentOptions, locales, defaultLocale, parentId) {\n  const isPageStaticSpan = (0, _trace).trace('is-page-static-utils', parentId);\n  return isPageStaticSpan.traceAsyncFn(async () => {\n    try {\n      require('../shared/lib/runtime-config').setConfig(runtimeEnvConfig);\n\n      (0, _config).setHttpAgentOptions(httpAgentOptions);\n      const components = await (0, _loadComponents).loadComponents(distDir, page, serverless);\n      const mod = components.ComponentMod;\n      const Comp = mod.default || mod;\n\n      if (!Comp || !(0, _reactIs).isValidElementType(Comp) || typeof Comp === 'string') {\n        throw new Error('INVALID_DEFAULT_EXPORT');\n      }\n\n      const hasGetInitialProps = !!Comp.getInitialProps;\n      const hasStaticProps = !!(await mod.getStaticProps);\n      const hasStaticPaths = !!(await mod.getStaticPaths);\n      const hasServerProps = !!(await mod.getServerSideProps);\n      const hasLegacyServerProps = !!(await mod.unstable_getServerProps);\n      const hasLegacyStaticProps = !!(await mod.unstable_getStaticProps);\n      const hasLegacyStaticPaths = !!(await mod.unstable_getStaticPaths);\n      const hasLegacyStaticParams = !!(await mod.unstable_getStaticParams);\n\n      if (hasLegacyStaticParams) {\n        throw new Error(`unstable_getStaticParams was replaced with getStaticPaths. Please update your code.`);\n      }\n\n      if (hasLegacyStaticPaths) {\n        throw new Error(`unstable_getStaticPaths was replaced with getStaticPaths. Please update your code.`);\n      }\n\n      if (hasLegacyStaticProps) {\n        throw new Error(`unstable_getStaticProps was replaced with getStaticProps. Please update your code.`);\n      }\n\n      if (hasLegacyServerProps) {\n        throw new Error(`unstable_getServerProps was replaced with getServerSideProps. Please update your code.`);\n      } // A page cannot be prerendered _and_ define a data requirement. That's\n      // contradictory!\n\n\n      if (hasGetInitialProps && hasStaticProps) {\n        throw new Error(_constants.SSG_GET_INITIAL_PROPS_CONFLICT);\n      }\n\n      if (hasGetInitialProps && hasServerProps) {\n        throw new Error(_constants.SERVER_PROPS_GET_INIT_PROPS_CONFLICT);\n      }\n\n      if (hasStaticProps && hasServerProps) {\n        throw new Error(_constants.SERVER_PROPS_SSG_CONFLICT);\n      }\n\n      const pageIsDynamic = (0, _isDynamic).isDynamicRoute(page); // A page cannot have static parameters if it is not a dynamic page.\n\n      if (hasStaticProps && hasStaticPaths && !pageIsDynamic) {\n        throw new Error(`getStaticPaths can only be used with dynamic pages, not '${page}'.` + `\\nLearn more: https://nextjs.org/docs/routing/dynamic-routes`);\n      }\n\n      if (hasStaticProps && pageIsDynamic && !hasStaticPaths) {\n        throw new Error(`getStaticPaths is required for dynamic SSG pages and is missing for '${page}'.` + `\\nRead more: https://nextjs.org/docs/messages/invalid-getstaticpaths-value`);\n      }\n\n      let prerenderRoutes;\n      let encodedPrerenderRoutes;\n      let prerenderFallback;\n\n      if (hasStaticProps && hasStaticPaths) {\n        ({\n          paths: prerenderRoutes,\n          fallback: prerenderFallback,\n          encodedPaths: encodedPrerenderRoutes\n        } = await buildStaticPaths(page, mod.getStaticPaths, locales, defaultLocale));\n      }\n\n      const isNextImageImported = global.__NEXT_IMAGE_IMPORTED;\n      const config = mod.config || {};\n      return {\n        isStatic: !hasStaticProps && !hasGetInitialProps && !hasServerProps,\n        isHybridAmp: config.amp === 'hybrid',\n        isAmpOnly: config.amp === true,\n        prerenderRoutes,\n        prerenderFallback,\n        encodedPrerenderRoutes,\n        hasStaticProps,\n        hasServerProps,\n        isNextImageImported,\n        traceIncludes: config.unstable_includeFiles || [],\n        traceExcludes: config.unstable_excludeFiles || []\n      };\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') return {};\n      throw err;\n    }\n  });\n}\n\nasync function hasCustomGetInitialProps(page, distDir, isLikeServerless, runtimeEnvConfig, checkingApp) {\n  require('../shared/lib/runtime-config').setConfig(runtimeEnvConfig);\n\n  const components = await (0, _loadComponents).loadComponents(distDir, page, isLikeServerless);\n  let mod = components.ComponentMod;\n\n  if (checkingApp) {\n    mod = (await mod._app) || mod.default || mod;\n  } else {\n    mod = mod.default || mod;\n  }\n\n  mod = await mod;\n  return mod.getInitialProps !== mod.origGetInitialProps;\n}\n\nasync function getNamedExports(page, distDir, isLikeServerless, runtimeEnvConfig) {\n  require('../shared/lib/runtime-config').setConfig(runtimeEnvConfig);\n\n  const components = await (0, _loadComponents).loadComponents(distDir, page, isLikeServerless);\n  let mod = components.ComponentMod;\n  return Object.keys(mod);\n}\n\nfunction detectConflictingPaths(combinedPages, ssgPages, additionalSsgPaths) {\n  const conflictingPaths = new Map();\n  const dynamicSsgPages = [...ssgPages].filter(page => (0, _isDynamic).isDynamicRoute(page));\n  additionalSsgPaths.forEach((paths, pathsPage) => {\n    paths.forEach(curPath => {\n      const lowerPath = curPath.toLowerCase();\n      let conflictingPage = combinedPages.find(page => page.toLowerCase() === lowerPath);\n\n      if (conflictingPage) {\n        conflictingPaths.set(lowerPath, [{\n          path: curPath,\n          page: pathsPage\n        }, {\n          path: conflictingPage,\n          page: conflictingPage\n        }]);\n      } else {\n        let conflictingPath;\n        conflictingPage = dynamicSsgPages.find(page => {\n          var ref9;\n          if (page === pathsPage) return false;\n          conflictingPath = (ref9 = additionalSsgPaths.get(page)) === null || ref9 === void 0 ? void 0 : ref9.find(compPath => compPath.toLowerCase() === lowerPath);\n          return conflictingPath;\n        });\n\n        if (conflictingPage && conflictingPath) {\n          conflictingPaths.set(lowerPath, [{\n            path: curPath,\n            page: pathsPage\n          }, {\n            path: conflictingPath,\n            page: conflictingPage\n          }]);\n        }\n      }\n    });\n  });\n\n  if (conflictingPaths.size > 0) {\n    let conflictingPathsOutput = '';\n    conflictingPaths.forEach(pathItems => {\n      pathItems.forEach((pathItem, idx) => {\n        const isDynamic = pathItem.page !== pathItem.path;\n\n        if (idx > 0) {\n          conflictingPathsOutput += 'conflicts with ';\n        }\n\n        conflictingPathsOutput += `path: \"${pathItem.path}\"${isDynamic ? ` from page: \"${pathItem.page}\" ` : ' '}`;\n      });\n      conflictingPathsOutput += '\\n';\n    });\n    Log.error('Conflicting paths returned from getStaticPaths, paths must unique per page.\\n' + 'See more info here: https://nextjs.org/docs/messages/conflicting-ssg-paths\\n\\n' + conflictingPathsOutput);\n    process.exit(1);\n  }\n}\n\nfunction getCssFilePaths(buildManifest) {\n  const cssFiles = new Set();\n  Object.values(buildManifest.pages).forEach(files => {\n    files.forEach(file => {\n      if (file.endsWith('.css')) {\n        cssFiles.add(file);\n      }\n    });\n  });\n  return [...cssFiles];\n}","map":{"version":3,"sources":["../../build/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import '../server/node-polyfill-fetch'\nimport chalk from 'chalk'\nimport getGzipSize from 'next/dist/compiled/gzip-size'\nimport textTable from 'next/dist/compiled/text-table'\nimport path from 'path'\nimport { promises as fs } from 'fs'\nimport { isValidElementType } from 'react-is'\nimport stripAnsi from 'next/dist/compiled/strip-ansi'\nimport {\n  Redirect,\n  Rewrite,\n  Header,\n  CustomRoutes,\n} from '../lib/load-custom-routes'\nimport {\n  SSG_GET_INITIAL_PROPS_CONFLICT,\n  SERVER_PROPS_GET_INIT_PROPS_CONFLICT,\n  SERVER_PROPS_SSG_CONFLICT,\n} from '../lib/constants'\nimport prettyBytes from '../lib/pretty-bytes'\nimport { recursiveReadDir } from '../lib/recursive-readdir'\nimport { getRouteMatcher, getRouteRegex } from '../shared/lib/router/utils'\nimport { isDynamicRoute } from '../shared/lib/router/utils/is-dynamic'\nimport escapePathDelimiters from '../shared/lib/router/utils/escape-path-delimiters'\nimport { findPageFile } from '../server/lib/find-page-file'\nimport { GetStaticPaths, PageConfig } from 'next/types'\nimport { denormalizePagePath } from '../server/normalize-page-path'\nimport { BuildManifest } from '../server/get-page-files'\nimport { removePathTrailingSlash } from '../client/normalize-trailing-slash'\nimport { UnwrapPromise } from '../lib/coalesced-function'\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\nimport * as Log from './output/log'\nimport { loadComponents } from '../server/load-components'\nimport { trace } from '../telemetry/trace'\nimport { setHttpAgentOptions } from '../server/config'\nimport { NextConfigComplete } from '../server/config-shared'\n\nconst fileGzipStats: { [k: string]: Promise<number> | undefined } = {}\nconst fsStatGzip = (file: string) => {\n  const cached = fileGzipStats[file]\n  if (cached) return cached\n  return (fileGzipStats[file] = getGzipSize.file(file))\n}\n\nconst fileSize = async (file: string) => (await fs.stat(file)).size\n\nconst fileStats: { [k: string]: Promise<number> | undefined } = {}\nconst fsStat = (file: string) => {\n  const cached = fileStats[file]\n  if (cached) return cached\n  return (fileStats[file] = fileSize(file))\n}\n\nexport function collectPages(\n  directory: string,\n  pageExtensions: string[]\n): Promise<string[]> {\n  return recursiveReadDir(\n    directory,\n    new RegExp(`\\\\.(?:${pageExtensions.join('|')})$`)\n  )\n}\n\nexport interface PageInfo {\n  isHybridAmp?: boolean\n  size: number\n  totalSize: number\n  static: boolean\n  isSsg: boolean\n  ssgPageRoutes: string[] | null\n  initialRevalidateSeconds: number | false\n  pageDuration: number | undefined\n  ssgPageDurations: number[] | undefined\n}\n\nexport async function printTreeView(\n  list: readonly string[],\n  pageInfos: Map<string, PageInfo>,\n  serverless: boolean,\n  {\n    distPath,\n    buildId,\n    pagesDir,\n    pageExtensions,\n    buildManifest,\n    useStatic404,\n    gzipSize = true,\n  }: {\n    distPath: string\n    buildId: string\n    pagesDir: string\n    pageExtensions: string[]\n    buildManifest: BuildManifest\n    useStatic404: boolean\n    gzipSize?: boolean\n  }\n) {\n  const getPrettySize = (_size: number): string => {\n    const size = prettyBytes(_size)\n    // green for 0-130kb\n    if (_size < 130 * 1000) return chalk.green(size)\n    // yellow for 130-170kb\n    if (_size < 170 * 1000) return chalk.yellow(size)\n    // red for >= 170kb\n    return chalk.red.bold(size)\n  }\n\n  const MIN_DURATION = 300\n  const getPrettyDuration = (_duration: number): string => {\n    const duration = `${_duration} ms`\n    // green for 300-1000ms\n    if (_duration < 1000) return chalk.green(duration)\n    // yellow for 1000-2000ms\n    if (_duration < 2000) return chalk.yellow(duration)\n    // red for >= 2000ms\n    return chalk.red.bold(duration)\n  }\n\n  const getCleanName = (fileName: string) =>\n    fileName\n      // Trim off `static/`\n      .replace(/^static\\//, '')\n      // Re-add `static/` for root files\n      .replace(/^<buildId>/, 'static')\n      // Remove file hash\n      .replace(/(?:^|[.-])([0-9a-z]{6})[0-9a-z]{14}(?=\\.)/, '.$1')\n\n  const messages: [string, string, string][] = [\n    ['Page', 'Size', 'First Load JS'].map((entry) =>\n      chalk.underline(entry)\n    ) as [string, string, string],\n  ]\n\n  const hasCustomApp = await findPageFile(pagesDir, '/_app', pageExtensions)\n\n  pageInfos.set('/404', {\n    ...(pageInfos.get('/404') || pageInfos.get('/_error')),\n    static: useStatic404,\n  } as any)\n\n  if (!list.includes('/404')) {\n    list = [...list, '/404']\n  }\n\n  const sizeData = await computeFromManifest(\n    buildManifest,\n    distPath,\n    gzipSize,\n    pageInfos\n  )\n\n  const pageList = list\n    .slice()\n    .filter(\n      (e) =>\n        !(\n          e === '/_document' ||\n          e === '/_error' ||\n          (!hasCustomApp && e === '/_app')\n        )\n    )\n    .sort((a, b) => a.localeCompare(b))\n\n  pageList.forEach((item, i, arr) => {\n    const symbol =\n      i === 0\n        ? arr.length === 1\n          ? '─'\n          : '┌'\n        : i === arr.length - 1\n        ? '└'\n        : '├'\n\n    const pageInfo = pageInfos.get(item)\n    const ampFirst = buildManifest.ampFirstPages.includes(item)\n\n    const totalDuration =\n      (pageInfo?.pageDuration || 0) +\n      (pageInfo?.ssgPageDurations?.reduce((a, b) => a + (b || 0), 0) || 0)\n\n    messages.push([\n      `${symbol} ${\n        item === '/_app'\n          ? ' '\n          : pageInfo?.static\n          ? '○'\n          : pageInfo?.isSsg\n          ? '●'\n          : 'λ'\n      } ${\n        pageInfo?.initialRevalidateSeconds\n          ? `${item} (ISR: ${pageInfo?.initialRevalidateSeconds} Seconds)`\n          : item\n      }${\n        totalDuration > MIN_DURATION\n          ? ` (${getPrettyDuration(totalDuration)})`\n          : ''\n      }`,\n      pageInfo\n        ? ampFirst\n          ? chalk.cyan('AMP')\n          : pageInfo.size >= 0\n          ? prettyBytes(pageInfo.size)\n          : ''\n        : '',\n      pageInfo\n        ? ampFirst\n          ? chalk.cyan('AMP')\n          : pageInfo.size >= 0\n          ? getPrettySize(pageInfo.totalSize)\n          : ''\n        : '',\n    ])\n\n    const uniqueCssFiles =\n      buildManifest.pages[item]?.filter(\n        (file) => file.endsWith('.css') && sizeData.uniqueFiles.includes(file)\n      ) || []\n\n    if (uniqueCssFiles.length > 0) {\n      const contSymbol = i === arr.length - 1 ? ' ' : '├'\n\n      uniqueCssFiles.forEach((file, index, { length }) => {\n        const innerSymbol = index === length - 1 ? '└' : '├'\n        messages.push([\n          `${contSymbol}   ${innerSymbol} ${getCleanName(file)}`,\n          prettyBytes(sizeData.sizeUniqueFiles[file]),\n          '',\n        ])\n      })\n    }\n\n    if (pageInfo?.ssgPageRoutes?.length) {\n      const totalRoutes = pageInfo.ssgPageRoutes.length\n      const contSymbol = i === arr.length - 1 ? ' ' : '├'\n\n      let routes: { route: string; duration: number; avgDuration?: number }[]\n      if (\n        pageInfo.ssgPageDurations &&\n        pageInfo.ssgPageDurations.some((d) => d > MIN_DURATION)\n      ) {\n        const previewPages = totalRoutes === 8 ? 8 : Math.min(totalRoutes, 7)\n        const routesWithDuration = pageInfo.ssgPageRoutes\n          .map((route, idx) => ({\n            route,\n            duration: pageInfo.ssgPageDurations![idx] || 0,\n          }))\n          .sort(({ duration: a }, { duration: b }) =>\n            // Sort by duration\n            // keep too small durations in original order at the end\n            a <= MIN_DURATION && b <= MIN_DURATION ? 0 : b - a\n          )\n        routes = routesWithDuration.slice(0, previewPages)\n        const remainingRoutes = routesWithDuration.slice(previewPages)\n        if (remainingRoutes.length) {\n          const remaining = remainingRoutes.length\n          const avgDuration = Math.round(\n            remainingRoutes.reduce(\n              (total, { duration }) => total + duration,\n              0\n            ) / remainingRoutes.length\n          )\n          routes.push({\n            route: `[+${remaining} more paths]`,\n            duration: 0,\n            avgDuration,\n          })\n        }\n      } else {\n        const previewPages = totalRoutes === 4 ? 4 : Math.min(totalRoutes, 3)\n        routes = pageInfo.ssgPageRoutes\n          .slice(0, previewPages)\n          .map((route) => ({ route, duration: 0 }))\n        if (totalRoutes > previewPages) {\n          const remaining = totalRoutes - previewPages\n          routes.push({ route: `[+${remaining} more paths]`, duration: 0 })\n        }\n      }\n\n      routes.forEach(({ route, duration, avgDuration }, index, { length }) => {\n        const innerSymbol = index === length - 1 ? '└' : '├'\n        messages.push([\n          `${contSymbol}   ${innerSymbol} ${route}${\n            duration > MIN_DURATION ? ` (${getPrettyDuration(duration)})` : ''\n          }${\n            avgDuration && avgDuration > MIN_DURATION\n              ? ` (avg ${getPrettyDuration(avgDuration)})`\n              : ''\n          }`,\n          '',\n          '',\n        ])\n      })\n    }\n  })\n\n  const sharedFilesSize = sizeData.sizeCommonFiles\n  const sharedFiles = sizeData.sizeCommonFile\n\n  messages.push([\n    '+ First Load JS shared by all',\n    getPrettySize(sharedFilesSize),\n    '',\n  ])\n  const sharedFileKeys = Object.keys(sharedFiles)\n  const sharedCssFiles: string[] = []\n  ;[\n    ...sharedFileKeys\n      .filter((file) => {\n        if (file.endsWith('.css')) {\n          sharedCssFiles.push(file)\n          return false\n        }\n        return true\n      })\n      .map((e) => e.replace(buildId, '<buildId>'))\n      .sort(),\n    ...sharedCssFiles.map((e) => e.replace(buildId, '<buildId>')).sort(),\n  ].forEach((fileName, index, { length }) => {\n    const innerSymbol = index === length - 1 ? '└' : '├'\n\n    const originalName = fileName.replace('<buildId>', buildId)\n    const cleanName = getCleanName(fileName)\n\n    messages.push([\n      `  ${innerSymbol} ${cleanName}`,\n      prettyBytes(sharedFiles[originalName]),\n      '',\n    ])\n  })\n\n  console.log(\n    textTable(messages, {\n      align: ['l', 'l', 'r'],\n      stringLength: (str) => stripAnsi(str).length,\n    })\n  )\n\n  console.log()\n  console.log(\n    textTable(\n      [\n        [\n          'λ',\n          serverless ? '(Lambda)' : '(Server)',\n          `server-side renders at runtime (uses ${chalk.cyan(\n            'getInitialProps'\n          )} or ${chalk.cyan('getServerSideProps')})`,\n        ],\n        [\n          '○',\n          '(Static)',\n          'automatically rendered as static HTML (uses no initial props)',\n        ],\n        [\n          '●',\n          '(SSG)',\n          `automatically generated as static HTML + JSON (uses ${chalk.cyan(\n            'getStaticProps'\n          )})`,\n        ],\n        [\n          '',\n          '(ISR)',\n          `incremental static regeneration (uses revalidate in ${chalk.cyan(\n            'getStaticProps'\n          )})`,\n        ],\n      ] as [string, string, string][],\n      {\n        align: ['l', 'l', 'l'],\n        stringLength: (str) => stripAnsi(str).length,\n      }\n    )\n  )\n\n  console.log()\n}\n\nexport function printCustomRoutes({\n  redirects,\n  rewrites,\n  headers,\n}: CustomRoutes) {\n  const printRoutes = (\n    routes: Redirect[] | Rewrite[] | Header[],\n    type: 'Redirects' | 'Rewrites' | 'Headers'\n  ) => {\n    const isRedirects = type === 'Redirects'\n    const isHeaders = type === 'Headers'\n    console.log(chalk.underline(type))\n    console.log()\n\n    /*\n        ┌ source\n        ├ permanent/statusCode\n        └ destination\n     */\n    const routesStr = (routes as any[])\n      .map((route: { source: string }) => {\n        let routeStr = `┌ source: ${route.source}\\n`\n\n        if (!isHeaders) {\n          const r = route as Rewrite\n          routeStr += `${isRedirects ? '├' : '└'} destination: ${\n            r.destination\n          }\\n`\n        }\n        if (isRedirects) {\n          const r = route as Redirect\n          routeStr += `└ ${\n            r.statusCode\n              ? `status: ${r.statusCode}`\n              : `permanent: ${r.permanent}`\n          }\\n`\n        }\n\n        if (isHeaders) {\n          const r = route as Header\n          routeStr += `└ headers:\\n`\n\n          for (let i = 0; i < r.headers.length; i++) {\n            const header = r.headers[i]\n            const last = i === headers.length - 1\n\n            routeStr += `  ${last ? '└' : '├'} ${header.key}: ${header.value}\\n`\n          }\n        }\n\n        return routeStr\n      })\n      .join('\\n')\n\n    console.log(routesStr, '\\n')\n  }\n\n  if (redirects.length) {\n    printRoutes(redirects, 'Redirects')\n  }\n  if (headers.length) {\n    printRoutes(headers, 'Headers')\n  }\n\n  const combinedRewrites = [\n    ...rewrites.beforeFiles,\n    ...rewrites.afterFiles,\n    ...rewrites.fallback,\n  ]\n  if (combinedRewrites.length) {\n    printRoutes(combinedRewrites, 'Rewrites')\n  }\n}\n\ntype ComputeManifestShape = {\n  commonFiles: string[]\n  uniqueFiles: string[]\n  sizeUniqueFiles: { [file: string]: number }\n  sizeCommonFile: { [file: string]: number }\n  sizeCommonFiles: number\n}\n\nlet cachedBuildManifest: BuildManifest | undefined\n\nlet lastCompute: ComputeManifestShape | undefined\nlet lastComputePageInfo: boolean | undefined\n\nexport async function computeFromManifest(\n  manifest: BuildManifest,\n  distPath: string,\n  gzipSize: boolean = true,\n  pageInfos?: Map<string, PageInfo>\n): Promise<ComputeManifestShape> {\n  if (\n    Object.is(cachedBuildManifest, manifest) &&\n    lastComputePageInfo === !!pageInfos\n  ) {\n    return lastCompute!\n  }\n\n  let expected = 0\n  const files = new Map<string, number>()\n  Object.keys(manifest.pages).forEach((key) => {\n    if (pageInfos) {\n      const pageInfo = pageInfos.get(key)\n      // don't include AMP pages since they don't rely on shared bundles\n      // AMP First pages are not under the pageInfos key\n      if (pageInfo?.isHybridAmp) {\n        return\n      }\n    }\n\n    ++expected\n    manifest.pages[key].forEach((file) => {\n      if (key === '/_app') {\n        files.set(file, Infinity)\n      } else if (files.has(file)) {\n        files.set(file, files.get(file)! + 1)\n      } else {\n        files.set(file, 1)\n      }\n    })\n  })\n\n  const getSize = gzipSize ? fsStatGzip : fsStat\n\n  const commonFiles = [...files.entries()]\n    .filter(([, len]) => len === expected || len === Infinity)\n    .map(([f]) => f)\n  const uniqueFiles = [...files.entries()]\n    .filter(([, len]) => len === 1)\n    .map(([f]) => f)\n\n  let stats: [string, number][]\n  try {\n    stats = await Promise.all(\n      commonFiles.map(\n        async (f) =>\n          [f, await getSize(path.join(distPath, f))] as [string, number]\n      )\n    )\n  } catch (_) {\n    stats = []\n  }\n\n  let uniqueStats: [string, number][]\n  try {\n    uniqueStats = await Promise.all(\n      uniqueFiles.map(\n        async (f) =>\n          [f, await getSize(path.join(distPath, f))] as [string, number]\n      )\n    )\n  } catch (_) {\n    uniqueStats = []\n  }\n\n  lastCompute = {\n    commonFiles,\n    uniqueFiles,\n    sizeUniqueFiles: uniqueStats.reduce(\n      (obj, n) => Object.assign(obj, { [n[0]]: n[1] }),\n      {}\n    ),\n    sizeCommonFile: stats.reduce(\n      (obj, n) => Object.assign(obj, { [n[0]]: n[1] }),\n      {}\n    ),\n    sizeCommonFiles: stats.reduce((size, [f, stat]) => {\n      if (f.endsWith('.css')) return size\n      return size + stat\n    }, 0),\n  }\n\n  cachedBuildManifest = manifest\n  lastComputePageInfo = !!pageInfos\n  return lastCompute!\n}\n\nexport function difference<T>(main: T[] | Set<T>, sub: T[] | Set<T>): T[] {\n  const a = new Set(main)\n  const b = new Set(sub)\n  return [...a].filter((x) => !b.has(x))\n}\n\nfunction intersect<T>(main: T[], sub: T[]): T[] {\n  const a = new Set(main)\n  const b = new Set(sub)\n  return [...new Set([...a].filter((x) => b.has(x)))]\n}\n\nfunction sum(a: number[]): number {\n  return a.reduce((size, stat) => size + stat, 0)\n}\n\nexport async function getJsPageSizeInKb(\n  page: string,\n  distPath: string,\n  buildManifest: BuildManifest,\n  gzipSize: boolean = true,\n  computedManifestData?: ComputeManifestShape\n): Promise<[number, number]> {\n  const data =\n    computedManifestData ||\n    (await computeFromManifest(buildManifest, distPath, gzipSize))\n\n  const fnFilterJs = (entry: string) => entry.endsWith('.js')\n\n  const pageFiles = (\n    buildManifest.pages[denormalizePagePath(page)] || []\n  ).filter(fnFilterJs)\n  const appFiles = (buildManifest.pages['/_app'] || []).filter(fnFilterJs)\n\n  const fnMapRealPath = (dep: string) => `${distPath}/${dep}`\n\n  const allFilesReal = [...new Set([...pageFiles, ...appFiles])].map(\n    fnMapRealPath\n  )\n  const selfFilesReal = difference(\n    intersect(pageFiles, data.uniqueFiles),\n    data.commonFiles\n  ).map(fnMapRealPath)\n\n  const getSize = gzipSize ? fsStatGzip : fsStat\n\n  try {\n    // Doesn't use `Promise.all`, as we'd double compute duplicate files. This\n    // function is memoized, so the second one will instantly resolve.\n    const allFilesSize = sum(await Promise.all(allFilesReal.map(getSize)))\n    const selfFilesSize = sum(await Promise.all(selfFilesReal.map(getSize)))\n\n    return [selfFilesSize, allFilesSize]\n  } catch (_) {}\n  return [-1, -1]\n}\n\nexport async function buildStaticPaths(\n  page: string,\n  getStaticPaths: GetStaticPaths,\n  locales?: string[],\n  defaultLocale?: string\n): Promise<\n  Omit<UnwrapPromise<ReturnType<GetStaticPaths>>, 'paths'> & {\n    paths: string[]\n    encodedPaths: string[]\n  }\n> {\n  const prerenderPaths = new Set<string>()\n  const encodedPrerenderPaths = new Set<string>()\n  const _routeRegex = getRouteRegex(page)\n  const _routeMatcher = getRouteMatcher(_routeRegex)\n\n  // Get the default list of allowed params.\n  const _validParamKeys = Object.keys(_routeMatcher(page))\n\n  const staticPathsResult = await getStaticPaths({ locales, defaultLocale })\n\n  const expectedReturnVal =\n    `Expected: { paths: [], fallback: boolean }\\n` +\n    `See here for more info: https://nextjs.org/docs/messages/invalid-getstaticpaths-value`\n\n  if (\n    !staticPathsResult ||\n    typeof staticPathsResult !== 'object' ||\n    Array.isArray(staticPathsResult)\n  ) {\n    throw new Error(\n      `Invalid value returned from getStaticPaths in ${page}. Received ${typeof staticPathsResult} ${expectedReturnVal}`\n    )\n  }\n\n  const invalidStaticPathKeys = Object.keys(staticPathsResult).filter(\n    (key) => !(key === 'paths' || key === 'fallback')\n  )\n\n  if (invalidStaticPathKeys.length > 0) {\n    throw new Error(\n      `Extra keys returned from getStaticPaths in ${page} (${invalidStaticPathKeys.join(\n        ', '\n      )}) ${expectedReturnVal}`\n    )\n  }\n\n  if (\n    !(\n      typeof staticPathsResult.fallback === 'boolean' ||\n      staticPathsResult.fallback === 'blocking'\n    )\n  ) {\n    throw new Error(\n      `The \\`fallback\\` key must be returned from getStaticPaths in ${page}.\\n` +\n        expectedReturnVal\n    )\n  }\n\n  const toPrerender = staticPathsResult.paths\n\n  if (!Array.isArray(toPrerender)) {\n    throw new Error(\n      `Invalid \\`paths\\` value returned from getStaticPaths in ${page}.\\n` +\n        `\\`paths\\` must be an array of strings or objects of shape { params: [key: string]: string }`\n    )\n  }\n\n  toPrerender.forEach((entry) => {\n    // For a string-provided path, we must make sure it matches the dynamic\n    // route.\n    if (typeof entry === 'string') {\n      entry = removePathTrailingSlash(entry)\n\n      const localePathResult = normalizeLocalePath(entry, locales)\n      let cleanedEntry = entry\n\n      if (localePathResult.detectedLocale) {\n        cleanedEntry = entry.substr(localePathResult.detectedLocale.length + 1)\n      } else if (defaultLocale) {\n        entry = `/${defaultLocale}${entry}`\n      }\n\n      const result = _routeMatcher(cleanedEntry)\n      if (!result) {\n        throw new Error(\n          `The provided path \\`${cleanedEntry}\\` does not match the page: \\`${page}\\`.`\n        )\n      }\n\n      // If leveraging the string paths variant the entry should already be\n      // encoded so we decode the segments ensuring we only escape path\n      // delimiters\n      prerenderPaths.add(\n        entry\n          .split('/')\n          .map((segment) =>\n            escapePathDelimiters(decodeURIComponent(segment), true)\n          )\n          .join('/')\n      )\n      encodedPrerenderPaths.add(entry)\n    }\n    // For the object-provided path, we must make sure it specifies all\n    // required keys.\n    else {\n      const invalidKeys = Object.keys(entry).filter(\n        (key) => key !== 'params' && key !== 'locale'\n      )\n\n      if (invalidKeys.length) {\n        throw new Error(\n          `Additional keys were returned from \\`getStaticPaths\\` in page \"${page}\". ` +\n            `URL Parameters intended for this dynamic route must be nested under the \\`params\\` key, i.e.:` +\n            `\\n\\n\\treturn { params: { ${_validParamKeys\n              .map((k) => `${k}: ...`)\n              .join(', ')} } }` +\n            `\\n\\nKeys that need to be moved: ${invalidKeys.join(', ')}.\\n`\n        )\n      }\n\n      const { params = {} } = entry\n      let builtPage = page\n      let encodedBuiltPage = page\n\n      _validParamKeys.forEach((validParamKey) => {\n        const { repeat, optional } = _routeRegex.groups[validParamKey]\n        let paramValue = params[validParamKey]\n        if (\n          optional &&\n          params.hasOwnProperty(validParamKey) &&\n          (paramValue === null ||\n            paramValue === undefined ||\n            (paramValue as any) === false)\n        ) {\n          paramValue = []\n        }\n        if (\n          (repeat && !Array.isArray(paramValue)) ||\n          (!repeat && typeof paramValue !== 'string')\n        ) {\n          throw new Error(\n            `A required parameter (${validParamKey}) was not provided as ${\n              repeat ? 'an array' : 'a string'\n            } in getStaticPaths for ${page}`\n          )\n        }\n        let replaced = `[${repeat ? '...' : ''}${validParamKey}]`\n        if (optional) {\n          replaced = `[${replaced}]`\n        }\n        builtPage = builtPage\n          .replace(\n            replaced,\n            repeat\n              ? (paramValue as string[])\n                  .map((segment) => escapePathDelimiters(segment, true))\n                  .join('/')\n              : escapePathDelimiters(paramValue as string, true)\n          )\n          .replace(/(?!^)\\/$/, '')\n\n        encodedBuiltPage = encodedBuiltPage\n          .replace(\n            replaced,\n            repeat\n              ? (paramValue as string[]).map(encodeURIComponent).join('/')\n              : encodeURIComponent(paramValue as string)\n          )\n          .replace(/(?!^)\\/$/, '')\n      })\n\n      if (entry.locale && !locales?.includes(entry.locale)) {\n        throw new Error(\n          `Invalid locale returned from getStaticPaths for ${page}, the locale ${entry.locale} is not specified in next.config.js`\n        )\n      }\n      const curLocale = entry.locale || defaultLocale || ''\n\n      prerenderPaths.add(\n        `${curLocale ? `/${curLocale}` : ''}${\n          curLocale && builtPage === '/' ? '' : builtPage\n        }`\n      )\n      encodedPrerenderPaths.add(\n        `${curLocale ? `/${curLocale}` : ''}${\n          curLocale && encodedBuiltPage === '/' ? '' : encodedBuiltPage\n        }`\n      )\n    }\n  })\n\n  return {\n    paths: [...prerenderPaths],\n    fallback: staticPathsResult.fallback,\n    encodedPaths: [...encodedPrerenderPaths],\n  }\n}\n\nexport async function isPageStatic(\n  page: string,\n  distDir: string,\n  serverless: boolean,\n  runtimeEnvConfig: any,\n  httpAgentOptions: NextConfigComplete['httpAgentOptions'],\n  locales?: string[],\n  defaultLocale?: string,\n  parentId?: any\n): Promise<{\n  isStatic?: boolean\n  isAmpOnly?: boolean\n  isHybridAmp?: boolean\n  hasServerProps?: boolean\n  hasStaticProps?: boolean\n  prerenderRoutes?: string[]\n  encodedPrerenderRoutes?: string[]\n  prerenderFallback?: boolean | 'blocking'\n  isNextImageImported?: boolean\n  traceIncludes?: string[]\n  traceExcludes?: string[]\n}> {\n  const isPageStaticSpan = trace('is-page-static-utils', parentId)\n  return isPageStaticSpan.traceAsyncFn(async () => {\n    try {\n      require('../shared/lib/runtime-config').setConfig(runtimeEnvConfig)\n      setHttpAgentOptions(httpAgentOptions)\n      const components = await loadComponents(distDir, page, serverless)\n      const mod = components.ComponentMod\n      const Comp = mod.default || mod\n\n      if (!Comp || !isValidElementType(Comp) || typeof Comp === 'string') {\n        throw new Error('INVALID_DEFAULT_EXPORT')\n      }\n\n      const hasGetInitialProps = !!(Comp as any).getInitialProps\n      const hasStaticProps = !!(await mod.getStaticProps)\n      const hasStaticPaths = !!(await mod.getStaticPaths)\n      const hasServerProps = !!(await mod.getServerSideProps)\n      const hasLegacyServerProps = !!(await mod.unstable_getServerProps)\n      const hasLegacyStaticProps = !!(await mod.unstable_getStaticProps)\n      const hasLegacyStaticPaths = !!(await mod.unstable_getStaticPaths)\n      const hasLegacyStaticParams = !!(await mod.unstable_getStaticParams)\n\n      if (hasLegacyStaticParams) {\n        throw new Error(\n          `unstable_getStaticParams was replaced with getStaticPaths. Please update your code.`\n        )\n      }\n\n      if (hasLegacyStaticPaths) {\n        throw new Error(\n          `unstable_getStaticPaths was replaced with getStaticPaths. Please update your code.`\n        )\n      }\n\n      if (hasLegacyStaticProps) {\n        throw new Error(\n          `unstable_getStaticProps was replaced with getStaticProps. Please update your code.`\n        )\n      }\n\n      if (hasLegacyServerProps) {\n        throw new Error(\n          `unstable_getServerProps was replaced with getServerSideProps. Please update your code.`\n        )\n      }\n\n      // A page cannot be prerendered _and_ define a data requirement. That's\n      // contradictory!\n      if (hasGetInitialProps && hasStaticProps) {\n        throw new Error(SSG_GET_INITIAL_PROPS_CONFLICT)\n      }\n\n      if (hasGetInitialProps && hasServerProps) {\n        throw new Error(SERVER_PROPS_GET_INIT_PROPS_CONFLICT)\n      }\n\n      if (hasStaticProps && hasServerProps) {\n        throw new Error(SERVER_PROPS_SSG_CONFLICT)\n      }\n\n      const pageIsDynamic = isDynamicRoute(page)\n      // A page cannot have static parameters if it is not a dynamic page.\n      if (hasStaticProps && hasStaticPaths && !pageIsDynamic) {\n        throw new Error(\n          `getStaticPaths can only be used with dynamic pages, not '${page}'.` +\n            `\\nLearn more: https://nextjs.org/docs/routing/dynamic-routes`\n        )\n      }\n\n      if (hasStaticProps && pageIsDynamic && !hasStaticPaths) {\n        throw new Error(\n          `getStaticPaths is required for dynamic SSG pages and is missing for '${page}'.` +\n            `\\nRead more: https://nextjs.org/docs/messages/invalid-getstaticpaths-value`\n        )\n      }\n\n      let prerenderRoutes: Array<string> | undefined\n      let encodedPrerenderRoutes: Array<string> | undefined\n      let prerenderFallback: boolean | 'blocking' | undefined\n      if (hasStaticProps && hasStaticPaths) {\n        ;({\n          paths: prerenderRoutes,\n          fallback: prerenderFallback,\n          encodedPaths: encodedPrerenderRoutes,\n        } = await buildStaticPaths(\n          page,\n          mod.getStaticPaths,\n          locales,\n          defaultLocale\n        ))\n      }\n\n      const isNextImageImported = (global as any).__NEXT_IMAGE_IMPORTED\n      const config: PageConfig = mod.config || {}\n      return {\n        isStatic: !hasStaticProps && !hasGetInitialProps && !hasServerProps,\n        isHybridAmp: config.amp === 'hybrid',\n        isAmpOnly: config.amp === true,\n        prerenderRoutes,\n        prerenderFallback,\n        encodedPrerenderRoutes,\n        hasStaticProps,\n        hasServerProps,\n        isNextImageImported,\n        traceIncludes: config.unstable_includeFiles || [],\n        traceExcludes: config.unstable_excludeFiles || [],\n      }\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') return {}\n      throw err\n    }\n  })\n}\n\nexport async function hasCustomGetInitialProps(\n  page: string,\n  distDir: string,\n  isLikeServerless: boolean,\n  runtimeEnvConfig: any,\n  checkingApp: boolean\n): Promise<boolean> {\n  require('../shared/lib/runtime-config').setConfig(runtimeEnvConfig)\n\n  const components = await loadComponents(distDir, page, isLikeServerless)\n  let mod = components.ComponentMod\n\n  if (checkingApp) {\n    mod = (await mod._app) || mod.default || mod\n  } else {\n    mod = mod.default || mod\n  }\n  mod = await mod\n  return mod.getInitialProps !== mod.origGetInitialProps\n}\n\nexport async function getNamedExports(\n  page: string,\n  distDir: string,\n  isLikeServerless: boolean,\n  runtimeEnvConfig: any\n): Promise<Array<string>> {\n  require('../shared/lib/runtime-config').setConfig(runtimeEnvConfig)\n  const components = await loadComponents(distDir, page, isLikeServerless)\n  let mod = components.ComponentMod\n\n  return Object.keys(mod)\n}\n\nexport function detectConflictingPaths(\n  combinedPages: string[],\n  ssgPages: Set<string>,\n  additionalSsgPaths: Map<string, string[]>\n) {\n  const conflictingPaths = new Map<\n    string,\n    Array<{\n      path: string\n      page: string\n    }>\n  >()\n\n  const dynamicSsgPages = [...ssgPages].filter((page) => isDynamicRoute(page))\n\n  additionalSsgPaths.forEach((paths, pathsPage) => {\n    paths.forEach((curPath) => {\n      const lowerPath = curPath.toLowerCase()\n      let conflictingPage = combinedPages.find(\n        (page) => page.toLowerCase() === lowerPath\n      )\n\n      if (conflictingPage) {\n        conflictingPaths.set(lowerPath, [\n          { path: curPath, page: pathsPage },\n          { path: conflictingPage, page: conflictingPage },\n        ])\n      } else {\n        let conflictingPath: string | undefined\n\n        conflictingPage = dynamicSsgPages.find((page) => {\n          if (page === pathsPage) return false\n\n          conflictingPath = additionalSsgPaths\n            .get(page)\n            ?.find((compPath) => compPath.toLowerCase() === lowerPath)\n          return conflictingPath\n        })\n\n        if (conflictingPage && conflictingPath) {\n          conflictingPaths.set(lowerPath, [\n            { path: curPath, page: pathsPage },\n            { path: conflictingPath, page: conflictingPage },\n          ])\n        }\n      }\n    })\n  })\n\n  if (conflictingPaths.size > 0) {\n    let conflictingPathsOutput = ''\n\n    conflictingPaths.forEach((pathItems) => {\n      pathItems.forEach((pathItem, idx) => {\n        const isDynamic = pathItem.page !== pathItem.path\n\n        if (idx > 0) {\n          conflictingPathsOutput += 'conflicts with '\n        }\n\n        conflictingPathsOutput += `path: \"${pathItem.path}\"${\n          isDynamic ? ` from page: \"${pathItem.page}\" ` : ' '\n        }`\n      })\n      conflictingPathsOutput += '\\n'\n    })\n\n    Log.error(\n      'Conflicting paths returned from getStaticPaths, paths must unique per page.\\n' +\n        'See more info here: https://nextjs.org/docs/messages/conflicting-ssg-paths\\n\\n' +\n        conflictingPathsOutput\n    )\n    process.exit(1)\n  }\n}\n\nexport function getCssFilePaths(buildManifest: BuildManifest): string[] {\n  const cssFiles = new Set<string>()\n  Object.values(buildManifest.pages).forEach((files) => {\n    files.forEach((file) => {\n      if (file.endsWith('.css')) {\n        cssFiles.add(file)\n      }\n    })\n  })\n\n  return [...cssFiles]\n}\n"]},"metadata":{},"sourceType":"script"}