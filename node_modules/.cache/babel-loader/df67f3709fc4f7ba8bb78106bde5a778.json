{"ast":null,"code":"'use strict';\n\nconst Hoek = require('@hapi/hoek');\n\nconst Boom = require('@hapi/boom');\n\nconst internals = {};\n\nexports.selection = function (header, preferences, options) {\n  const selections = exports.selections(header, preferences, options);\n  return selections.length ? selections[0] : '';\n};\n\nexports.selections = function (header, preferences, options) {\n  Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');\n  return internals.parse(header || '', preferences, options);\n}; //      RFC 7231 Section 5.3.3 (https://tools.ietf.org/html/rfc7231#section-5.3.3)\n//\n//      Accept-Charset  = *( \",\" OWS ) ( ( charset / \"*\" ) [ weight ] ) *( OWS \",\" [ OWS ( ( charset / \"*\" ) [ weight ] ) ] )\n//      charset         = token\n//\n//      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8\n//      RFC 7231 Section 5.3.4 (https://tools.ietf.org/html/rfc7231#section-5.3.4)\n//\n//      Accept-Encoding = [ ( \",\" / ( codings [ weight ] ) ) *( OWS \",\" [ OWS ( codings [ weight ] ) ] ) ]\n//      codings         = content-coding / \"identity\" / \"*\"\n//      content-coding  = token\n//\n//      Accept-Encoding: compress, gzip\n//      Accept-Encoding:\n//      Accept-Encoding: *\n//      Accept-Encoding: compress;q=0.5, gzip;q=1.0\n//      Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0\n//      RFC 7231 Section 5.3.5 (https://tools.ietf.org/html/rfc7231#section-5.3.5)\n//\n//      Accept-Language = *( \",\" OWS ) ( language-range [ weight ] ) *( OWS \",\" [ OWS ( language-range [ weight ] ) ] )\n//      language-range  = ( 1*8ALPHA *( \"-\" 1*8alphanum ) ) / \"*\"   ; [RFC4647], Section 2.1\n//      alphanum        = ALPHA / DIGIT\n//\n//       Accept-Language: da, en-gb;q=0.8, en;q=0.7\n//      token           = 1*tchar\n//      tchar           = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n//                        / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n//                        / DIGIT / ALPHA\n//                        ; any VCHAR, except delimiters\n//      OWS             = *( SP / HTAB )\n//      RFC 7231 Section 5.3.1 (https://tools.ietf.org/html/rfc7231#section-5.3.1)\n//\n//      The weight is normalized to a real number in the range 0 through 1,\n//      where 0.001 is the least preferred and 1 is the most preferred; a\n//      value of 0 means \"not acceptable\".  If no \"q\" parameter is present,\n//      the default weight is 1.\n//\n//       weight = OWS \";\" OWS \"q=\" qvalue\n//       qvalue = ( \"0\" [ \".\" 0*3DIGIT ] ) / ( \"1\" [ \".\" 0*3(\"0\") ] )\n\n\ninternals.parse = function (raw, preferences, options) {\n  // Normalize header (remove spaces and tabs)\n  const header = raw.replace(/[ \\t]/g, ''); // Normalize preferences\n\n  const lowers = new Map();\n\n  if (preferences) {\n    let pos = 0;\n\n    for (const preference of preferences) {\n      const lower = preference.toLowerCase();\n      lowers.set(lower, {\n        orig: preference,\n        pos: pos++\n      });\n\n      if (options.prefixMatch) {\n        const parts = lower.split('-');\n\n        while (parts.pop(), parts.length > 0) {\n          const joined = parts.join('-');\n\n          if (!lowers.has(joined)) {\n            lowers.set(joined, {\n              orig: preference,\n              pos: pos++\n            });\n          }\n        }\n      }\n    }\n  } // Parse selections\n\n\n  const parts = header.split(',');\n  const selections = [];\n  const map = new Set();\n\n  for (let i = 0; i < parts.length; ++i) {\n    const part = parts[i];\n\n    if (!part) {\n      // Ignore empty parts or leading commas\n      continue;\n    } // Parse parameters\n\n\n    const params = part.split(';');\n\n    if (params.length > 2) {\n      throw Boom.badRequest(`Invalid ${options.type} header`);\n    }\n\n    let token = params[0].toLowerCase();\n\n    if (!token) {\n      throw Boom.badRequest(`Invalid ${options.type} header`);\n    }\n\n    if (options.equivalents && options.equivalents.has(token)) {\n      token = options.equivalents.get(token);\n    }\n\n    const selection = {\n      token,\n      pos: i,\n      q: 1\n    };\n\n    if (preferences && lowers.has(token)) {\n      selection.pref = lowers.get(token).pos;\n    }\n\n    map.add(selection.token); // Parse q=value\n\n    if (params.length === 2) {\n      const q = params[1];\n      const [key, value] = q.split('=');\n\n      if (!value || key !== 'q' && key !== 'Q') {\n        throw Boom.badRequest(`Invalid ${options.type} header`);\n      }\n\n      const score = parseFloat(value);\n\n      if (score === 0) {\n        continue;\n      }\n\n      if (Number.isFinite(score) && score <= 1 && score >= 0.001) {\n        selection.q = score;\n      }\n    }\n\n    selections.push(selection); // Only add allowed selections (q !== 0)\n  } // Sort selection based on q and then position in header\n\n\n  selections.sort(internals.sort); // Extract tokens\n\n  const values = selections.map(selection => selection.token);\n\n  if (options.default && !map.has(options.default)) {\n    values.push(options.default);\n  }\n\n  if (!preferences || !preferences.length) {\n    return values;\n  }\n\n  const preferred = [];\n\n  for (const selection of values) {\n    if (selection === '*') {\n      for (const [preference, value] of lowers) {\n        if (!map.has(preference)) {\n          preferred.push(value.orig);\n        }\n      }\n    } else {\n      const lower = selection.toLowerCase();\n\n      if (lowers.has(lower)) {\n        preferred.push(lowers.get(lower).orig);\n      }\n    }\n  }\n\n  return preferred;\n};\n\ninternals.sort = function (a, b) {\n  const aFirst = -1;\n  const bFirst = 1;\n\n  if (b.q !== a.q) {\n    return b.q - a.q;\n  }\n\n  if (b.pref !== a.pref) {\n    if (a.pref === undefined) {\n      return bFirst;\n    }\n\n    if (b.pref === undefined) {\n      return aFirst;\n    }\n\n    return a.pref - b.pref;\n  }\n\n  return a.pos - b.pos;\n};","map":{"version":3,"sources":["C:/xampp/public_html/vamo/interface2/node_modules/@hapi/accept/lib/header.js"],"names":["Hoek","require","Boom","internals","exports","selection","header","preferences","options","selections","length","assert","Array","isArray","parse","raw","replace","lowers","Map","pos","preference","lower","toLowerCase","set","orig","prefixMatch","parts","split","pop","joined","join","has","map","Set","i","part","params","badRequest","type","token","equivalents","get","q","pref","add","key","value","score","parseFloat","Number","isFinite","push","sort","values","default","preferred","a","b","aFirst","bFirst","undefined"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Hoek = require('@hapi/hoek');\nconst Boom = require('@hapi/boom');\n\n\nconst internals = {};\n\n\nexports.selection = function (header, preferences, options) {\n\n    const selections = exports.selections(header, preferences, options);\n    return selections.length ? selections[0] : '';\n};\n\n\nexports.selections = function (header, preferences, options) {\n\n    Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');\n\n    return internals.parse(header || '', preferences, options);\n};\n\n\n//      RFC 7231 Section 5.3.3 (https://tools.ietf.org/html/rfc7231#section-5.3.3)\n//\n//      Accept-Charset  = *( \",\" OWS ) ( ( charset / \"*\" ) [ weight ] ) *( OWS \",\" [ OWS ( ( charset / \"*\" ) [ weight ] ) ] )\n//      charset         = token\n//\n//      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8\n\n\n//      RFC 7231 Section 5.3.4 (https://tools.ietf.org/html/rfc7231#section-5.3.4)\n//\n//      Accept-Encoding = [ ( \",\" / ( codings [ weight ] ) ) *( OWS \",\" [ OWS ( codings [ weight ] ) ] ) ]\n//      codings         = content-coding / \"identity\" / \"*\"\n//      content-coding  = token\n//\n//      Accept-Encoding: compress, gzip\n//      Accept-Encoding:\n//      Accept-Encoding: *\n//      Accept-Encoding: compress;q=0.5, gzip;q=1.0\n//      Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0\n\n\n//      RFC 7231 Section 5.3.5 (https://tools.ietf.org/html/rfc7231#section-5.3.5)\n//\n//      Accept-Language = *( \",\" OWS ) ( language-range [ weight ] ) *( OWS \",\" [ OWS ( language-range [ weight ] ) ] )\n//      language-range  = ( 1*8ALPHA *( \"-\" 1*8alphanum ) ) / \"*\"   ; [RFC4647], Section 2.1\n//      alphanum        = ALPHA / DIGIT\n//\n//       Accept-Language: da, en-gb;q=0.8, en;q=0.7\n\n\n//      token           = 1*tchar\n//      tchar           = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n//                        / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n//                        / DIGIT / ALPHA\n//                        ; any VCHAR, except delimiters\n//      OWS             = *( SP / HTAB )\n\n\n//      RFC 7231 Section 5.3.1 (https://tools.ietf.org/html/rfc7231#section-5.3.1)\n//\n//      The weight is normalized to a real number in the range 0 through 1,\n//      where 0.001 is the least preferred and 1 is the most preferred; a\n//      value of 0 means \"not acceptable\".  If no \"q\" parameter is present,\n//      the default weight is 1.\n//\n//       weight = OWS \";\" OWS \"q=\" qvalue\n//       qvalue = ( \"0\" [ \".\" 0*3DIGIT ] ) / ( \"1\" [ \".\" 0*3(\"0\") ] )\n\n\ninternals.parse = function (raw, preferences, options) {\n\n    // Normalize header (remove spaces and tabs)\n\n    const header = raw.replace(/[ \\t]/g, '');\n\n    // Normalize preferences\n\n    const lowers = new Map();\n    if (preferences) {\n        let pos = 0;\n        for (const preference of preferences) {\n            const lower = preference.toLowerCase();\n            lowers.set(lower, { orig: preference, pos: pos++ });\n\n            if (options.prefixMatch) {\n                const parts = lower.split('-');\n                while (parts.pop(), parts.length > 0) {\n                    const joined = parts.join('-');\n                    if (!lowers.has(joined)) {\n                        lowers.set(joined, { orig: preference, pos: pos++ });\n                    }\n                }\n            }\n        }\n    }\n\n    // Parse selections\n\n    const parts = header.split(',');\n    const selections = [];\n    const map = new Set();\n\n    for (let i = 0; i < parts.length; ++i) {\n        const part = parts[i];\n        if (!part) {                            // Ignore empty parts or leading commas\n            continue;\n        }\n\n        // Parse parameters\n\n        const params = part.split(';');\n        if (params.length > 2) {\n            throw Boom.badRequest(`Invalid ${options.type} header`);\n        }\n\n        let token = params[0].toLowerCase();\n        if (!token) {\n            throw Boom.badRequest(`Invalid ${options.type} header`);\n        }\n\n        if (options.equivalents &&\n            options.equivalents.has(token)) {\n\n            token = options.equivalents.get(token);\n        }\n\n        const selection = {\n            token,\n            pos: i,\n            q: 1\n        };\n\n        if (preferences &&\n            lowers.has(token)) {\n\n            selection.pref = lowers.get(token).pos;\n        }\n\n        map.add(selection.token);\n\n        // Parse q=value\n\n        if (params.length === 2) {\n            const q = params[1];\n            const [key, value] = q.split('=');\n\n            if (!value ||\n                key !== 'q' && key !== 'Q') {\n\n                throw Boom.badRequest(`Invalid ${options.type} header`);\n            }\n\n            const score = parseFloat(value);\n            if (score === 0) {\n                continue;\n            }\n\n            if (Number.isFinite(score) &&\n                score <= 1 &&\n                score >= 0.001) {\n\n                selection.q = score;\n            }\n        }\n\n        selections.push(selection);             // Only add allowed selections (q !== 0)\n    }\n\n    // Sort selection based on q and then position in header\n\n    selections.sort(internals.sort);\n\n    // Extract tokens\n\n    const values = selections.map((selection) => selection.token);\n\n    if (options.default &&\n        !map.has(options.default)) {\n\n        values.push(options.default);\n    }\n\n    if (!preferences ||\n        !preferences.length) {\n\n        return values;\n    }\n\n    const preferred = [];\n    for (const selection of values) {\n        if (selection === '*') {\n            for (const [preference, value] of lowers) {\n                if (!map.has(preference)) {\n                    preferred.push(value.orig);\n                }\n            }\n        }\n        else {\n            const lower = selection.toLowerCase();\n            if (lowers.has(lower)) {\n                preferred.push(lowers.get(lower).orig);\n            }\n        }\n    }\n\n    return preferred;\n};\n\n\ninternals.sort = function (a, b) {\n\n    const aFirst = -1;\n    const bFirst = 1;\n\n    if (b.q !== a.q) {\n        return b.q - a.q;\n    }\n\n    if (b.pref !== a.pref) {\n        if (a.pref === undefined) {\n            return bFirst;\n        }\n\n        if (b.pref === undefined) {\n            return aFirst;\n        }\n\n        return a.pref - b.pref;\n    }\n\n    return a.pos - b.pos;\n};\n"]},"metadata":{},"sourceType":"script"}