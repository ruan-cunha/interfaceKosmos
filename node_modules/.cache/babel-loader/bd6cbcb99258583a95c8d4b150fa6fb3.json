{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = require(\"crypto\");\n\nvar _toZipkin = require(\"./to-zipkin\");\n\nvar _shared = require(\"../shared\");\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nlet writeStream;\nlet traceId;\nlet batch;\n\nconst reportToLocalHost = (name, duration, timestamp, id, parentId, attrs) => {\n  const distDir = _shared.traceGlobals.get('distDir');\n\n  if (!distDir) {\n    return;\n  }\n\n  if (!traceId) {\n    traceId = process.env.TRACE_ID || (0, _crypto).randomBytes(8).toString('hex');\n  }\n\n  if (!batch) {\n    batch = (0, _toZipkin).batcher(async events => {\n      if (!writeStream) {\n        const tracesDir = _path.default.join(distDir, 'traces');\n\n        await _fs.default.promises.mkdir(tracesDir, {\n          recursive: true\n        });\n\n        const file = _path.default.join(distDir, 'trace');\n\n        writeStream = _fs.default.createWriteStream(file, {\n          flags: 'a',\n          encoding: 'utf8'\n        });\n      }\n\n      const eventsJson = JSON.stringify(events);\n\n      try {\n        await new Promise((resolve, reject) => {\n          writeStream.write(eventsJson + '\\n', 'utf8', err => {\n            err ? reject(err) : resolve();\n          });\n        });\n      } catch (err) {\n        console.log(err);\n      }\n    });\n  }\n\n  batch.report({\n    traceId,\n    parentId,\n    name,\n    id,\n    timestamp,\n    duration,\n    tags: attrs\n  });\n};\n\nvar _default = {\n  flushAll: () => batch ? batch.flushAll().then(() => {\n    writeStream.end('', 'utf8');\n  }) : undefined,\n  report: reportToLocalHost\n};\nexports.default = _default;","map":{"version":3,"sources":["../../../../telemetry/trace/report/to-json.ts"],"names":[],"mappings":";;;;;;;AAA4B,IAAA,OAAQ,GAAA,OAAA,CAAA,QAAA,CAAR;;AACJ,IAAA,SAAa,GAAA,OAAA,CAAA,aAAA,CAAb;;AACK,IAAA,OAAW,GAAA,OAAA,CAAA,WAAA,CAAX;;AACd,IAAA,GAAI,GAAA,sBAAA,CAAA,OAAA,CAAA,IAAA,CAAA,CAAJ;;AACE,IAAA,KAAM,GAAA,sBAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAN;;;;;;;;AAEjB,IAAI,WAAJ;AACA,IAAI,OAAJ;AACA,IAAI,KAAJ;;AAEA,MAAM,iBAAiB,GAAA,CACrB,IADqB,EAErB,QAFqB,EAGrB,SAHqB,EAIrB,EAJqB,EAKrB,QALqB,EAMrB,KANqB,KAOlB;AACH,QAAM,OAAO,GAhBc,OAAW,CAAA,YAAX,CAgBE,GAhBF,CAgBK,SAhBL,CAgB3B;;AACA,MAAE,CAAG,OAAL,EAAc;;AAEb;;AAED,MAAE,CAAG,OAAL,EAAc;AACZ,IAAA,OAAO,GAAG,OAAO,CAAC,GAAR,CAAY,QAAZ,IAAoB,CAAA,GAxBN,OAwBM,EAxBE,WAwBF,CAAgB,CAAhB,EAAmB,QAAnB,CAA2B,KAA3B,CAA9B;AACD;;AAED,MAAE,CAAG,KAAL,EAAY;AACV,IAAA,KAAK,GAAA,CAAA,GA3Be,SA2Bf,EA3B4B,OA2B5B,CA3B4B,MA2BV,MA3BU,IA2BC;AAChC,UAAE,CAAG,WAAL,EAAkB;AAChB,cAAM,SAAS,GA1BN,KAAM,CAAA,OAAN,CA0Bc,IA1Bd,CA0BmB,OA1BnB,EA0B0B,QA1B1B,CA0BT;;cA3BO,GAAI,CAAA,OAAJ,CA4BE,QA5BF,CA4BW,KA5BX,CA4BiB,SA5BjB,EA4B0B;AAAI,UAAA,SAAS,EAAE;AAAf,SA5B1B,C;;AA6BP,cAAM,IAAI,GA5BD,KAAM,CAAA,OAAN,CA4BS,IA5BT,CA4Bc,OA5Bd,EA4BqB,OA5BrB,CA4BT;;AACA,QAAA,WAAW,GA9BJ,GAAI,CAAA,OAAJ,CA8BU,iBA9BV,CA8B4B,IA9B5B,EA8BgC;AACrC,UAAA,KAAK,EAAA,GADgC;AAErC,UAAA,QAAQ,EAAA;AAF6B,SA9BhC,CA8BP;AAID;;AACD,YAAM,UAAU,GAAG,IAAI,CAAC,SAAL,CAAe,MAAf,CAAnB;;UACI;cACI,IAAI,OAAJ,CAAW,CAAQ,OAAR,EAAiB,MAAjB,KAA4B;AAC3C,UAAA,WAAW,CAAC,KAAZ,CAAkB,UAAU,GAAA,IAA5B,EAAmC,MAAnC,EAA8C,GAAH,IAAW;AACpD,YAAA,GAAG,GAAG,MAAM,CAAC,GAAD,CAAT,GAAiB,OAAO,EAA3B;AACD,WAFD;AAGD,SAJK,C;AAKP,O,CAAA,OAAQ,GAAR,EAAa;AACZ,QAAA,OAAO,CAAC,GAAR,CAAY,GAAZ;AACD;AACF,KApBI,CAAL;AAqBD;;AAED,EAAA,KAAK,CAAC,MAAN,CAAY;AACV,IAAA,OADU;AAEV,IAAA,QAFU;AAGV,IAAA,IAHU;AAIV,IAAA,EAJU;AAKV,IAAA,SALU;AAMV,IAAA,QANU;AAOV,IAAA,IAAI,EAAE;AAPI,GAAZ;AASD,CAlDD;;;AAqDE,EAAA,QAAQ,EAAA,MACN,KAAK,GACD,KAAK,CAAC,QAAN,GAAiB,IAAjB,CAAqB,MAAO;AAC1B,IAAA,WAAW,CAAC,GAAZ,CAAe,EAAf,EAAe,MAAf;AACD,GAFD,CADC,GAID,S;AACN,EAAA,MAAM,EAAE","sourcesContent":["import { randomBytes } from 'crypto'\nimport { batcher } from './to-zipkin'\nimport { traceGlobals } from '../shared'\nimport fs from 'fs'\nimport path from 'path'\n\nlet writeStream: fs.WriteStream\nlet traceId: string\nlet batch: ReturnType<typeof batcher> | undefined\n\nconst reportToLocalHost = (\n  name: string,\n  duration: number,\n  timestamp: number,\n  id: string,\n  parentId?: string,\n  attrs?: Object\n) => {\n  const distDir = traceGlobals.get('distDir')\n  if (!distDir) {\n    return\n  }\n\n  if (!traceId) {\n    traceId = process.env.TRACE_ID || randomBytes(8).toString('hex')\n  }\n\n  if (!batch) {\n    batch = batcher(async (events) => {\n      if (!writeStream) {\n        const tracesDir = path.join(distDir, 'traces')\n        await fs.promises.mkdir(tracesDir, { recursive: true })\n        const file = path.join(distDir, 'trace')\n        writeStream = fs.createWriteStream(file, {\n          flags: 'a',\n          encoding: 'utf8',\n        })\n      }\n      const eventsJson = JSON.stringify(events)\n      try {\n        await new Promise<void>((resolve, reject) => {\n          writeStream.write(eventsJson + '\\n', 'utf8', (err) => {\n            err ? reject(err) : resolve()\n          })\n        })\n      } catch (err) {\n        console.log(err)\n      }\n    })\n  }\n\n  batch.report({\n    traceId,\n    parentId,\n    name,\n    id,\n    timestamp,\n    duration,\n    tags: attrs,\n  })\n}\n\nexport default {\n  flushAll: () =>\n    batch\n      ? batch.flushAll().then(() => {\n          writeStream.end('', 'utf8')\n        })\n      : undefined,\n  report: reportToLocalHost,\n}\n"]},"metadata":{},"sourceType":"script"}