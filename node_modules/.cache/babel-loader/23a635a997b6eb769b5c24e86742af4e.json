{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.store = void 0;\n\nvar _unistore = _interopRequireDefault(require(\"next/dist/compiled/unistore\"));\n\nvar _stripAnsi = _interopRequireDefault(require(\"next/dist/compiled/strip-ansi\"));\n\nvar Log = _interopRequireWildcard(require(\"./log\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nconst store = (0, _unistore).default({\n  appUrl: null,\n  bindAddr: null,\n  bootstrap: true\n});\nexports.store = store;\nlet lastStore = {\n  appUrl: null,\n  bindAddr: null,\n  bootstrap: true\n};\n\nfunction hasStoreChanged(nextStore) {\n  if ([...new Set([...Object.keys(lastStore), ...Object.keys(nextStore)])].every(key => Object.is(lastStore[key], nextStore[key]))) {\n    return false;\n  }\n\n  lastStore = nextStore;\n  return true;\n}\n\nstore.subscribe(state => {\n  if (!hasStoreChanged(state)) {\n    return;\n  }\n\n  if (state.bootstrap) {\n    if (state.appUrl) {\n      Log.ready(`started server on ${state.bindAddr}, url: ${state.appUrl}`);\n    }\n\n    return;\n  }\n\n  if (state.loading) {\n    Log.wait('compiling...');\n    return;\n  }\n\n  if (state.errors) {\n    Log.error(state.errors[0]);\n    const cleanError = (0, _stripAnsi).default(state.errors[0]);\n\n    if (cleanError.indexOf('SyntaxError') > -1) {\n      const matches = cleanError.match(/\\[.*\\]=/);\n\n      if (matches) {\n        for (const match of matches) {\n          const prop = (match.split(']').shift() || '').substr(1);\n          console.log(`AMP bind syntax [${prop}]='' is not supported in JSX, use 'data-amp-bind-${prop}' instead. https://nextjs.org/docs/messages/amp-bind-jsx-alt`);\n        }\n\n        return;\n      }\n    }\n\n    return;\n  }\n\n  if (state.warnings) {\n    Log.warn(state.warnings.join('\\n\\n'));\n\n    if (state.appUrl) {\n      Log.info(`ready on ${state.appUrl}`);\n    }\n\n    return;\n  }\n\n  if (state.typeChecking) {\n    Log.info('bundled successfully, waiting for typecheck results...');\n    return;\n  }\n\n  Log.event('compiled successfully');\n});","map":{"version":3,"sources":["../../../build/output/store.ts"],"names":[],"mappings":"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","sourcesContent":["import createStore from 'next/dist/compiled/unistore'\nimport stripAnsi from 'next/dist/compiled/strip-ansi'\n\nimport * as Log from './log'\n\nexport type OutputState =\n  | { bootstrap: true; appUrl: string | null; bindAddr: string | null }\n  | ({ bootstrap: false; appUrl: string | null; bindAddr: string | null } & (\n      | { loading: true }\n      | {\n          loading: false\n          typeChecking: boolean\n          errors: string[] | null\n          warnings: string[] | null\n        }\n    ))\n\nexport const store = createStore<OutputState>({\n  appUrl: null,\n  bindAddr: null,\n  bootstrap: true,\n})\n\nlet lastStore: OutputState = { appUrl: null, bindAddr: null, bootstrap: true }\nfunction hasStoreChanged(nextStore: OutputState) {\n  if (\n    (\n      [\n        ...new Set([...Object.keys(lastStore), ...Object.keys(nextStore)]),\n      ] as Array<keyof OutputState>\n    ).every((key) => Object.is(lastStore[key], nextStore[key]))\n  ) {\n    return false\n  }\n\n  lastStore = nextStore\n  return true\n}\n\nstore.subscribe((state) => {\n  if (!hasStoreChanged(state)) {\n    return\n  }\n\n  if (state.bootstrap) {\n    if (state.appUrl) {\n      Log.ready(`started server on ${state.bindAddr}, url: ${state.appUrl}`)\n    }\n    return\n  }\n\n  if (state.loading) {\n    Log.wait('compiling...')\n    return\n  }\n\n  if (state.errors) {\n    Log.error(state.errors[0])\n\n    const cleanError = stripAnsi(state.errors[0])\n    if (cleanError.indexOf('SyntaxError') > -1) {\n      const matches = cleanError.match(/\\[.*\\]=/)\n      if (matches) {\n        for (const match of matches) {\n          const prop = (match.split(']').shift() || '').substr(1)\n          console.log(\n            `AMP bind syntax [${prop}]='' is not supported in JSX, use 'data-amp-bind-${prop}' instead. https://nextjs.org/docs/messages/amp-bind-jsx-alt`\n          )\n        }\n        return\n      }\n    }\n\n    return\n  }\n\n  if (state.warnings) {\n    Log.warn(state.warnings.join('\\n\\n'))\n    if (state.appUrl) {\n      Log.info(`ready on ${state.appUrl}`)\n    }\n    return\n  }\n\n  if (state.typeChecking) {\n    Log.info('bundled successfully, waiting for typecheck results...')\n    return\n  }\n\n  Log.event('compiled successfully')\n})\n"]},"metadata":{},"sourceType":"script"}