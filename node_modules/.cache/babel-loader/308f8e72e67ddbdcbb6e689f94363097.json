{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pathToRegexp = exports.customRouteMatcherOptions = exports.default = exports.matcherOptions = void 0;\n\nvar pathToRegexp = _interopRequireWildcard(require(\"next/dist/compiled/path-to-regexp\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nexports.pathToRegexp = pathToRegexp;\nconst matcherOptions = {\n  sensitive: false,\n  delimiter: '/'\n};\nexports.matcherOptions = matcherOptions;\nconst customRouteMatcherOptions = { ...matcherOptions,\n  strict: true\n};\nexports.customRouteMatcherOptions = customRouteMatcherOptions;\n\nvar _default = (customRoute = false) => {\n  return (path, regexModifier) => {\n    const keys = [];\n    let matcherRegex = pathToRegexp.pathToRegexp(path, keys, customRoute ? customRouteMatcherOptions : matcherOptions);\n\n    if (regexModifier) {\n      const regexSource = regexModifier(matcherRegex.source);\n      matcherRegex = new RegExp(regexSource, matcherRegex.flags);\n    }\n\n    const matcher = pathToRegexp.regexpToFunction(matcherRegex, keys);\n    return (pathname, params) => {\n      const res = pathname == null ? false : matcher(pathname);\n\n      if (!res) {\n        return false;\n      }\n\n      if (customRoute) {\n        for (const key of keys) {\n          // unnamed params should be removed as they\n          // are not allowed to be used in the destination\n          if (typeof key.name === 'number') {\n            delete res.params[key.name];\n          }\n        }\n      }\n\n      return { ...params,\n        ...res.params\n      };\n    };\n  };\n};\n\nexports.default = _default;","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/path-match.ts"],"names":[],"mappings":";;;;;;;AAAY,IAAA,YAAY,GAAA,uBAAA,CAAA,OAAA,CAAA,mCAAA,CAAA,CAAZ;;;;;;;;;;;;;;;;;;;;;;;;;;;QAEH,Y,GAFG,Y;AAIL,MAAM,cAAc,GAAA;AAEzB,EAAA,SAAS,EAAE,KAFc;AAGzB,EAAA,SAAS,EAAA;AAHgB,CAApB;QAAM,c,GAAA,c;AAMN,MAAM,yBAAyB,GAAA,E,GAEjC,cAFiC;AAGpC,EAAA,MAAM,EAAE;AAH4B,CAA/B;QAAM,yB,GAAA,yB;;gBAMG,WAAW,GAAG,K,KAAU;UAC9B,I,EAAc,a,KAA8C;AAClE,UAAM,IAAI,GAAA,EAAV;AACA,QAAI,YAAY,GAnBR,YAAY,CAmBY,YAnBxB,CAoBN,IApBM,EAqBN,IArBM,EAsBN,WAAW,GAAG,yBAAH,GAA+B,cAtBpC,CAmBR;;AAMA,QAAI,aAAJ,EAAmB;AACjB,YAAM,WAAW,GAAG,aAAa,CAAC,YAAY,CAAC,MAAd,CAAjC;AACA,MAAA,YAAY,GAAG,IAAI,MAAJ,CAAW,WAAX,EAAwB,YAAY,CAAC,KAArC,CAAf;AACD;;AAED,UAAM,OAAO,GA9BL,YAAY,CA8BS,gBA9BrB,CA8BsC,YA9BtC,EA8BoD,IA9BpD,CA8BR;YAEQ,Q,EAAqC,M,KAAiB;AAC5D,YAAM,GAAG,GAAG,QAAQ,IAAI,IAAZ,GAAmB,KAAnB,GAA2B,OAAO,CAAC,QAAD,CAA9C;;AACA,UAAE,CAAG,GAAL,EAAU;eACD,K;AACR;;AAED,UAAI,WAAJ,EAAiB;aACV,MAAM,G,IAAO,I,EAAM;AACtB;AACA;AACA,cAAE,OAAS,GAAG,CAAC,IAAb,KAAiB,QAAnB,EAAkC;mBACxB,GAAG,CAAC,MAAJ,CAAmB,GAAG,CAAC,IAAvB,C;AACT;AACF;AACF;;kBAEW,M;WAAW,GAAG,CAAC;;AAC5B,K;AACF,G;AACF,C","sourcesContent":["import * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\n\nexport { pathToRegexp }\n\nexport const matcherOptions: pathToRegexp.TokensToRegexpOptions &\n  pathToRegexp.ParseOptions = {\n  sensitive: false,\n  delimiter: '/',\n}\n\nexport const customRouteMatcherOptions: pathToRegexp.TokensToRegexpOptions &\n  pathToRegexp.ParseOptions = {\n  ...matcherOptions,\n  strict: true,\n}\n\nexport default (customRoute = false) => {\n  return (path: string, regexModifier?: (regex: string) => string) => {\n    const keys: pathToRegexp.Key[] = []\n    let matcherRegex = pathToRegexp.pathToRegexp(\n      path,\n      keys,\n      customRoute ? customRouteMatcherOptions : matcherOptions\n    )\n\n    if (regexModifier) {\n      const regexSource = regexModifier(matcherRegex.source)\n      matcherRegex = new RegExp(regexSource, matcherRegex.flags)\n    }\n\n    const matcher = pathToRegexp.regexpToFunction(matcherRegex, keys)\n\n    return (pathname: string | null | undefined, params?: any) => {\n      const res = pathname == null ? false : matcher(pathname)\n      if (!res) {\n        return false\n      }\n\n      if (customRoute) {\n        for (const key of keys) {\n          // unnamed params should be removed as they\n          // are not allowed to be used in the destination\n          if (typeof key.name === 'number') {\n            delete (res.params as any)[key.name]\n          }\n        }\n      }\n\n      return { ...params, ...res.params }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}