{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.getOrientation = {}));\n})(this, function (exports) {\n  'use strict';\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n  function __awaiter(thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function step(result) {\n        result.done ? resolve(result.value) : new P(function (resolve) {\n          resolve(result.value);\n        }).then(fulfilled, rejected);\n      }\n\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  }\n\n  (function (Orientation) {\n    Orientation[Orientation[\"TOP_LEFT\"] = 1] = \"TOP_LEFT\";\n    Orientation[Orientation[\"TOP_RIGHT\"] = 2] = \"TOP_RIGHT\";\n    Orientation[Orientation[\"BOTTOM_RIGHT\"] = 3] = \"BOTTOM_RIGHT\";\n    Orientation[Orientation[\"BOTTOM_LEFT\"] = 4] = \"BOTTOM_LEFT\";\n    Orientation[Orientation[\"LEFT_TOP\"] = 5] = \"LEFT_TOP\";\n    Orientation[Orientation[\"RIGHT_TOP\"] = 6] = \"RIGHT_TOP\";\n    Orientation[Orientation[\"RIGHT_BOTTOM\"] = 7] = \"RIGHT_BOTTOM\";\n    Orientation[Orientation[\"LEFT_BOTTOM\"] = 8] = \"LEFT_BOTTOM\";\n  })(exports.Orientation || (exports.Orientation = {}));\n\n  const fileReaderMap = new WeakMap();\n\n  function getOrientation(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!(input instanceof ArrayBuffer || input instanceof Blob)) {\n        throw new TypeError(\"Unexpected input type\");\n      }\n\n      let offset = 0;\n      const totalBytes = getSize(input); // Signature validation\n\n      {\n        const bufSignature = yield readBytes(input, offset, 4);\n        offset += bufSignature.byteLength;\n        const signature = new DataView(bufSignature);\n        const head = signature.getUint16(0);\n        const tail = signature.getUint16(2); // Check EXIF SOI first\n\n        if (head === 0xffd8) {\n          // This is EXIF structure. handle application markers\n          let bufMarker = bufSignature.slice(2);\n\n          do {\n            const marker = new DataView(bufMarker).getUint16(0);\n\n            if (marker === 0xffe1) {\n              // APP1 Marker - EXIF, or Adobe XMP\n              // We must verify that marker segment to avoid conflict.\n              // Adobe XMP uses APP1 space too!\n              const bufSegmentHead = yield readBytes(input, offset, 8);\n              const segmentHead = new DataView(bufSegmentHead);\n              const isEXIF = segmentHead.getUint16(2) === 0x4578 && segmentHead.getUint16(4) === 0x6966 && segmentHead.getUint16(6) === 0x0000;\n\n              if (isEXIF) {\n                offset += bufSegmentHead.byteLength;\n                break;\n              } else {\n                const segmentSize = segmentHead.getUint16(0);\n                offset += segmentSize;\n              }\n            } else if (0xffe0 <= marker && marker <= 0xffef) {\n              // Other JPEG application markers\n              // e.g. APP0 Marker (JFIF), APP2 Marker (FlashFix Extension, ICC Color Profile), Photoshop IRB...\n              // @see http://www.ozhiker.com/electronics/pjmt/jpeg_info/app_segments.html\n              // Just skip. we don't need them\n              const bufSegmentSize = yield readBytes(input, offset, 2);\n              offset += bufSegmentSize.byteLength;\n              const segmentSize = new DataView(bufSegmentSize).getUint16(0);\n              const remainingBytes = segmentSize - 2;\n              offset += remainingBytes;\n            } else {\n              // If any other JPEG marker segment was found, skip entire bytes.\n              // Please refer Table B.1 – Marker code assignments from\n              // https://www.w3.org/Graphics/JPEG/itu-t81.pdf\n              return exports.Orientation.TOP_LEFT;\n            }\n\n            bufMarker = yield readBytes(input, offset, 2);\n            offset += bufMarker.byteLength;\n          } while (offset < totalBytes);\n        } else if (head === 0x4949 && tail === 0x2a00 || head === 0x4d4d && tail === 0x002a) {\n          // yeah this is TIFF header\n          // reset offset cursor.\n          offset = 0;\n        } else {\n          // This stream is not a JPEG file. Skip.\n          return exports.Orientation.TOP_LEFT;\n        }\n      }\n      const bufTIFFHeader = yield readBytes(input, offset, 8);\n      const tiffHeader = new DataView(bufTIFFHeader);\n      const isLittleEndian = tiffHeader.getUint16(0) === 0x4949;\n      const ifdOffset = tiffHeader.getUint32(4, isLittleEndian); // move cursor to IFD block\n\n      offset += ifdOffset;\n      const bufFieldCount = yield readBytes(input, offset, 2);\n      offset += bufFieldCount.byteLength;\n      let fieldCount = new DataView(bufFieldCount).getUint16(0, isLittleEndian);\n\n      while (fieldCount-- > 0) {\n        const bufField = yield readBytes(input, offset, 12);\n        offset += bufField.byteLength;\n        const field = new DataView(bufField);\n        const tagId = field.getUint16(0, isLittleEndian);\n\n        if (tagId === 0x112) {\n          // Orientation Tag\n          const value = new DataView(bufField.slice(8, 12)).getUint16(0, isLittleEndian);\n\n          if (1 <= value && value <= 8) {\n            return value;\n          } else {\n            throw new Error(\"Unexpected Orientation Value\");\n          }\n        }\n      }\n\n      return exports.Orientation.TOP_LEFT;\n    });\n  }\n\n  function readBytes(input, offset, size) {\n    if (input instanceof Blob) {\n      return new Promise((resolve, reject) => {\n        let reader = fileReaderMap.get(input);\n\n        if (!reader) {\n          reader = new FileReader();\n          fileReaderMap.set(input, reader);\n        }\n\n        reader.onerror = e => {\n          reader.onerror = null;\n          reader.onload = null;\n          reject(e);\n        };\n\n        reader.onload = () => {\n          reader.onerror = null;\n          reader.onload = null;\n          resolve(reader.result);\n        };\n\n        reader.readAsArrayBuffer(input.slice(offset, offset + size));\n      });\n    }\n\n    return Promise.resolve(input.slice(offset, offset + size));\n  }\n\n  function getSize(input) {\n    return input instanceof Blob ? input.size : input.byteLength;\n  }\n\n  exports.getOrientation = getOrientation;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["base.ts","browser.ts"],"names":["Orientation"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,GAAA,UAAYA,WAAZ,EAAuB;AACrB,IAAA,WAAA,CAAA,WAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AACA,IAAA,WAAA,CAAA,WAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACA,IAAA,WAAA,CAAA,WAAA,CAAA,cAAA,CAAA,GAAA,CAAA,CAAA,GAAA,cAAA;AACA,IAAA,WAAA,CAAA,WAAA,CAAA,aAAA,CAAA,GAAA,CAAA,CAAA,GAAA,aAAA;AACA,IAAA,WAAA,CAAA,WAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AACA,IAAA,WAAA,CAAA,WAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACA,IAAA,WAAA,CAAA,WAAA,CAAA,cAAA,CAAA,GAAA,CAAA,CAAA,GAAA,cAAA;AACA,IAAA,WAAA,CAAA,WAAA,CAAA,aAAA,CAAA,GAAA,CAAA,CAAA,GAAA,aAAA;AACD,GATD,EAAYA,OAAAA,CAAAA,WAAAA,KAAAA,OAAAA,CAAAA,WAAAA,GAAW,EAAXA,CAAZ;;ACIA,QAAM,aAAa,GAAG,IAAI,OAAJ,EAAtB;;AAEA,WAAsB,cAAtB,CAAqC,KAArC,EAAqE;;AACnE,UAAI,EAAE,KAAK,YAAY,WAAjB,IAAgC,KAAK,YAAY,IAAnD,CAAJ,EAA8D;AAC5D,cAAM,IAAI,SAAJ,CAAc,uBAAd,CAAN;AACD;;AAED,UAAI,MAAM,GAAG,CAAb;AACA,YAAM,UAAU,GAAG,OAAO,CAAC,KAAD,CAA1B,C;;AAGA;AACE,cAAM,YAAY,GAAG,MAAM,SAAS,CAAC,KAAD,EAAQ,MAAR,EAAgB,CAAhB,CAApC;AACA,QAAA,MAAM,IAAI,YAAY,CAAC,UAAvB;AAEA,cAAM,SAAS,GAAG,IAAI,QAAJ,CAAa,YAAb,CAAlB;AACA,cAAM,IAAI,GAAG,SAAS,CAAC,SAAV,CAAoB,CAApB,CAAb;AACA,cAAM,IAAI,GAAG,SAAS,CAAC,SAAV,CAAoB,CAApB,CAAb,CANF,C;;AASE,YAAI,IAAI,KAAK,MAAb,EAAqB;;AAEnB,cAAI,SAAS,GAAG,YAAY,CAAC,KAAb,CAAmB,CAAnB,CAAhB;;AACA,aAAG;AACD,kBAAM,MAAM,GAAI,IAAI,QAAJ,CAAa,SAAb,CAAD,CAA0B,SAA1B,CAAoC,CAApC,CAAf;;AACA,gBAAI,MAAM,KAAK,MAAf,EAAuB;AAAA;;;AAGrB,oBAAM,cAAc,GAAG,MAAM,SAAS,CAAC,KAAD,EAAQ,MAAR,EAAgB,CAAhB,CAAtC;AACA,oBAAM,WAAW,GAAG,IAAI,QAAJ,CAAa,cAAb,CAApB;AAEA,oBAAM,MAAM,GAAG,WAAW,CAAC,SAAZ,CAAsB,CAAtB,MAA6B,MAA7B,IACV,WAAW,CAAC,SAAZ,CAAsB,CAAtB,MAA6B,MADnB,IAEV,WAAW,CAAC,SAAZ,CAAsB,CAAtB,MAA6B,MAFlC;;AAIA,kBAAI,MAAJ,EAAY;AACV,gBAAA,MAAM,IAAI,cAAc,CAAC,UAAzB;AACA;AACD,eAHD,MAGO;AACL,sBAAM,WAAW,GAAG,WAAW,CAAC,SAAZ,CAAsB,CAAtB,CAApB;AACA,gBAAA,MAAM,IAAI,WAAV;AACD;AACF,aAjBD,MAiBO,IAAI,UAAU,MAAV,IAAoB,MAAM,IAAI,MAAlC,EAA0C;AAAA;;;;AAK/C,oBAAM,cAAc,GAAG,MAAM,SAAS,CAAC,KAAD,EAAQ,MAAR,EAAgB,CAAhB,CAAtC;AACA,cAAA,MAAM,IAAI,cAAc,CAAC,UAAzB;AAEA,oBAAM,WAAW,GAAI,IAAI,QAAJ,CAAa,cAAb,CAAD,CAA+B,SAA/B,CAAyC,CAAzC,CAApB;AACA,oBAAM,cAAc,GAAG,WAAW,GAAG,CAArC;AACA,cAAA,MAAM,IAAI,cAAV;AACD,aAXM,MAWA;AAAA;;;AAGL,qBAAOA,OAAAA,CAAAA,WAAAA,CAAY,QAAnB;AACD;;AAED,YAAA,SAAS,GAAG,MAAM,SAAS,CAAC,KAAD,EAAQ,MAAR,EAAgB,CAAhB,CAA3B;AACA,YAAA,MAAM,IAAI,SAAS,CAAC,UAApB;AACD,WAtCD,QAsCS,MAAM,GAAG,UAtClB;AAuCD,SA1CD,MA0CO,IAAK,IAAI,KAAK,MAAT,IAAmB,IAAI,KAAK,MAA7B,IAAyC,IAAI,KAAK,MAAT,IAAmB,IAAI,KAAK,MAAzE,EAAkF;;;AAGvF,UAAA,MAAM,GAAG,CAAT;AACD,SAJM,MAIA;AAAA;AACL,iBAAOA,OAAAA,CAAAA,WAAAA,CAAY,QAAnB;AACD;AACF;AAED,YAAM,aAAa,GAAG,MAAM,SAAS,CAAC,KAAD,EAAQ,MAAR,EAAgB,CAAhB,CAArC;AAEA,YAAM,UAAU,GAAG,IAAI,QAAJ,CAAa,aAAb,CAAnB;AACA,YAAM,cAAc,GAAG,UAAU,CAAC,SAAX,CAAqB,CAArB,MAA4B,MAAnD;AACA,YAAM,SAAS,GAAG,UAAU,CAAC,SAAX,CAAqB,CAArB,EAAwB,cAAxB,CAAlB,C;;AAGA,MAAA,MAAM,IAAI,SAAV;AAEA,YAAM,aAAa,GAAG,MAAM,SAAS,CAAC,KAAD,EAAQ,MAAR,EAAgB,CAAhB,CAArC;AACA,MAAA,MAAM,IAAI,aAAa,CAAC,UAAxB;AAEA,UAAI,UAAU,GAAI,IAAI,QAAJ,CAAa,aAAb,CAAD,CAA8B,SAA9B,CAAwC,CAAxC,EAA2C,cAA3C,CAAjB;;AACA,aAAO,UAAU,KAAK,CAAtB,EAAyB;AACvB,cAAM,QAAQ,GAAG,MAAM,SAAS,CAAC,KAAD,EAAQ,MAAR,EAAgB,EAAhB,CAAhC;AACA,QAAA,MAAM,IAAI,QAAQ,CAAC,UAAnB;AACA,cAAM,KAAK,GAAG,IAAI,QAAJ,CAAa,QAAb,CAAd;AAEA,cAAM,KAAK,GAAG,KAAK,CAAC,SAAN,CAAgB,CAAhB,EAAmB,cAAnB,CAAd;;AACA,YAAI,KAAK,KAAK,KAAd,EAAqB;AAAA;AACnB,gBAAM,KAAK,GAAI,IAAI,QAAJ,CAAa,QAAQ,CAAC,KAAT,CAAe,CAAf,EAAkB,EAAlB,CAAb,CAAD,CAAsC,SAAtC,CAAgD,CAAhD,EAAmD,cAAnD,CAAd;;AAEA,cAAI,KAAK,KAAL,IAAc,KAAK,IAAI,CAA3B,EAA8B;AAC5B,mBAAO,KAAP;AACD,WAFD,MAEO;AACL,kBAAM,IAAI,KAAJ,CAAU,8BAAV,CAAN;AACD;AACF;AACF;;AAED,aAAOA,OAAAA,CAAAA,WAAAA,CAAY,QAAnB;AACD,K;AAAA;;AAED,WAAS,SAAT,CAAmB,KAAnB,EAA8C,MAA9C,EAA8D,IAA9D,EAA0E;AACxE,QAAI,KAAK,YAAY,IAArB,EAA2B;AACzB,aAAO,IAAI,OAAJ,CAAyB,CAAC,OAAD,EAAU,MAAV,KAAgB;AAC9C,YAAI,MAAM,GAAG,aAAa,CAAC,GAAd,CAAkB,KAAlB,CAAb;;AAEA,YAAI,CAAC,MAAL,EAAa;AACX,UAAA,MAAM,GAAG,IAAI,UAAJ,EAAT;AACA,UAAA,aAAa,CAAC,GAAd,CAAkB,KAAlB,EAAyB,MAAzB;AACD;;AAED,QAAA,MAAM,CAAC,OAAP,GAAkB,CAAD,IAAE;AACjB,UAAA,MAAM,CAAC,OAAP,GAAiB,IAAjB;AACA,UAAA,MAAM,CAAC,MAAP,GAAgB,IAAhB;AACA,UAAA,MAAM,CAAC,CAAD,CAAN;AACD,SAJD;;AAMA,QAAA,MAAM,CAAC,MAAP,GAAgB,MAAA;AACd,UAAA,MAAM,CAAC,OAAP,GAAiB,IAAjB;AACA,UAAA,MAAM,CAAC,MAAP,GAAgB,IAAhB;AAEA,UAAA,OAAO,CAAC,MAAM,CAAC,MAAR,CAAP;AACD,SALD;;AAOA,QAAA,MAAM,CAAC,iBAAP,CACE,KAAK,CAAC,KAAN,CAAY,MAAZ,EAAoB,MAAM,GAAG,IAA7B,CADF;AAGD,OAxBM,CAAP;AAyBD;;AAED,WAAO,OAAO,CAAC,OAAR,CAAgB,KAAK,CAAC,KAAN,CAAY,MAAZ,EAAoB,MAAM,GAAG,IAA7B,CAAhB,CAAP;AACD;;AAED,WAAS,OAAT,CAAiB,KAAjB,EAA0C;AACxC,WAAO,KAAK,YAAY,IAAjB,GACL,KAAK,CAAC,IADD,GAEL,KAAK,CAAC,UAFR;AAGD","sourcesContent":["export enum Orientation {\n  TOP_LEFT = 1,         // Horizontal (Default)\n  TOP_RIGHT = 2,        // Mirror Horizontal\n  BOTTOM_RIGHT  = 3,    // Rotate 180\n  BOTTOM_LEFT = 4,      // Mirror vertical\n  LEFT_TOP = 5,         // Mirror horizontal and rotate 270 CW\n  RIGHT_TOP = 6,        // Rotate 90 CW\n  RIGHT_BOTTOM = 7,     // Mirror horizontal and rotate 90 CW\n  LEFT_BOTTOM = 8,      // Rotate 270 CW\n}\n","import { Orientation } from \"./base\";\n\nexport { Orientation };\n\nconst fileReaderMap = new WeakMap<Blob, FileReader>();\n\nexport async function getOrientation(input: ArrayBuffer | File | Blob) {\n  if (!(input instanceof ArrayBuffer || input instanceof Blob)) {\n    throw new TypeError(\"Unexpected input type\");\n  }\n\n  let offset = 0;\n  const totalBytes = getSize(input);\n\n  // Signature validation\n  {\n    const bufSignature = await readBytes(input, offset, 4);\n    offset += bufSignature.byteLength;\n\n    const signature = new DataView(bufSignature);\n    const head = signature.getUint16(0);\n    const tail = signature.getUint16(2);\n\n    // Check EXIF SOI first\n    if (head === 0xffd8) {\n      // This is EXIF structure. handle application markers\n      let bufMarker = bufSignature.slice(2);\n      do {\n        const marker = (new DataView(bufMarker)).getUint16(0);\n        if (marker === 0xffe1) { // APP1 Marker - EXIF, or Adobe XMP\n          // We must verify that marker segment to avoid conflict.\n          // Adobe XMP uses APP1 space too!\n          const bufSegmentHead = await readBytes(input, offset, 8);\n          const segmentHead = new DataView(bufSegmentHead);\n\n          const isEXIF = segmentHead.getUint16(2) === 0x4578\n            && segmentHead.getUint16(4) === 0x6966\n            && segmentHead.getUint16(6) === 0x0000;\n\n          if (isEXIF) {\n            offset += bufSegmentHead.byteLength;\n            break;\n          } else {\n            const segmentSize = segmentHead.getUint16(0);\n            offset += segmentSize;\n          }\n        } else if (0xffe0 <= marker && marker <= 0xffef) { // Other JPEG application markers\n          // e.g. APP0 Marker (JFIF), APP2 Marker (FlashFix Extension, ICC Color Profile), Photoshop IRB...\n          // @see http://www.ozhiker.com/electronics/pjmt/jpeg_info/app_segments.html\n\n          // Just skip. we don't need them\n          const bufSegmentSize = await readBytes(input, offset, 2);\n          offset += bufSegmentSize.byteLength;\n\n          const segmentSize = (new DataView(bufSegmentSize)).getUint16(0);\n          const remainingBytes = segmentSize - 2;\n          offset += remainingBytes;\n        } else { // If any other JPEG marker segment was found, skip entire bytes.\n          // Please refer Table B.1 – Marker code assignments from\n          // https://www.w3.org/Graphics/JPEG/itu-t81.pdf\n          return Orientation.TOP_LEFT;\n        }\n\n        bufMarker = await readBytes(input, offset, 2);\n        offset += bufMarker.byteLength;\n      } while (offset < totalBytes);\n    } else if ((head === 0x4949 && tail === 0x2a00) || (head === 0x4d4d && tail === 0x002a)) {\n      // yeah this is TIFF header\n      // reset offset cursor.\n      offset = 0;\n    } else { // This stream is not a JPEG file. Skip.\n      return Orientation.TOP_LEFT;\n    }\n  }\n\n  const bufTIFFHeader = await readBytes(input, offset, 8);\n\n  const tiffHeader = new DataView(bufTIFFHeader);\n  const isLittleEndian = tiffHeader.getUint16(0) === 0x4949;\n  const ifdOffset = tiffHeader.getUint32(4, isLittleEndian);\n\n  // move cursor to IFD block\n  offset += ifdOffset;\n\n  const bufFieldCount = await readBytes(input, offset, 2);\n  offset += bufFieldCount.byteLength;\n\n  let fieldCount = (new DataView(bufFieldCount)).getUint16(0, isLittleEndian);\n  while (fieldCount-- > 0) {\n    const bufField = await readBytes(input, offset, 12);\n    offset += bufField.byteLength;\n    const field = new DataView(bufField);\n\n    const tagId = field.getUint16(0, isLittleEndian);\n    if (tagId === 0x112) { // Orientation Tag\n      const value = (new DataView(bufField.slice(8, 12))).getUint16(0, isLittleEndian);\n\n      if (1 <= value && value <= 8) {\n        return value as Orientation;\n      } else {\n        throw new Error(\"Unexpected Orientation Value\");\n      }\n    }\n  }\n\n  return Orientation.TOP_LEFT;\n}\n\nfunction readBytes(input: Blob | ArrayBuffer, offset: number, size: number): Promise<ArrayBuffer> {\n  if (input instanceof Blob) {\n    return new Promise<ArrayBuffer>((resolve, reject) => {\n      let reader = fileReaderMap.get(input)!;\n\n      if (!reader) {\n        reader = new FileReader();\n        fileReaderMap.set(input, reader);\n      }\n\n      reader.onerror = (e) => {\n        reader.onerror = null;\n        reader.onload = null;\n        reject(e);\n      };\n\n      reader.onload = () => {\n        reader.onerror = null;\n        reader.onload = null;\n\n        resolve(reader.result as ArrayBuffer);\n      };\n\n      reader.readAsArrayBuffer(\n        input.slice(offset, offset + size),\n      );\n    });\n  }\n\n  return Promise.resolve(input.slice(offset, offset + size));\n}\n\nfunction getSize(input: Blob | ArrayBuffer) {\n  return input instanceof Blob ?\n    input.size :\n    input.byteLength;\n}\n"]},"metadata":{},"sourceType":"script"}