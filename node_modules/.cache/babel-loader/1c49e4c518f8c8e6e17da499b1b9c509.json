{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.recursiveReadDirSync = recursiveReadDirSync;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _path = require(\"path\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction recursiveReadDirSync(dir, arr = [], rootDir = dir) {\n  const result = _fs.default.readdirSync(dir);\n\n  result.forEach(part => {\n    const absolutePath = (0, _path).join(dir, part);\n\n    const pathStat = _fs.default.statSync(absolutePath);\n\n    if (pathStat.isDirectory()) {\n      recursiveReadDirSync(absolutePath, arr, rootDir);\n      return;\n    }\n\n    arr.push(absolutePath.replace(rootDir, ''));\n  });\n  return arr;\n}","map":{"version":3,"sources":["../../../server/lib/recursive-readdir-sync.ts"],"names":[],"mappings":";;;;;QASgB,oB,GAAA,oB;;AATD,IAAA,GAAI,GAAA,sBAAA,CAAA,OAAA,CAAA,IAAA,CAAA,CAAJ;;AACM,IAAA,KAAM,GAAA,OAAA,CAAA,MAAA,CAAN;;;;;;;;SAQL,oB,CACd,G,EACA,GAAa,GAAA,E,EACb,OAAO,GAAG,G,EACA;AACV,QAAM,MAAM,GAdC,GAAI,CAAA,OAAJ,CAcK,WAdL,CAciB,GAdjB,CAcb;;AAEA,EAAA,MAAM,CAAC,OAAP,CAAgB,IAAF,IAAmB;AAC/B,UAAM,YAAY,GAAA,CAAA,GAhBD,KAgBC,EAhBK,IAgBL,CAAQ,GAAR,EAAa,IAAb,CAAlB;;AACA,UAAM,QAAQ,GAlBH,GAAI,CAAA,OAAJ,CAkBS,QAlBT,CAkBkB,YAlBlB,CAkBX;;AAEA,QAAI,QAAQ,CAAC,WAAT,EAAJ,EAA4B;AAC1B,MAAA,oBAAoB,CAAC,YAAD,EAAe,GAAf,EAAoB,OAApB,CAApB;;AAED;;AACD,IAAA,GAAG,CAAC,IAAJ,CAAS,YAAY,CAAC,OAAb,CAAqB,OAArB,EAA4B,EAA5B,CAAT;AACD,GATD;SAWO,G;AACR","sourcesContent":["import fs from 'fs'\nimport { join } from 'path'\n\n/**\n * Recursively read directory\n * @param  {string[]=[]} arr This doesn't have to be provided, it's used for the recursion\n * @param  {string=dir`} rootDir Used to replace the initial path, only the relative path is left, it's faster than path.relative.\n * @returns Array holding all relative paths\n */\nexport function recursiveReadDirSync(\n  dir: string,\n  arr: string[] = [],\n  rootDir = dir\n): string[] {\n  const result = fs.readdirSync(dir)\n\n  result.forEach((part: string) => {\n    const absolutePath = join(dir, part)\n    const pathStat = fs.statSync(absolutePath)\n\n    if (pathStat.isDirectory()) {\n      recursiveReadDirSync(absolutePath, arr, rootDir)\n      return\n    }\n    arr.push(absolutePath.replace(rootDir, ''))\n  })\n\n  return arr\n}\n"]},"metadata":{},"sourceType":"script"}