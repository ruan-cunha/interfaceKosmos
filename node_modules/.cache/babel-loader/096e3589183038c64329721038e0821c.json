{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadStaticPaths = loadStaticPaths;\n\nvar _utils = require(\"../../build/utils\");\n\nvar _config = require(\"../config\");\n\nvar _loadComponents = require(\"../load-components\");\n\nrequire(\"../node-polyfill-fetch\");\n\nlet workerWasUsed = false;\n\nasync function loadStaticPaths(distDir, pathname, serverless, config, httpAgentOptions, locales, defaultLocale) {\n  // we only want to use each worker once to prevent any invalid\n  // caches\n  if (workerWasUsed) {\n    process.exit(1);\n  } // update work memory runtime-config\n\n\n  require('../../shared/lib/runtime-config').setConfig(config);\n\n  (0, _config).setHttpAgentOptions(httpAgentOptions);\n  const components = await (0, _loadComponents).loadComponents(distDir, pathname, serverless);\n\n  if (!components.getStaticPaths) {\n    // we shouldn't get to this point since the worker should\n    // only be called for SSG pages with getStaticPaths\n    throw new Error(`Invariant: failed to load page with getStaticPaths for ${pathname}`);\n  }\n\n  workerWasUsed = true;\n  return (0, _utils).buildStaticPaths(pathname, components.getStaticPaths, locales, defaultLocale);\n}","map":{"version":3,"sources":["../../../server/dev/static-paths-worker.ts"],"names":[],"mappings":";;;;;QAasB,e,GAAA,e;;AAbW,IAAA,MAAmB,GAAA,OAAA,CAAA,mBAAA,CAAnB;;AACG,IAAA,OAAW,GAAA,OAAA,CAAA,WAAA,CAAX;;AAEL,IAAA,eAAoB,GAAA,OAAA,CAAA,oBAAA,CAApB;;;;AAK/B,IAAI,aAAa,GAAG,KAApB;;eAKsB,e,CACpB,O,EACA,Q,EACA,U,EACA,M,EACA,gB,EACA,O,EACA,a,EACA;AACA;AACA;AACA,MAAI,aAAJ,EAAmB;AACjB,IAAA,OAAO,CAAC,IAAR,CAAa,CAAb;AACD,GALD,CAOA;;;AACA,EAAA,OAAO,CAAA,iCAAA,CAAP,CAA2C,SAA3C,CAAqD,MAArD;;MA5BkC,O,EAAW,mB,CA6BzB,gB;AAEpB,QAAM,UAAU,GAAA,MAAA,CAAA,GA7Ba,eA6Bb,EA7BiC,cA6BjC,CAAwB,OAAxB,EAAiC,QAAjC,EAA2C,UAA3C,CAAhB;;AAEA,MAAE,CAAG,UAAU,CAAC,cAAhB,EAAgC;AAC9B;AACA;AACA,UAAM,IAAI,KAAJ,CACH,0DAAyD,QAAQ,EAD9D,CAAN;AAGD;;AAED,EAAA,aAAa,GAAG,IAAhB;aA1C+B,M,EAAmB,gB,CA4ChD,Q,EACA,UAAU,CAAC,c,EACX,O,EACA,a;AAEH","sourcesContent":["import { buildStaticPaths } from '../../build/utils'\nimport { setHttpAgentOptions } from '../config'\nimport { NextConfigComplete } from '../config-shared'\nimport { loadComponents } from '../load-components'\nimport '../node-polyfill-fetch'\n\ntype RuntimeConfig = any\n\nlet workerWasUsed = false\n\n// we call getStaticPaths in a separate process to ensure\n// side-effects aren't relied on in dev that will break\n// during a production build\nexport async function loadStaticPaths(\n  distDir: string,\n  pathname: string,\n  serverless: boolean,\n  config: RuntimeConfig,\n  httpAgentOptions: NextConfigComplete['httpAgentOptions'],\n  locales?: string[],\n  defaultLocale?: string\n) {\n  // we only want to use each worker once to prevent any invalid\n  // caches\n  if (workerWasUsed) {\n    process.exit(1)\n  }\n\n  // update work memory runtime-config\n  require('../../shared/lib/runtime-config').setConfig(config)\n  setHttpAgentOptions(httpAgentOptions)\n\n  const components = await loadComponents(distDir, pathname, serverless)\n\n  if (!components.getStaticPaths) {\n    // we shouldn't get to this point since the worker should\n    // only be called for SSG pages with getStaticPaths\n    throw new Error(\n      `Invariant: failed to load page with getStaticPaths for ${pathname}`\n    )\n  }\n\n  workerWasUsed = true\n  return buildStaticPaths(\n    pathname,\n    components.getStaticPaths,\n    locales,\n    defaultLocale\n  )\n}\n"]},"metadata":{},"sourceType":"script"}