{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.imageOptimizer = imageOptimizer;\nexports.detectContentType = detectContentType;\nexports.getMaxAge = getMaxAge;\nexports.resizeImage = resizeImage;\n\nvar _accept = require(\"@hapi/accept\");\n\nvar _crypto = require(\"crypto\");\n\nvar _fs = require(\"fs\");\n\nvar _getOrientation = require(\"get-orientation\");\n\nvar _isAnimated = _interopRequireDefault(require(\"next/dist/compiled/is-animated\"));\n\nvar _path = require(\"path\");\n\nvar _stream = _interopRequireDefault(require(\"stream\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _fileExists = require(\"../lib/file-exists\");\n\nvar _imageConfig = require(\"./image-config\");\n\nvar _main = require(\"./lib/squoosh/main\");\n\nvar _sendPayload = require(\"./send-payload\");\n\nvar _serveStatic = require(\"./serve-static\");\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} //const AVIF = 'image/avif'\n\n\nconst WEBP = 'image/webp';\nconst PNG = 'image/png';\nconst JPEG = 'image/jpeg';\nconst GIF = 'image/gif';\nconst SVG = 'image/svg+xml';\nconst CACHE_VERSION = 3;\nconst MODERN_TYPES = [\n/* AVIF, */\nWEBP];\nconst ANIMATABLE_TYPES = [WEBP, PNG, GIF];\nconst VECTOR_TYPES = [SVG];\nconst BLUR_IMG_SIZE = 8 // should match `next-image-loader`\n;\nconst inflightRequests = new Map();\nlet sharp;\n\ntry {\n  sharp = require(process.env.NEXT_SHARP_PATH || 'sharp');\n} catch (e) {// Sharp not present on the server, Squoosh fallback will be used\n}\n\nlet shouldShowSharpWarning = process.env.NODE_ENV === 'production';\n\nasync function imageOptimizer(server, req, res, parsedUrl, nextConfig, distDir, isDev = false) {\n  const imageData = nextConfig.images || _imageConfig.imageConfigDefault;\n  const {\n    deviceSizes = [],\n    imageSizes = [],\n    domains = [],\n    loader,\n    minimumCacheTTL = 60\n  } = imageData;\n\n  if (loader !== 'default') {\n    await server.render404(req, res, parsedUrl);\n    return {\n      finished: true\n    };\n  }\n\n  const {\n    headers\n  } = req;\n  const {\n    url,\n    w,\n    q\n  } = parsedUrl.query;\n  const mimeType = getSupportedMimeType(MODERN_TYPES, headers.accept);\n  let href;\n\n  if (!url) {\n    res.statusCode = 400;\n    res.end('\"url\" parameter is required');\n    return {\n      finished: true\n    };\n  } else if (Array.isArray(url)) {\n    res.statusCode = 400;\n    res.end('\"url\" parameter cannot be an array');\n    return {\n      finished: true\n    };\n  }\n\n  let isAbsolute;\n\n  if (url.startsWith('/')) {\n    href = url;\n    isAbsolute = false;\n  } else {\n    let hrefParsed;\n\n    try {\n      hrefParsed = new URL(url);\n      href = hrefParsed.toString();\n      isAbsolute = true;\n    } catch (_error) {\n      res.statusCode = 400;\n      res.end('\"url\" parameter is invalid');\n      return {\n        finished: true\n      };\n    }\n\n    if (!['http:', 'https:'].includes(hrefParsed.protocol)) {\n      res.statusCode = 400;\n      res.end('\"url\" parameter is invalid');\n      return {\n        finished: true\n      };\n    }\n\n    if (!domains.includes(hrefParsed.hostname)) {\n      res.statusCode = 400;\n      res.end('\"url\" parameter is not allowed');\n      return {\n        finished: true\n      };\n    }\n  }\n\n  if (!w) {\n    res.statusCode = 400;\n    res.end('\"w\" parameter (width) is required');\n    return {\n      finished: true\n    };\n  } else if (Array.isArray(w)) {\n    res.statusCode = 400;\n    res.end('\"w\" parameter (width) cannot be an array');\n    return {\n      finished: true\n    };\n  }\n\n  if (!q) {\n    res.statusCode = 400;\n    res.end('\"q\" parameter (quality) is required');\n    return {\n      finished: true\n    };\n  } else if (Array.isArray(q)) {\n    res.statusCode = 400;\n    res.end('\"q\" parameter (quality) cannot be an array');\n    return {\n      finished: true\n    };\n  } // Should match output from next-image-loader\n\n\n  const isStatic = url.startsWith('/_next/static/image');\n  const width = parseInt(w, 10);\n\n  if (!width || isNaN(width)) {\n    res.statusCode = 400;\n    res.end('\"w\" parameter (width) must be a number greater than 0');\n    return {\n      finished: true\n    };\n  }\n\n  const sizes = [...deviceSizes, ...imageSizes];\n\n  if (isDev) {\n    sizes.push(BLUR_IMG_SIZE);\n  }\n\n  if (!sizes.includes(width)) {\n    res.statusCode = 400;\n    res.end(`\"w\" parameter (width) of ${width} is not allowed`);\n    return {\n      finished: true\n    };\n  }\n\n  const quality = parseInt(q);\n\n  if (isNaN(quality) || quality < 1 || quality > 100) {\n    res.statusCode = 400;\n    res.end('\"q\" parameter (quality) must be a number between 1 and 100');\n    return {\n      finished: true\n    };\n  }\n\n  const hash = getHash([CACHE_VERSION, href, width, quality, mimeType]);\n  const imagesDir = (0, _path).join(distDir, 'cache', 'images');\n  const hashDir = (0, _path).join(imagesDir, hash);\n  const now = Date.now(); // If there're concurrent requests hitting the same resource and it's still\n  // being optimized, wait before accessing the cache.\n\n  if (inflightRequests.has(hash)) {\n    await inflightRequests.get(hash);\n  }\n\n  let dedupeResolver;\n  inflightRequests.set(hash, new Promise(resolve => dedupeResolver = resolve));\n\n  try {\n    if (await (0, _fileExists).fileExists(hashDir, 'directory')) {\n      const files = await _fs.promises.readdir(hashDir);\n\n      for (let file of files) {\n        const [maxAgeStr, expireAtSt, etag, extension] = file.split('.');\n        const maxAge = Number(maxAgeStr);\n        const expireAt = Number(expireAtSt);\n        const contentType = (0, _serveStatic).getContentType(extension);\n        const fsPath = (0, _path).join(hashDir, file);\n\n        if (now < expireAt) {\n          const result = setResponseHeaders(req, res, url, etag, maxAge, contentType, isStatic, isDev);\n\n          if (!result.finished) {\n            (0, _fs).createReadStream(fsPath).pipe(res);\n          }\n\n          return {\n            finished: true\n          };\n        } else {\n          await _fs.promises.unlink(fsPath);\n        }\n      }\n    }\n\n    let upstreamBuffer;\n    let upstreamType;\n    let maxAge;\n\n    if (isAbsolute) {\n      const upstreamRes = await fetch(href);\n\n      if (!upstreamRes.ok) {\n        res.statusCode = upstreamRes.status;\n        res.end('\"url\" parameter is valid but upstream response is invalid');\n        return {\n          finished: true\n        };\n      }\n\n      res.statusCode = upstreamRes.status;\n      upstreamBuffer = Buffer.from(await upstreamRes.arrayBuffer());\n      upstreamType = detectContentType(upstreamBuffer) || upstreamRes.headers.get('Content-Type');\n      maxAge = getMaxAge(upstreamRes.headers.get('Cache-Control'));\n    } else {\n      try {\n        const resBuffers = [];\n        const mockRes = new _stream.default.Writable();\n        const isStreamFinished = new Promise(function (resolve, reject) {\n          mockRes.on('finish', () => resolve(true));\n          mockRes.on('end', () => resolve(true));\n          mockRes.on('error', () => reject());\n        });\n\n        mockRes.write = chunk => {\n          resBuffers.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));\n        };\n\n        mockRes._write = chunk => {\n          mockRes.write(chunk);\n        };\n\n        const mockHeaders = {};\n\n        mockRes.writeHead = (_status, _headers) => Object.assign(mockHeaders, _headers);\n\n        mockRes.getHeader = name => mockHeaders[name.toLowerCase()];\n\n        mockRes.getHeaders = () => mockHeaders;\n\n        mockRes.getHeaderNames = () => Object.keys(mockHeaders);\n\n        mockRes.setHeader = (name, value) => mockHeaders[name.toLowerCase()] = value;\n\n        mockRes.removeHeader = name => {\n          delete mockHeaders[name.toLowerCase()];\n        };\n\n        mockRes._implicitHeader = () => {};\n\n        mockRes.connection = res.connection;\n        mockRes.finished = false;\n        mockRes.statusCode = 200;\n        const mockReq = new _stream.default.Readable();\n\n        mockReq._read = () => {\n          mockReq.emit('end');\n          mockReq.emit('close');\n          return Buffer.from('');\n        };\n\n        mockReq.headers = req.headers;\n        mockReq.method = req.method;\n        mockReq.url = href;\n        mockReq.connection = req.connection;\n        await server.getRequestHandler()(mockReq, mockRes, _url.default.parse(href, true));\n        await isStreamFinished;\n        res.statusCode = mockRes.statusCode;\n        upstreamBuffer = Buffer.concat(resBuffers);\n        upstreamType = detectContentType(upstreamBuffer) || mockRes.getHeader('Content-Type');\n        maxAge = getMaxAge(mockRes.getHeader('Cache-Control'));\n      } catch (err) {\n        res.statusCode = 500;\n        res.end('\"url\" parameter is valid but upstream response is invalid');\n        return {\n          finished: true\n        };\n      }\n    }\n\n    const expireAt = Math.max(maxAge, minimumCacheTTL) * 1000 + now;\n\n    if (upstreamType) {\n      const vector = VECTOR_TYPES.includes(upstreamType);\n      const animate = ANIMATABLE_TYPES.includes(upstreamType) && (0, _isAnimated).default(upstreamBuffer);\n\n      if (vector || animate) {\n        await writeToCacheDir(hashDir, upstreamType, maxAge, expireAt, upstreamBuffer);\n        sendResponse(req, res, url, maxAge, upstreamType, upstreamBuffer, isStatic, isDev);\n        return {\n          finished: true\n        };\n      }\n\n      if (!upstreamType.startsWith('image/')) {\n        res.statusCode = 400;\n        res.end(\"The requested resource isn't a valid image.\");\n        return {\n          finished: true\n        };\n      }\n    }\n\n    let contentType;\n\n    if (mimeType) {\n      contentType = mimeType;\n    } else if ((upstreamType === null || upstreamType === void 0 ? void 0 : upstreamType.startsWith('image/')) && (0, _serveStatic).getExtension(upstreamType)) {\n      contentType = upstreamType;\n    } else {\n      contentType = JPEG;\n    }\n\n    try {\n      let optimizedBuffer;\n\n      if (sharp) {\n        // Begin sharp transformation logic\n        const transformer = sharp(upstreamBuffer);\n        transformer.rotate();\n        const {\n          width: metaWidth\n        } = await transformer.metadata();\n\n        if (metaWidth && metaWidth > width) {\n          transformer.resize(width);\n        }\n\n        if (contentType === WEBP) {\n          transformer.webp({\n            quality\n          });\n        } else if (contentType === PNG) {\n          transformer.png({\n            quality\n          });\n        } else if (contentType === JPEG) {\n          transformer.jpeg({\n            quality\n          });\n        }\n\n        optimizedBuffer = await transformer.toBuffer(); // End sharp transformation logic\n      } else {\n        // Show sharp warning in production once\n        if (shouldShowSharpWarning) {\n          console.warn(_chalk.default.yellow.bold('Warning: ') + `For production Image Optimization with Next.js, the optional 'sharp' package is strongly recommended. Run 'yarn add sharp', and Next.js will use it automatically for Image Optimization.\\n` + 'Read more: https://nextjs.org/docs/messages/sharp-missing-in-production');\n          shouldShowSharpWarning = false;\n        } // Begin Squoosh transformation logic\n\n\n        const orientation = await (0, _getOrientation).getOrientation(upstreamBuffer);\n        const operations = [];\n\n        if (orientation === _getOrientation.Orientation.RIGHT_TOP) {\n          operations.push({\n            type: 'rotate',\n            numRotations: 1\n          });\n        } else if (orientation === _getOrientation.Orientation.BOTTOM_RIGHT) {\n          operations.push({\n            type: 'rotate',\n            numRotations: 2\n          });\n        } else if (orientation === _getOrientation.Orientation.LEFT_BOTTOM) {\n          operations.push({\n            type: 'rotate',\n            numRotations: 3\n          });\n        } else {// TODO: support more orientations\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          // const _: never = orientation\n        }\n\n        operations.push({\n          type: 'resize',\n          width\n        }); //if (contentType === AVIF) {\n        //} else\n\n        if (contentType === WEBP) {\n          optimizedBuffer = await (0, _main).processBuffer(upstreamBuffer, operations, 'webp', quality);\n        } else if (contentType === PNG) {\n          optimizedBuffer = await (0, _main).processBuffer(upstreamBuffer, operations, 'png', quality);\n        } else if (contentType === JPEG) {\n          optimizedBuffer = await (0, _main).processBuffer(upstreamBuffer, operations, 'jpeg', quality);\n        } // End Squoosh transformation logic\n\n      }\n\n      if (optimizedBuffer) {\n        await writeToCacheDir(hashDir, contentType, maxAge, expireAt, optimizedBuffer);\n        sendResponse(req, res, url, maxAge, contentType, optimizedBuffer, isStatic, isDev);\n      } else {\n        throw new Error('Unable to optimize buffer');\n      }\n    } catch (error) {\n      sendResponse(req, res, url, maxAge, upstreamType, upstreamBuffer, isStatic, isDev);\n    }\n\n    return {\n      finished: true\n    };\n  } finally {\n    // Make sure to remove the hash in the end.\n    dedupeResolver();\n    inflightRequests.delete(hash);\n  }\n}\n\nasync function writeToCacheDir(dir, contentType, maxAge, expireAt, buffer) {\n  await _fs.promises.mkdir(dir, {\n    recursive: true\n  });\n  const extension = (0, _serveStatic).getExtension(contentType);\n  const etag = getHash([buffer]);\n  const filename = (0, _path).join(dir, `${maxAge}.${expireAt}.${etag}.${extension}`);\n  await _fs.promises.writeFile(filename, buffer);\n}\n\nfunction getFileNameWithExtension(url, contentType) {\n  const [urlWithoutQueryParams] = url.split('?');\n  const fileNameWithExtension = urlWithoutQueryParams.split('/').pop();\n\n  if (!contentType || !fileNameWithExtension) {\n    return;\n  }\n\n  const [fileName] = fileNameWithExtension.split('.');\n  const extension = (0, _serveStatic).getExtension(contentType);\n  return `${fileName}.${extension}`;\n}\n\nfunction setResponseHeaders(req, res, url, etag, maxAge, contentType, isStatic, isDev) {\n  res.setHeader('Vary', 'Accept');\n  res.setHeader('Cache-Control', isStatic ? 'public, max-age=315360000, immutable' : `public, max-age=${isDev ? 0 : maxAge}, must-revalidate`);\n\n  if ((0, _sendPayload).sendEtagResponse(req, res, etag)) {\n    // already called res.end() so we're finished\n    return {\n      finished: true\n    };\n  }\n\n  if (contentType) {\n    res.setHeader('Content-Type', contentType);\n  }\n\n  const fileName = getFileNameWithExtension(url, contentType);\n\n  if (fileName) {\n    res.setHeader('Content-Disposition', `inline; filename=\"${fileName}\"`);\n  }\n\n  res.setHeader('Content-Security-Policy', `script-src 'none'; sandbox;`);\n  return {\n    finished: false\n  };\n}\n\nfunction sendResponse(req, res, url, maxAge, contentType, buffer, isStatic, isDev) {\n  const etag = getHash([buffer]);\n  const result = setResponseHeaders(req, res, url, etag, maxAge, contentType, isStatic, isDev);\n\n  if (!result.finished) {\n    res.end(buffer);\n  }\n}\n\nfunction getSupportedMimeType(options, accept = '') {\n  const mimeType = (0, _accept).mediaType(accept, options);\n  return accept.includes(mimeType) ? mimeType : '';\n}\n\nfunction getHash(items) {\n  const hash = (0, _crypto).createHash('sha256');\n\n  for (let item of items) {\n    if (typeof item === 'number') hash.update(String(item));else {\n      hash.update(item);\n    }\n  } // See https://en.wikipedia.org/wiki/Base64#Filenames\n\n\n  return hash.digest('base64').replace(/\\//g, '-');\n}\n\nfunction parseCacheControl(str) {\n  const map = new Map();\n\n  if (!str) {\n    return map;\n  }\n\n  for (let directive of str.split(',')) {\n    let [key, value] = directive.trim().split('=');\n    key = key.toLowerCase();\n\n    if (value) {\n      value = value.toLowerCase();\n    }\n\n    map.set(key, value);\n  }\n\n  return map;\n}\n\nfunction detectContentType(buffer) {\n  if ([255, 216, 255].every((b, i) => buffer[i] === b)) {\n    return JPEG;\n  }\n\n  if ([137, 80, 78, 71, 13, 10, 26, 10].every((b, i) => buffer[i] === b)) {\n    return PNG;\n  }\n\n  if ([71, 73, 70, 56].every((b, i) => buffer[i] === b)) {\n    return GIF;\n  }\n\n  if ([82, 73, 70, 70, 0, 0, 0, 0, 87, 69, 66, 80].every((b, i) => !b || buffer[i] === b)) {\n    return WEBP;\n  }\n\n  if ([60, 63, 120, 109, 108].every((b, i) => buffer[i] === b)) {\n    return SVG;\n  }\n\n  return null;\n}\n\nfunction getMaxAge(str) {\n  const map = parseCacheControl(str);\n\n  if (map) {\n    let age = map.get('s-maxage') || map.get('max-age') || '';\n\n    if (age.startsWith('\"') && age.endsWith('\"')) {\n      age = age.slice(1, -1);\n    }\n\n    const n = parseInt(age, 10);\n\n    if (!isNaN(n)) {\n      return n;\n    }\n  }\n\n  return 0;\n}\n\nasync function resizeImage(content, dimension, size, extension, quality) {\n  if (sharp) {\n    const transformer = sharp(content);\n\n    if (extension === 'webp') {\n      transformer.webp({\n        quality\n      });\n    } else if (extension === 'png') {\n      transformer.png({\n        quality\n      });\n    } else if (extension === 'jpeg') {\n      transformer.jpeg({\n        quality\n      });\n    }\n\n    if (dimension === 'width') {\n      transformer.resize(size);\n    } else {\n      transformer.resize(null, size);\n    }\n\n    const buf = await transformer.toBuffer();\n    return buf;\n  } else {\n    const resizeOperationOpts = dimension === 'width' ? {\n      type: 'resize',\n      width: size\n    } : {\n      type: 'resize',\n      height: size\n    };\n    const buf = await (0, _main).processBuffer(content, [resizeOperationOpts], extension, quality);\n    return buf;\n  }\n}","map":{"version":3,"sources":["../../server/image-optimizer.ts"],"names":[],"mappings":"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","sourcesContent":["import { mediaType } from '@hapi/accept'\nimport { createHash } from 'crypto'\nimport { createReadStream, promises } from 'fs'\nimport { getOrientation, Orientation } from 'get-orientation'\nimport { IncomingMessage, ServerResponse } from 'http'\n// @ts-ignore no types for is-animated\nimport isAnimated from 'next/dist/compiled/is-animated'\nimport { join } from 'path'\nimport Stream from 'stream'\nimport nodeUrl, { UrlWithParsedQuery } from 'url'\nimport { NextConfig } from './config-shared'\nimport { fileExists } from '../lib/file-exists'\nimport { ImageConfig, imageConfigDefault } from './image-config'\nimport { processBuffer, Operation } from './lib/squoosh/main'\nimport Server from './next-server'\nimport { sendEtagResponse } from './send-payload'\nimport { getContentType, getExtension } from './serve-static'\nimport chalk from 'chalk'\n\n//const AVIF = 'image/avif'\nconst WEBP = 'image/webp'\nconst PNG = 'image/png'\nconst JPEG = 'image/jpeg'\nconst GIF = 'image/gif'\nconst SVG = 'image/svg+xml'\nconst CACHE_VERSION = 3\nconst MODERN_TYPES = [/* AVIF, */ WEBP]\nconst ANIMATABLE_TYPES = [WEBP, PNG, GIF]\nconst VECTOR_TYPES = [SVG]\nconst BLUR_IMG_SIZE = 8 // should match `next-image-loader`\nconst inflightRequests = new Map<string, Promise<undefined>>()\n\nlet sharp:\n  | ((\n      input?: string | Buffer,\n      options?: import('sharp').SharpOptions\n    ) => import('sharp').Sharp)\n  | undefined\n\ntry {\n  sharp = require(process.env.NEXT_SHARP_PATH || 'sharp')\n} catch (e) {\n  // Sharp not present on the server, Squoosh fallback will be used\n}\n\nlet shouldShowSharpWarning = process.env.NODE_ENV === 'production'\n\nexport async function imageOptimizer(\n  server: Server,\n  req: IncomingMessage,\n  res: ServerResponse,\n  parsedUrl: UrlWithParsedQuery,\n  nextConfig: NextConfig,\n  distDir: string,\n  isDev = false\n) {\n  const imageData: ImageConfig = nextConfig.images || imageConfigDefault\n  const {\n    deviceSizes = [],\n    imageSizes = [],\n    domains = [],\n    loader,\n    minimumCacheTTL = 60,\n  } = imageData\n\n  if (loader !== 'default') {\n    await server.render404(req, res, parsedUrl)\n    return { finished: true }\n  }\n\n  const { headers } = req\n  const { url, w, q } = parsedUrl.query\n  const mimeType = getSupportedMimeType(MODERN_TYPES, headers.accept)\n  let href: string\n\n  if (!url) {\n    res.statusCode = 400\n    res.end('\"url\" parameter is required')\n    return { finished: true }\n  } else if (Array.isArray(url)) {\n    res.statusCode = 400\n    res.end('\"url\" parameter cannot be an array')\n    return { finished: true }\n  }\n\n  let isAbsolute: boolean\n\n  if (url.startsWith('/')) {\n    href = url\n    isAbsolute = false\n  } else {\n    let hrefParsed: URL\n\n    try {\n      hrefParsed = new URL(url)\n      href = hrefParsed.toString()\n      isAbsolute = true\n    } catch (_error) {\n      res.statusCode = 400\n      res.end('\"url\" parameter is invalid')\n      return { finished: true }\n    }\n\n    if (!['http:', 'https:'].includes(hrefParsed.protocol)) {\n      res.statusCode = 400\n      res.end('\"url\" parameter is invalid')\n      return { finished: true }\n    }\n\n    if (!domains.includes(hrefParsed.hostname)) {\n      res.statusCode = 400\n      res.end('\"url\" parameter is not allowed')\n      return { finished: true }\n    }\n  }\n\n  if (!w) {\n    res.statusCode = 400\n    res.end('\"w\" parameter (width) is required')\n    return { finished: true }\n  } else if (Array.isArray(w)) {\n    res.statusCode = 400\n    res.end('\"w\" parameter (width) cannot be an array')\n    return { finished: true }\n  }\n\n  if (!q) {\n    res.statusCode = 400\n    res.end('\"q\" parameter (quality) is required')\n    return { finished: true }\n  } else if (Array.isArray(q)) {\n    res.statusCode = 400\n    res.end('\"q\" parameter (quality) cannot be an array')\n    return { finished: true }\n  }\n\n  // Should match output from next-image-loader\n  const isStatic = url.startsWith('/_next/static/image')\n\n  const width = parseInt(w, 10)\n\n  if (!width || isNaN(width)) {\n    res.statusCode = 400\n    res.end('\"w\" parameter (width) must be a number greater than 0')\n    return { finished: true }\n  }\n\n  const sizes = [...deviceSizes, ...imageSizes]\n\n  if (isDev) {\n    sizes.push(BLUR_IMG_SIZE)\n  }\n\n  if (!sizes.includes(width)) {\n    res.statusCode = 400\n    res.end(`\"w\" parameter (width) of ${width} is not allowed`)\n    return { finished: true }\n  }\n\n  const quality = parseInt(q)\n\n  if (isNaN(quality) || quality < 1 || quality > 100) {\n    res.statusCode = 400\n    res.end('\"q\" parameter (quality) must be a number between 1 and 100')\n    return { finished: true }\n  }\n\n  const hash = getHash([CACHE_VERSION, href, width, quality, mimeType])\n  const imagesDir = join(distDir, 'cache', 'images')\n  const hashDir = join(imagesDir, hash)\n  const now = Date.now()\n\n  // If there're concurrent requests hitting the same resource and it's still\n  // being optimized, wait before accessing the cache.\n  if (inflightRequests.has(hash)) {\n    await inflightRequests.get(hash)\n  }\n  let dedupeResolver: (val?: PromiseLike<undefined>) => void\n  inflightRequests.set(\n    hash,\n    new Promise((resolve) => (dedupeResolver = resolve))\n  )\n\n  try {\n    if (await fileExists(hashDir, 'directory')) {\n      const files = await promises.readdir(hashDir)\n      for (let file of files) {\n        const [maxAgeStr, expireAtSt, etag, extension] = file.split('.')\n        const maxAge = Number(maxAgeStr)\n        const expireAt = Number(expireAtSt)\n        const contentType = getContentType(extension)\n        const fsPath = join(hashDir, file)\n        if (now < expireAt) {\n          const result = setResponseHeaders(\n            req,\n            res,\n            url,\n            etag,\n            maxAge,\n            contentType,\n            isStatic,\n            isDev\n          )\n          if (!result.finished) {\n            createReadStream(fsPath).pipe(res)\n          }\n          return { finished: true }\n        } else {\n          await promises.unlink(fsPath)\n        }\n      }\n    }\n\n    let upstreamBuffer: Buffer\n    let upstreamType: string | null\n    let maxAge: number\n\n    if (isAbsolute) {\n      const upstreamRes = await fetch(href)\n\n      if (!upstreamRes.ok) {\n        res.statusCode = upstreamRes.status\n        res.end('\"url\" parameter is valid but upstream response is invalid')\n        return { finished: true }\n      }\n\n      res.statusCode = upstreamRes.status\n      upstreamBuffer = Buffer.from(await upstreamRes.arrayBuffer())\n      upstreamType =\n        detectContentType(upstreamBuffer) ||\n        upstreamRes.headers.get('Content-Type')\n      maxAge = getMaxAge(upstreamRes.headers.get('Cache-Control'))\n    } else {\n      try {\n        const resBuffers: Buffer[] = []\n        const mockRes: any = new Stream.Writable()\n\n        const isStreamFinished = new Promise(function (resolve, reject) {\n          mockRes.on('finish', () => resolve(true))\n          mockRes.on('end', () => resolve(true))\n          mockRes.on('error', () => reject())\n        })\n\n        mockRes.write = (chunk: Buffer | string) => {\n          resBuffers.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk))\n        }\n        mockRes._write = (chunk: Buffer | string) => {\n          mockRes.write(chunk)\n        }\n\n        const mockHeaders: Record<string, string | string[]> = {}\n\n        mockRes.writeHead = (_status: any, _headers: any) =>\n          Object.assign(mockHeaders, _headers)\n        mockRes.getHeader = (name: string) => mockHeaders[name.toLowerCase()]\n        mockRes.getHeaders = () => mockHeaders\n        mockRes.getHeaderNames = () => Object.keys(mockHeaders)\n        mockRes.setHeader = (name: string, value: string | string[]) =>\n          (mockHeaders[name.toLowerCase()] = value)\n        mockRes.removeHeader = (name: string) => {\n          delete mockHeaders[name.toLowerCase()]\n        }\n        mockRes._implicitHeader = () => {}\n        mockRes.connection = res.connection\n        mockRes.finished = false\n        mockRes.statusCode = 200\n\n        const mockReq: any = new Stream.Readable()\n\n        mockReq._read = () => {\n          mockReq.emit('end')\n          mockReq.emit('close')\n          return Buffer.from('')\n        }\n\n        mockReq.headers = req.headers\n        mockReq.method = req.method\n        mockReq.url = href\n        mockReq.connection = req.connection\n\n        await server.getRequestHandler()(\n          mockReq,\n          mockRes,\n          nodeUrl.parse(href, true)\n        )\n        await isStreamFinished\n        res.statusCode = mockRes.statusCode\n\n        upstreamBuffer = Buffer.concat(resBuffers)\n        upstreamType =\n          detectContentType(upstreamBuffer) || mockRes.getHeader('Content-Type')\n        maxAge = getMaxAge(mockRes.getHeader('Cache-Control'))\n      } catch (err) {\n        res.statusCode = 500\n        res.end('\"url\" parameter is valid but upstream response is invalid')\n        return { finished: true }\n      }\n    }\n\n    const expireAt = Math.max(maxAge, minimumCacheTTL) * 1000 + now\n\n    if (upstreamType) {\n      const vector = VECTOR_TYPES.includes(upstreamType)\n      const animate =\n        ANIMATABLE_TYPES.includes(upstreamType) && isAnimated(upstreamBuffer)\n      if (vector || animate) {\n        await writeToCacheDir(\n          hashDir,\n          upstreamType,\n          maxAge,\n          expireAt,\n          upstreamBuffer\n        )\n        sendResponse(\n          req,\n          res,\n          url,\n          maxAge,\n          upstreamType,\n          upstreamBuffer,\n          isStatic,\n          isDev\n        )\n        return { finished: true }\n      }\n\n      if (!upstreamType.startsWith('image/')) {\n        res.statusCode = 400\n        res.end(\"The requested resource isn't a valid image.\")\n        return { finished: true }\n      }\n    }\n\n    let contentType: string\n\n    if (mimeType) {\n      contentType = mimeType\n    } else if (\n      upstreamType?.startsWith('image/') &&\n      getExtension(upstreamType)\n    ) {\n      contentType = upstreamType\n    } else {\n      contentType = JPEG\n    }\n    try {\n      let optimizedBuffer: Buffer | undefined\n      if (sharp) {\n        // Begin sharp transformation logic\n        const transformer = sharp(upstreamBuffer)\n\n        transformer.rotate()\n\n        const { width: metaWidth } = await transformer.metadata()\n\n        if (metaWidth && metaWidth > width) {\n          transformer.resize(width)\n        }\n\n        if (contentType === WEBP) {\n          transformer.webp({ quality })\n        } else if (contentType === PNG) {\n          transformer.png({ quality })\n        } else if (contentType === JPEG) {\n          transformer.jpeg({ quality })\n        }\n\n        optimizedBuffer = await transformer.toBuffer()\n        // End sharp transformation logic\n      } else {\n        // Show sharp warning in production once\n        if (shouldShowSharpWarning) {\n          console.warn(\n            chalk.yellow.bold('Warning: ') +\n              `For production Image Optimization with Next.js, the optional 'sharp' package is strongly recommended. Run 'yarn add sharp', and Next.js will use it automatically for Image Optimization.\\n` +\n              'Read more: https://nextjs.org/docs/messages/sharp-missing-in-production'\n          )\n          shouldShowSharpWarning = false\n        }\n\n        // Begin Squoosh transformation logic\n        const orientation = await getOrientation(upstreamBuffer)\n\n        const operations: Operation[] = []\n\n        if (orientation === Orientation.RIGHT_TOP) {\n          operations.push({ type: 'rotate', numRotations: 1 })\n        } else if (orientation === Orientation.BOTTOM_RIGHT) {\n          operations.push({ type: 'rotate', numRotations: 2 })\n        } else if (orientation === Orientation.LEFT_BOTTOM) {\n          operations.push({ type: 'rotate', numRotations: 3 })\n        } else {\n          // TODO: support more orientations\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          // const _: never = orientation\n        }\n\n        operations.push({ type: 'resize', width })\n\n        //if (contentType === AVIF) {\n        //} else\n        if (contentType === WEBP) {\n          optimizedBuffer = await processBuffer(\n            upstreamBuffer,\n            operations,\n            'webp',\n            quality\n          )\n        } else if (contentType === PNG) {\n          optimizedBuffer = await processBuffer(\n            upstreamBuffer,\n            operations,\n            'png',\n            quality\n          )\n        } else if (contentType === JPEG) {\n          optimizedBuffer = await processBuffer(\n            upstreamBuffer,\n            operations,\n            'jpeg',\n            quality\n          )\n        }\n\n        // End Squoosh transformation logic\n      }\n      if (optimizedBuffer) {\n        await writeToCacheDir(\n          hashDir,\n          contentType,\n          maxAge,\n          expireAt,\n          optimizedBuffer\n        )\n        sendResponse(\n          req,\n          res,\n          url,\n          maxAge,\n          contentType,\n          optimizedBuffer,\n          isStatic,\n          isDev\n        )\n      } else {\n        throw new Error('Unable to optimize buffer')\n      }\n    } catch (error) {\n      sendResponse(\n        req,\n        res,\n        url,\n        maxAge,\n        upstreamType,\n        upstreamBuffer,\n        isStatic,\n        isDev\n      )\n    }\n\n    return { finished: true }\n  } finally {\n    // Make sure to remove the hash in the end.\n    dedupeResolver!()\n    inflightRequests.delete(hash)\n  }\n}\n\nasync function writeToCacheDir(\n  dir: string,\n  contentType: string,\n  maxAge: number,\n  expireAt: number,\n  buffer: Buffer\n) {\n  await promises.mkdir(dir, { recursive: true })\n  const extension = getExtension(contentType)\n  const etag = getHash([buffer])\n  const filename = join(dir, `${maxAge}.${expireAt}.${etag}.${extension}`)\n  await promises.writeFile(filename, buffer)\n}\n\nfunction getFileNameWithExtension(\n  url: string,\n  contentType: string | null\n): string | void {\n  const [urlWithoutQueryParams] = url.split('?')\n  const fileNameWithExtension = urlWithoutQueryParams.split('/').pop()\n  if (!contentType || !fileNameWithExtension) {\n    return\n  }\n\n  const [fileName] = fileNameWithExtension.split('.')\n  const extension = getExtension(contentType)\n  return `${fileName}.${extension}`\n}\n\nfunction setResponseHeaders(\n  req: IncomingMessage,\n  res: ServerResponse,\n  url: string,\n  etag: string,\n  maxAge: number,\n  contentType: string | null,\n  isStatic: boolean,\n  isDev: boolean\n) {\n  res.setHeader('Vary', 'Accept')\n  res.setHeader(\n    'Cache-Control',\n    isStatic\n      ? 'public, max-age=315360000, immutable'\n      : `public, max-age=${isDev ? 0 : maxAge}, must-revalidate`\n  )\n  if (sendEtagResponse(req, res, etag)) {\n    // already called res.end() so we're finished\n    return { finished: true }\n  }\n  if (contentType) {\n    res.setHeader('Content-Type', contentType)\n  }\n\n  const fileName = getFileNameWithExtension(url, contentType)\n  if (fileName) {\n    res.setHeader('Content-Disposition', `inline; filename=\"${fileName}\"`)\n  }\n\n  res.setHeader('Content-Security-Policy', `script-src 'none'; sandbox;`)\n\n  return { finished: false }\n}\n\nfunction sendResponse(\n  req: IncomingMessage,\n  res: ServerResponse,\n  url: string,\n  maxAge: number,\n  contentType: string | null,\n  buffer: Buffer,\n  isStatic: boolean,\n  isDev: boolean\n) {\n  const etag = getHash([buffer])\n  const result = setResponseHeaders(\n    req,\n    res,\n    url,\n    etag,\n    maxAge,\n    contentType,\n    isStatic,\n    isDev\n  )\n  if (!result.finished) {\n    res.end(buffer)\n  }\n}\n\nfunction getSupportedMimeType(options: string[], accept = ''): string {\n  const mimeType = mediaType(accept, options)\n  return accept.includes(mimeType) ? mimeType : ''\n}\n\nfunction getHash(items: (string | number | Buffer)[]) {\n  const hash = createHash('sha256')\n  for (let item of items) {\n    if (typeof item === 'number') hash.update(String(item))\n    else {\n      hash.update(item)\n    }\n  }\n  // See https://en.wikipedia.org/wiki/Base64#Filenames\n  return hash.digest('base64').replace(/\\//g, '-')\n}\n\nfunction parseCacheControl(str: string | null): Map<string, string> {\n  const map = new Map<string, string>()\n  if (!str) {\n    return map\n  }\n  for (let directive of str.split(',')) {\n    let [key, value] = directive.trim().split('=')\n    key = key.toLowerCase()\n    if (value) {\n      value = value.toLowerCase()\n    }\n    map.set(key, value)\n  }\n  return map\n}\n\n/**\n * Inspects the first few bytes of a buffer to determine if\n * it matches the \"magic number\" of known file signatures.\n * https://en.wikipedia.org/wiki/List_of_file_signatures\n */\nexport function detectContentType(buffer: Buffer) {\n  if ([0xff, 0xd8, 0xff].every((b, i) => buffer[i] === b)) {\n    return JPEG\n  }\n  if (\n    [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a].every(\n      (b, i) => buffer[i] === b\n    )\n  ) {\n    return PNG\n  }\n  if ([0x47, 0x49, 0x46, 0x38].every((b, i) => buffer[i] === b)) {\n    return GIF\n  }\n  if (\n    [0x52, 0x49, 0x46, 0x46, 0, 0, 0, 0, 0x57, 0x45, 0x42, 0x50].every(\n      (b, i) => !b || buffer[i] === b\n    )\n  ) {\n    return WEBP\n  }\n  if ([0x3c, 0x3f, 0x78, 0x6d, 0x6c].every((b, i) => buffer[i] === b)) {\n    return SVG\n  }\n  return null\n}\n\nexport function getMaxAge(str: string | null): number {\n  const map = parseCacheControl(str)\n  if (map) {\n    let age = map.get('s-maxage') || map.get('max-age') || ''\n    if (age.startsWith('\"') && age.endsWith('\"')) {\n      age = age.slice(1, -1)\n    }\n    const n = parseInt(age, 10)\n    if (!isNaN(n)) {\n      return n\n    }\n  }\n  return 0\n}\n\nexport async function resizeImage(\n  content: Buffer,\n  dimension: 'width' | 'height',\n  size: number,\n  extension: 'webp' | 'png' | 'jpeg',\n  quality: number\n): Promise<Buffer> {\n  if (sharp) {\n    const transformer = sharp(content)\n\n    if (extension === 'webp') {\n      transformer.webp({ quality })\n    } else if (extension === 'png') {\n      transformer.png({ quality })\n    } else if (extension === 'jpeg') {\n      transformer.jpeg({ quality })\n    }\n    if (dimension === 'width') {\n      transformer.resize(size)\n    } else {\n      transformer.resize(null, size)\n    }\n    const buf = await transformer.toBuffer()\n    return buf\n  } else {\n    const resizeOperationOpts: Operation =\n      dimension === 'width'\n        ? { type: 'resize', width: size }\n        : { type: 'resize', height: size }\n    const buf = await processBuffer(\n      content,\n      [resizeOperationOpts],\n      extension,\n      quality\n    )\n    return buf\n  }\n}\n"]},"metadata":{},"sourceType":"script"}