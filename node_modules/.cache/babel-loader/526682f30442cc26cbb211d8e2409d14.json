{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _webpack = require(\"next/dist/compiled/webpack/webpack\");\n\nvar _fs = require(\"fs\");\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst originModules = [require.resolve('../../../server/require'), require.resolve('../../../server/load-components')];\n\nfunction deleteCache(filePath) {\n  try {\n    filePath = (0, _fs).realpathSync(filePath);\n  } catch (e) {\n    if (e.code !== 'ENOENT') throw e;\n  }\n\n  const module = require.cache[filePath];\n\n  if (module) {\n    // remove the child reference from the originModules\n    for (const originModule of originModules) {\n      const parent = require.cache[originModule];\n\n      if (parent) {\n        const idx = parent.children.indexOf(module);\n        if (idx >= 0) parent.children.splice(idx, 1);\n      }\n    } // remove parent references from external modules\n\n\n    for (const child of module.children) {\n      child.parent = null;\n    }\n  }\n\n  delete require.cache[filePath];\n}\n\nconst PLUGIN_NAME = 'NextJsRequireCacheHotReloader';\n\nclass NextJsRequireCacheHotReloader {\n  apply(compiler) {\n    if (_webpack.isWebpack5) {\n      // @ts-ignored Webpack has this hooks\n      compiler.hooks.assetEmitted.tap(PLUGIN_NAME, (_file, {\n        targetPath\n      }) => {\n        this.currentOutputPathsWebpack5.add(targetPath);\n        deleteCache(targetPath);\n      });\n      compiler.hooks.afterEmit.tap(PLUGIN_NAME, compilation => {\n        const runtimeChunkPath = _path.default.join(compilation.outputOptions.path, 'webpack-runtime.js');\n\n        deleteCache(runtimeChunkPath); // we need to make sure to clear all server entries from cache\n        // since they can have a stale webpack-runtime cache\n        // which needs to always be in-sync\n\n        const entries = [...compilation.entries.keys()].filter(entry => entry.toString().startsWith('pages/'));\n        entries.forEach(page => {\n          const outputPath = _path.default.join(compilation.outputOptions.path, page + '.js');\n\n          deleteCache(outputPath);\n        });\n      });\n      this.previousOutputPathsWebpack5 = new Set(this.currentOutputPathsWebpack5);\n      this.currentOutputPathsWebpack5.clear();\n      return;\n    }\n\n    compiler.hooks.afterEmit.tapAsync(PLUGIN_NAME, (compilation, callback) => {\n      const {\n        assets\n      } = compilation;\n\n      if (this.prevAssets) {\n        for (const f of Object.keys(assets)) {\n          deleteCache(assets[f].existsAt);\n        }\n\n        for (const f1 of Object.keys(this.prevAssets)) {\n          if (!assets[f1]) {\n            deleteCache(this.prevAssets[f1].existsAt);\n          }\n        }\n      }\n\n      this.prevAssets = assets;\n      callback();\n    });\n  }\n\n  constructor() {\n    this.prevAssets = null;\n    this.previousOutputPathsWebpack5 = new Set();\n    this.currentOutputPathsWebpack5 = new Set();\n  }\n\n}\n\nexports.NextJsRequireCacheHotReloader = NextJsRequireCacheHotReloader;","map":{"version":3,"sources":["../../../../build/webpack/plugins/nextjs-require-cache-hot-reloader.ts"],"names":[],"mappings":"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","sourcesContent":["import { webpack } from 'next/dist/compiled/webpack/webpack'\nimport { isWebpack5 } from 'next/dist/compiled/webpack/webpack'\nimport { realpathSync } from 'fs'\nimport path from 'path'\n\nconst originModules = [\n  require.resolve('../../../server/require'),\n  require.resolve('../../../server/load-components'),\n]\n\nfunction deleteCache(filePath: string) {\n  try {\n    filePath = realpathSync(filePath)\n  } catch (e) {\n    if (e.code !== 'ENOENT') throw e\n  }\n  const module = require.cache[filePath]\n  if (module) {\n    // remove the child reference from the originModules\n    for (const originModule of originModules) {\n      const parent = require.cache[originModule]\n      if (parent) {\n        const idx = parent.children.indexOf(module)\n        if (idx >= 0) parent.children.splice(idx, 1)\n      }\n    }\n    // remove parent references from external modules\n    for (const child of module.children) {\n      child.parent = null\n    }\n  }\n  delete require.cache[filePath]\n}\n\nconst PLUGIN_NAME = 'NextJsRequireCacheHotReloader'\n\n// This plugin flushes require.cache after emitting the files. Providing 'hot reloading' of server files.\nexport class NextJsRequireCacheHotReloader implements webpack.Plugin {\n  prevAssets: any = null\n  previousOutputPathsWebpack5: Set<string> = new Set()\n  currentOutputPathsWebpack5: Set<string> = new Set()\n\n  apply(compiler: webpack.Compiler) {\n    if (isWebpack5) {\n      // @ts-ignored Webpack has this hooks\n      compiler.hooks.assetEmitted.tap(\n        PLUGIN_NAME,\n        (_file: any, { targetPath }: any) => {\n          this.currentOutputPathsWebpack5.add(targetPath)\n          deleteCache(targetPath)\n        }\n      )\n\n      compiler.hooks.afterEmit.tap(PLUGIN_NAME, (compilation) => {\n        const runtimeChunkPath = path.join(\n          compilation.outputOptions.path,\n          'webpack-runtime.js'\n        )\n        deleteCache(runtimeChunkPath)\n\n        // we need to make sure to clear all server entries from cache\n        // since they can have a stale webpack-runtime cache\n        // which needs to always be in-sync\n        const entries = [...compilation.entries.keys()].filter((entry) =>\n          entry.toString().startsWith('pages/')\n        )\n\n        entries.forEach((page) => {\n          const outputPath = path.join(\n            compilation.outputOptions.path,\n            page + '.js'\n          )\n          deleteCache(outputPath)\n        })\n      })\n\n      this.previousOutputPathsWebpack5 = new Set(\n        this.currentOutputPathsWebpack5\n      )\n      this.currentOutputPathsWebpack5.clear()\n      return\n    }\n\n    compiler.hooks.afterEmit.tapAsync(PLUGIN_NAME, (compilation, callback) => {\n      const { assets } = compilation\n\n      if (this.prevAssets) {\n        for (const f of Object.keys(assets)) {\n          deleteCache(assets[f].existsAt)\n        }\n        for (const f of Object.keys(this.prevAssets)) {\n          if (!assets[f]) {\n            deleteCache(this.prevAssets[f].existsAt)\n          }\n        }\n      }\n      this.prevAssets = assets\n\n      callback()\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}