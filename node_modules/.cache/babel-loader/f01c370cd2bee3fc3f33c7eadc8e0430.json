{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _conf = _interopRequireDefault(require(\"next/dist/compiled/conf\"));\n\nvar _crypto = require(\"crypto\");\n\nvar _isDocker = _interopRequireDefault(require(\"next/dist/compiled/is-docker\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _anonymousMeta = require(\"./anonymous-meta\");\n\nvar ciEnvironment = _interopRequireWildcard(require(\"./ci-info\"));\n\nvar _postPayload = require(\"./post-payload\");\n\nvar _projectId = require(\"./project-id\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n} // This is the key that stores whether or not telemetry is enabled or disabled.\n\n\nconst TELEMETRY_KEY_ENABLED = 'telemetry.enabled'; // This is the key that specifies when the user was informed about anonymous\n// telemetry collection.\n\nconst TELEMETRY_KEY_NOTIFY_DATE = 'telemetry.notifiedAt'; // This is a quasi-persistent identifier used to dedupe recurring events. It's\n// generated from random data and completely anonymous.\n\nconst TELEMETRY_KEY_ID = `telemetry.anonymousId`; // This is the cryptographic salt that is included within every hashed value.\n// This salt value is never sent to us, ensuring privacy and the one-way nature\n// of the hash (prevents dictionary lookups of pre-computed hashes).\n// See the `oneWayHash` function.\n\nconst TELEMETRY_KEY_SALT = `telemetry.salt`;\n\nclass Telemetry {\n  constructor({\n    distDir\n  }) {\n    this.notify = () => {\n      if (this.isDisabled || !this.conf) {\n        return;\n      } // The end-user has already been notified about our telemetry integration. We\n      // don't need to constantly annoy them about it.\n      // We will re-inform users about the telemetry if significant changes are\n      // ever made.\n\n\n      if (this.conf.get(TELEMETRY_KEY_NOTIFY_DATE, '')) {\n        return;\n      }\n\n      this.conf.set(TELEMETRY_KEY_NOTIFY_DATE, Date.now().toString());\n      console.log(`${_chalk.default.magenta.bold('Attention')}: Next.js now collects completely anonymous telemetry regarding usage.`);\n      console.log(`This information is used to shape Next.js' roadmap and prioritize features.`);\n      console.log(`You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:`);\n      console.log(_chalk.default.cyan('https://nextjs.org/telemetry'));\n      console.log();\n    };\n\n    this.setEnabled = _enabled => {\n      const enabled = !!_enabled;\n      this.conf && this.conf.set(TELEMETRY_KEY_ENABLED, enabled);\n    };\n\n    this.oneWayHash = payload => {\n      const hash = (0, _crypto).createHash('sha256'); // Always prepend the payload value with salt. This ensures the hash is truly\n      // one-way.\n\n      hash.update(this.salt); // Update is an append operation, not a replacement. The salt from the prior\n      // update is still present!\n\n      hash.update(payload);\n      return hash.digest('hex');\n    };\n\n    this.record = _events => {\n      const _this = this; // pseudo try-catch\n\n\n      async function wrapper() {\n        return await _this.submitRecord(_events);\n      }\n\n      const prom = wrapper().then(value => ({\n        isFulfilled: true,\n        isRejected: false,\n        value\n      })).catch(reason => ({\n        isFulfilled: false,\n        isRejected: true,\n        reason\n      })) // Acts as `Promise#finally` because `catch` transforms the error\n      .then(res => {\n        // Clean up the event to prevent unbounded `Set` growth\n        this.queue.delete(prom);\n        return res;\n      }); // Track this `Promise` so we can flush pending events\n\n      this.queue.add(prom);\n      return prom;\n    };\n\n    this.flush = async () => Promise.all(this.queue).catch(() => null);\n\n    this.submitRecord = _events => {\n      let events;\n\n      if (Array.isArray(_events)) {\n        events = _events;\n      } else {\n        events = [_events];\n      }\n\n      if (events.length < 1) {\n        return Promise.resolve();\n      }\n\n      if (this.NEXT_TELEMETRY_DEBUG) {\n        // Print to standard error to simplify selecting the output\n        events.forEach(({\n          eventName,\n          payload\n        }) => console.error(`[telemetry] ` + JSON.stringify({\n          eventName,\n          payload\n        }, null, 2))); // Do not send the telemetry data if debugging. Users may use this feature\n        // to preview what data would be sent.\n\n        return Promise.resolve();\n      } // Skip recording telemetry if the feature is disabled\n\n\n      if (this.isDisabled) {\n        return Promise.resolve();\n      }\n\n      const context = {\n        anonymousId: this.anonymousId,\n        projectId: this.projectId,\n        sessionId: this.sessionId\n      };\n      const meta = (0, _anonymousMeta).getAnonymousMeta();\n      return (0, _postPayload)._postPayload(`https://telemetry.nextjs.org/api/v1/record`, {\n        context,\n        meta,\n        events: events.map(({\n          eventName,\n          payload\n        }) => ({\n          eventName,\n          fields: payload\n        }))\n      });\n    }; // Read in the constructor so that .env can be loaded before reading\n\n\n    const {\n      NEXT_TELEMETRY_DISABLED,\n      NEXT_TELEMETRY_DEBUG\n    } = process.env;\n    this.NEXT_TELEMETRY_DISABLED = NEXT_TELEMETRY_DISABLED;\n    this.NEXT_TELEMETRY_DEBUG = NEXT_TELEMETRY_DEBUG;\n    const storageDirectory = getStorageDirectory(distDir);\n\n    try {\n      // `conf` incorrectly throws a permission error during initialization\n      // instead of waiting for first use. We need to handle it, otherwise the\n      // process may crash.\n      this.conf = new _conf.default({\n        projectName: 'nextjs',\n        cwd: storageDirectory\n      });\n    } catch (_) {\n      this.conf = null;\n    }\n\n    this.sessionId = (0, _crypto).randomBytes(32).toString('hex');\n    this.rawProjectId = (0, _projectId).getRawProjectId();\n    this.queue = new Set();\n    this.notify();\n  }\n\n  get anonymousId() {\n    const val = this.conf && this.conf.get(TELEMETRY_KEY_ID);\n\n    if (val) {\n      return val;\n    }\n\n    const generated = (0, _crypto).randomBytes(32).toString('hex');\n    this.conf && this.conf.set(TELEMETRY_KEY_ID, generated);\n    return generated;\n  }\n\n  get salt() {\n    const val = this.conf && this.conf.get(TELEMETRY_KEY_SALT);\n\n    if (val) {\n      return val;\n    }\n\n    const generated = (0, _crypto).randomBytes(16).toString('hex');\n    this.conf && this.conf.set(TELEMETRY_KEY_SALT, generated);\n    return generated;\n  }\n\n  get isDisabled() {\n    if (!!this.NEXT_TELEMETRY_DISABLED || !this.conf) {\n      return true;\n    }\n\n    return this.conf.get(TELEMETRY_KEY_ENABLED, true) === false;\n  }\n\n  get isEnabled() {\n    return !!this.conf && this.conf.get(TELEMETRY_KEY_ENABLED, true) !== false;\n  }\n\n  get projectId() {\n    return this.oneWayHash(this.rawProjectId);\n  }\n\n}\n\nexports.Telemetry = Telemetry;\n\nfunction getStorageDirectory(distDir1) {\n  const isLikelyEphemeral = ciEnvironment.isCI || (0, _isDocker).default();\n\n  if (isLikelyEphemeral) {\n    return _path.default.join(distDir1, 'cache');\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../../telemetry/storage.ts"],"names":[],"mappings":"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","sourcesContent":["import chalk from 'chalk'\nimport Conf from 'next/dist/compiled/conf'\nimport { BinaryLike, createHash, randomBytes } from 'crypto'\nimport isDockerFunction from 'next/dist/compiled/is-docker'\nimport path from 'path'\n\nimport { getAnonymousMeta } from './anonymous-meta'\nimport * as ciEnvironment from './ci-info'\nimport { _postPayload } from './post-payload'\nimport { getRawProjectId } from './project-id'\n\n// This is the key that stores whether or not telemetry is enabled or disabled.\nconst TELEMETRY_KEY_ENABLED = 'telemetry.enabled'\n\n// This is the key that specifies when the user was informed about anonymous\n// telemetry collection.\nconst TELEMETRY_KEY_NOTIFY_DATE = 'telemetry.notifiedAt'\n\n// This is a quasi-persistent identifier used to dedupe recurring events. It's\n// generated from random data and completely anonymous.\nconst TELEMETRY_KEY_ID = `telemetry.anonymousId`\n\n// This is the cryptographic salt that is included within every hashed value.\n// This salt value is never sent to us, ensuring privacy and the one-way nature\n// of the hash (prevents dictionary lookups of pre-computed hashes).\n// See the `oneWayHash` function.\nconst TELEMETRY_KEY_SALT = `telemetry.salt`\n\ntype TelemetryEvent = { eventName: string; payload: object }\ntype EventContext = {\n  anonymousId: string\n  projectId: string\n  sessionId: string\n}\ntype EventMeta = { [key: string]: unknown }\ntype EventBatchShape = {\n  eventName: string\n  fields: object\n}\n\ntype RecordObject = {\n  isFulfilled: boolean\n  isRejected: boolean\n  value?: any\n  reason?: any\n}\n\nexport class Telemetry {\n  private conf: Conf<any> | null\n  private sessionId: string\n  private rawProjectId: string\n  private NEXT_TELEMETRY_DISABLED: any\n  private NEXT_TELEMETRY_DEBUG: any\n\n  private queue: Set<Promise<RecordObject>>\n\n  constructor({ distDir }: { distDir: string }) {\n    // Read in the constructor so that .env can be loaded before reading\n    const { NEXT_TELEMETRY_DISABLED, NEXT_TELEMETRY_DEBUG } = process.env\n    this.NEXT_TELEMETRY_DISABLED = NEXT_TELEMETRY_DISABLED\n    this.NEXT_TELEMETRY_DEBUG = NEXT_TELEMETRY_DEBUG\n    const storageDirectory = getStorageDirectory(distDir)\n\n    try {\n      // `conf` incorrectly throws a permission error during initialization\n      // instead of waiting for first use. We need to handle it, otherwise the\n      // process may crash.\n      this.conf = new Conf({ projectName: 'nextjs', cwd: storageDirectory })\n    } catch (_) {\n      this.conf = null\n    }\n    this.sessionId = randomBytes(32).toString('hex')\n    this.rawProjectId = getRawProjectId()\n\n    this.queue = new Set()\n\n    this.notify()\n  }\n\n  private notify = () => {\n    if (this.isDisabled || !this.conf) {\n      return\n    }\n\n    // The end-user has already been notified about our telemetry integration. We\n    // don't need to constantly annoy them about it.\n    // We will re-inform users about the telemetry if significant changes are\n    // ever made.\n    if (this.conf.get(TELEMETRY_KEY_NOTIFY_DATE, '')) {\n      return\n    }\n    this.conf.set(TELEMETRY_KEY_NOTIFY_DATE, Date.now().toString())\n\n    console.log(\n      `${chalk.magenta.bold(\n        'Attention'\n      )}: Next.js now collects completely anonymous telemetry regarding usage.`\n    )\n    console.log(\n      `This information is used to shape Next.js' roadmap and prioritize features.`\n    )\n    console.log(\n      `You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:`\n    )\n    console.log(chalk.cyan('https://nextjs.org/telemetry'))\n    console.log()\n  }\n\n  get anonymousId(): string {\n    const val = this.conf && this.conf.get(TELEMETRY_KEY_ID)\n    if (val) {\n      return val\n    }\n\n    const generated = randomBytes(32).toString('hex')\n    this.conf && this.conf.set(TELEMETRY_KEY_ID, generated)\n    return generated\n  }\n\n  get salt(): string {\n    const val = this.conf && this.conf.get(TELEMETRY_KEY_SALT)\n    if (val) {\n      return val\n    }\n\n    const generated = randomBytes(16).toString('hex')\n    this.conf && this.conf.set(TELEMETRY_KEY_SALT, generated)\n    return generated\n  }\n\n  private get isDisabled(): boolean {\n    if (!!this.NEXT_TELEMETRY_DISABLED || !this.conf) {\n      return true\n    }\n    return this.conf.get(TELEMETRY_KEY_ENABLED, true) === false\n  }\n\n  setEnabled = (_enabled: boolean) => {\n    const enabled = !!_enabled\n    this.conf && this.conf.set(TELEMETRY_KEY_ENABLED, enabled)\n  }\n\n  get isEnabled(): boolean {\n    return !!this.conf && this.conf.get(TELEMETRY_KEY_ENABLED, true) !== false\n  }\n\n  oneWayHash = (payload: BinaryLike): string => {\n    const hash = createHash('sha256')\n\n    // Always prepend the payload value with salt. This ensures the hash is truly\n    // one-way.\n    hash.update(this.salt)\n\n    // Update is an append operation, not a replacement. The salt from the prior\n    // update is still present!\n    hash.update(payload)\n    return hash.digest('hex')\n  }\n\n  private get projectId(): string {\n    return this.oneWayHash(this.rawProjectId)\n  }\n\n  record = (\n    _events: TelemetryEvent | TelemetryEvent[]\n  ): Promise<RecordObject> => {\n    const _this = this\n    // pseudo try-catch\n    async function wrapper() {\n      return await _this.submitRecord(_events)\n    }\n\n    const prom = wrapper()\n      .then((value) => ({\n        isFulfilled: true,\n        isRejected: false,\n        value,\n      }))\n      .catch((reason) => ({\n        isFulfilled: false,\n        isRejected: true,\n        reason,\n      }))\n      // Acts as `Promise#finally` because `catch` transforms the error\n      .then((res) => {\n        // Clean up the event to prevent unbounded `Set` growth\n        this.queue.delete(prom)\n        return res\n      })\n\n    // Track this `Promise` so we can flush pending events\n    this.queue.add(prom)\n\n    return prom\n  }\n\n  flush = async () => Promise.all(this.queue).catch(() => null)\n\n  private submitRecord = (\n    _events: TelemetryEvent | TelemetryEvent[]\n  ): Promise<any> => {\n    let events: TelemetryEvent[]\n    if (Array.isArray(_events)) {\n      events = _events\n    } else {\n      events = [_events]\n    }\n\n    if (events.length < 1) {\n      return Promise.resolve()\n    }\n\n    if (this.NEXT_TELEMETRY_DEBUG) {\n      // Print to standard error to simplify selecting the output\n      events.forEach(({ eventName, payload }) =>\n        console.error(\n          `[telemetry] ` + JSON.stringify({ eventName, payload }, null, 2)\n        )\n      )\n      // Do not send the telemetry data if debugging. Users may use this feature\n      // to preview what data would be sent.\n      return Promise.resolve()\n    }\n\n    // Skip recording telemetry if the feature is disabled\n    if (this.isDisabled) {\n      return Promise.resolve()\n    }\n\n    const context: EventContext = {\n      anonymousId: this.anonymousId,\n      projectId: this.projectId,\n      sessionId: this.sessionId,\n    }\n    const meta: EventMeta = getAnonymousMeta()\n    return _postPayload(`https://telemetry.nextjs.org/api/v1/record`, {\n      context,\n      meta,\n      events: events.map(({ eventName, payload }) => ({\n        eventName,\n        fields: payload,\n      })) as Array<EventBatchShape>,\n    })\n  }\n}\n\nfunction getStorageDirectory(distDir: string): string | undefined {\n  const isLikelyEphemeral = ciEnvironment.isCI || isDockerFunction()\n\n  if (isLikelyEphemeral) {\n    return path.join(distDir, 'cache')\n  }\n\n  return undefined\n}\n"]},"metadata":{},"sourceType":"script"}