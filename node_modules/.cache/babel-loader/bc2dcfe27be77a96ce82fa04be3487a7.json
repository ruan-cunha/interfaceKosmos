{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reporter = void 0;\n\nvar _shared = require(\"../shared\");\n\nvar _toConsole = _interopRequireDefault(require(\"./to-console\"));\n\nvar _toZipkin = _interopRequireDefault(require(\"./to-zipkin\"));\n\nvar _toJaeger = _interopRequireDefault(require(\"./to-jaeger\"));\n\nvar _toTelemetry = _interopRequireDefault(require(\"./to-telemetry\"));\n\nvar _toJson = _interopRequireDefault(require(\"./to-json\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nclass MultiReporter {\n  constructor(reporters) {\n    this.reporters = [];\n    this.reporters = reporters;\n  }\n\n  async flushAll() {\n    await Promise.all(this.reporters.map(reporter => reporter.flushAll()));\n  }\n\n  report(spanName, duration, timestamp, id, parentId, attrs) {\n    this.reporters.forEach(reporter => reporter.report(spanName, duration, timestamp, id, parentId, attrs));\n  }\n\n}\n\nconst target = process.env.TRACE_TARGET && process.env.TRACE_TARGET in _shared.TARGET ? _shared.TARGET[process.env.TRACE_TARGET] : _shared.TARGET.TELEMETRY;\n\nif (process.env.TRACE_TARGET && !target) {\n  console.info('For TRACE_TARGET, please specify one of: CONSOLE, ZIPKIN, TELEMETRY');\n}\n\nlet traceTargetReporter;\n\nif (target === _shared.TARGET.CONSOLE) {\n  traceTargetReporter = _toConsole.default;\n} else if (target === _shared.TARGET.ZIPKIN) {\n  traceTargetReporter = _toZipkin.default;\n} else if (target === _shared.TARGET.JAEGER) {\n  traceTargetReporter = _toJaeger.default;\n} else {\n  traceTargetReporter = _toTelemetry.default;\n}\n\nconst reporter = new MultiReporter([_toJson.default, traceTargetReporter]);\nexports.reporter = reporter;","map":{"version":3,"sources":["../../../../telemetry/trace/report/index.ts"],"names":[],"mappings":";;;;;;;AAA+B,IAAA,OAAW,GAAA,OAAA,CAAA,WAAA,CAAX;;AACH,IAAA,UAAc,GAAA,sBAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAd;;AACD,IAAA,SAAa,GAAA,sBAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAb;;AACA,IAAA,SAAa,GAAA,sBAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAb;;AACG,IAAA,YAAgB,GAAA,sBAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAhB;;AACL,IAAA,OAAW,GAAA,sBAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAX;;;;;;;;MAcnB,a,CAAa;cAGL,S,EAAuB;SAF3B,S,GAAS,E;SAGV,S,GAAY,S;AAClB;;AAEa,QAAR,QAAQ,GAAG;UACT,OAAO,CAAC,GAAR,CAAW,KAAM,SAAN,CAAgB,GAAhB,CAAqB,QAAF,IAAe,QAAQ,CAAC,QAAT,EAAlC,CAAX,C;AACP;;AAED,EAAA,MAAM,CACJ,QADI,EAEJ,QAFI,EAGJ,SAHI,EAIJ,EAJI,EAKJ,QALI,EAMJ,KANI,EAOJ;SACK,S,CAAU,O,CAAS,QAAF,IACpB,QAAQ,CAAC,MAAT,CAAgB,QAAhB,EAA0B,QAA1B,EAAoC,SAApC,EAA+C,EAA/C,EAAmD,QAAnD,EAA6D,KAA7D,C;AAEH;;AAtBgB;;AAyBnB,MAAM,MAAM,GACV,OAAO,CAAC,GAAR,CAAY,YAAZ,IAA4B,OAAO,CAAC,GAAR,CAAY,YAAZ,IA7CC,OAAW,CAAA,MA6CxC,GA7C6B,OAAW,CAAA,MAAX,CA8ClB,OAAO,CAAC,GAAR,CAAY,YA9CM,CA6C7B,GA7C6B,OAAW,CAAA,MAAX,CA+ClB,SAHb;;AAKA,IAAI,OAAO,CAAC,GAAR,CAAY,YAAZ,IAAwB,CAAK,MAAjC,EAAyC;AACvC,EAAA,OAAO,CAAC,IAAR,CAAY,qEAAZ;AAGD;;AAED,IAAI,mBAAJ;;AAEA,IAAI,MAAM,KAzDqB,OAAW,CAAA,MAAX,CAyDT,OAAtB,EAA+B;AAC7B,EAAA,mBAAmB,GAzDO,UAAc,CAAA,OAyDxC;AACD,CAFD,MAEO,IAAI,MAAM,KA3Dc,OAAW,CAAA,MAAX,CA2DF,MAAtB,EAA8B;AACnC,EAAA,mBAAmB,GA1DM,SAAa,CAAA,OA0DtC;AACD,CAFM,MAEA,IAAI,MAAM,KA7Dc,OAAW,CAAA,MAAX,CA6DF,MAAtB,EAA8B;AACnC,EAAA,mBAAmB,GA3DM,SAAa,CAAA,OA2DtC;AACD,CAFM,MAEA;AACL,EAAA,mBAAmB,GA5DS,YAAgB,CAAA,OA4D5C;AACD;;AAGM,MAAM,QAAQ,GAAG,IAAI,aAAJ,CAAiB,CA/DhB,OAAW,CAAA,OA+DK,EAAgB,mBAAhB,CAAjB,CAAjB;QAAM,Q,GAAA,Q","sourcesContent":["import { TARGET, SpanId } from '../shared'\nimport reportToConsole from './to-console'\nimport reportToZipkin from './to-zipkin'\nimport reportToJaeger from './to-jaeger'\nimport reportToTelemetry from './to-telemetry'\nimport reportToJson from './to-json'\n\ntype Reporter = {\n  flushAll: () => Promise<void> | void\n  report: (\n    spanName: string,\n    duration: number,\n    timestamp: number,\n    id: SpanId,\n    parentId?: SpanId,\n    attrs?: Object\n  ) => void\n}\n\nclass MultiReporter implements Reporter {\n  private reporters: Reporter[] = []\n\n  constructor(reporters: Reporter[]) {\n    this.reporters = reporters\n  }\n\n  async flushAll() {\n    await Promise.all(this.reporters.map((reporter) => reporter.flushAll()))\n  }\n\n  report(\n    spanName: string,\n    duration: number,\n    timestamp: number,\n    id: SpanId,\n    parentId?: SpanId,\n    attrs?: Object\n  ) {\n    this.reporters.forEach((reporter) =>\n      reporter.report(spanName, duration, timestamp, id, parentId, attrs)\n    )\n  }\n}\n\nconst target =\n  process.env.TRACE_TARGET && process.env.TRACE_TARGET in TARGET\n    ? TARGET[process.env.TRACE_TARGET as TARGET]\n    : TARGET.TELEMETRY\n\nif (process.env.TRACE_TARGET && !target) {\n  console.info(\n    'For TRACE_TARGET, please specify one of: CONSOLE, ZIPKIN, TELEMETRY'\n  )\n}\n\nlet traceTargetReporter: Reporter\n\nif (target === TARGET.CONSOLE) {\n  traceTargetReporter = reportToConsole\n} else if (target === TARGET.ZIPKIN) {\n  traceTargetReporter = reportToZipkin\n} else if (target === TARGET.JAEGER) {\n  traceTargetReporter = reportToJaeger\n} else {\n  traceTargetReporter = reportToTelemetry\n}\n\n// JSON is always reported to allow for diagnostics\nexport const reporter = new MultiReporter([reportToJson, traceTargetReporter])\n"]},"metadata":{},"sourceType":"script"}