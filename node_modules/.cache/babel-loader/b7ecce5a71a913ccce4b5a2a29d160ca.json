{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.route = void 0;\n\nvar _pathMatch = _interopRequireDefault(require(\"../shared/lib/router/utils/path-match\"));\n\nvar _normalizeTrailingSlash = require(\"../client/normalize-trailing-slash\");\n\nvar _normalizeLocalePath = require(\"../shared/lib/i18n/normalize-locale-path\");\n\nvar _prepareDestination = require(\"../shared/lib/router/utils/prepare-destination\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst route = (0, _pathMatch).default();\nexports.route = route;\nconst customRouteTypes = new Set(['rewrite', 'redirect', 'header']);\n\nfunction replaceBasePath(basePath, pathname) {\n  // If replace ends up replacing the full url it'll be `undefined`, meaning we have to default it to `/`\n  return pathname.replace(basePath, '') || '/';\n}\n\nclass Router {\n  constructor({\n    basePath = '',\n    headers = [],\n    fsRoutes = [],\n    rewrites = {\n      beforeFiles: [],\n      afterFiles: [],\n      fallback: []\n    },\n    redirects = [],\n    catchAllRoute,\n    dynamicRoutes = [],\n    pageChecker,\n    useFileSystemPublicRoutes,\n    locales = []\n  }) {\n    this.basePath = basePath;\n    this.headers = headers;\n    this.fsRoutes = fsRoutes;\n    this.rewrites = rewrites;\n    this.redirects = redirects;\n    this.pageChecker = pageChecker;\n    this.catchAllRoute = catchAllRoute;\n    this.dynamicRoutes = dynamicRoutes;\n    this.useFileSystemPublicRoutes = useFileSystemPublicRoutes;\n    this.locales = locales;\n  }\n\n  setDynamicRoutes(routes = []) {\n    this.dynamicRoutes = routes;\n  }\n\n  addFsRoute(fsRoute) {\n    this.fsRoutes.unshift(fsRoute);\n  }\n\n  async execute(req, res, parsedUrl) {\n    // memoize page check calls so we don't duplicate checks for pages\n    const pageChecks = {};\n\n    const memoizedPageChecker = async p => {\n      p = (0, _normalizeLocalePath).normalizeLocalePath(p, this.locales).pathname;\n\n      if (pageChecks[p]) {\n        return pageChecks[p];\n      }\n\n      const result = this.pageChecker(p);\n      pageChecks[p] = result;\n      return result;\n    };\n\n    let parsedUrlUpdated = parsedUrl;\n\n    const applyCheckTrue = async checkParsedUrl => {\n      const originalFsPathname = checkParsedUrl.pathname;\n      const fsPathname = replaceBasePath(this.basePath, originalFsPathname);\n\n      for (const fsRoute of this.fsRoutes) {\n        const fsParams = fsRoute.match(fsPathname);\n\n        if (fsParams) {\n          checkParsedUrl.pathname = fsPathname;\n          const fsResult = await fsRoute.fn(req, res, fsParams, checkParsedUrl);\n\n          if (fsResult.finished) {\n            return true;\n          }\n\n          checkParsedUrl.pathname = originalFsPathname;\n        }\n      }\n\n      let matchedPage = await memoizedPageChecker(fsPathname); // If we didn't match a page check dynamic routes\n\n      if (!matchedPage) {\n        const normalizedFsPathname = (0, _normalizeLocalePath).normalizeLocalePath(fsPathname, this.locales).pathname;\n\n        for (const dynamicRoute of this.dynamicRoutes) {\n          if (dynamicRoute.match(normalizedFsPathname)) {\n            matchedPage = true;\n          }\n        }\n      } // Matched a page or dynamic route so render it using catchAllRoute\n\n\n      if (matchedPage) {\n        const pageParams = this.catchAllRoute.match(checkParsedUrl.pathname);\n        checkParsedUrl.pathname = fsPathname;\n        checkParsedUrl.query._nextBubbleNoFallback = '1';\n        const result = await this.catchAllRoute.fn(req, res, pageParams, checkParsedUrl);\n        return result.finished;\n      }\n    };\n    /*\n    Desired routes order\n    - headers\n    - redirects\n    - Check filesystem (including pages), if nothing found continue\n    - User rewrites (checking filesystem and pages each match)\n    */\n\n\n    const allRoutes = [...this.headers, ...this.redirects, ...this.rewrites.beforeFiles, ...this.fsRoutes, // We only check the catch-all route if public page routes hasn't been\n    // disabled\n    ...(this.useFileSystemPublicRoutes ? [{\n      type: 'route',\n      name: 'page checker',\n      requireBasePath: false,\n      match: route('/:path*'),\n      fn: async (checkerReq, checkerRes, params, parsedCheckerUrl) => {\n        let {\n          pathname\n        } = parsedCheckerUrl;\n        pathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname || '/');\n\n        if (!pathname) {\n          return {\n            finished: false\n          };\n        }\n\n        if (await memoizedPageChecker(pathname)) {\n          return this.catchAllRoute.fn(checkerReq, checkerRes, params, parsedCheckerUrl);\n        }\n\n        return {\n          finished: false\n        };\n      }\n    }] : []), ...this.rewrites.afterFiles, ...(this.rewrites.fallback.length ? [{\n      type: 'route',\n      name: 'dynamic route/page check',\n      requireBasePath: false,\n      match: route('/:path*'),\n      fn: async (_checkerReq, _checkerRes, _params, parsedCheckerUrl) => {\n        return {\n          finished: await applyCheckTrue(parsedCheckerUrl)\n        };\n      }\n    }, ...this.rewrites.fallback] : []), // We only check the catch-all route if public page routes hasn't been\n    // disabled\n    ...(this.useFileSystemPublicRoutes ? [this.catchAllRoute] : [])];\n    const originallyHadBasePath = !this.basePath || req._nextHadBasePath;\n\n    for (const testRoute of allRoutes) {\n      // if basePath is being used, the basePath will still be included\n      // in the pathname here to allow custom-routes to require containing\n      // it or not, filesystem routes and pages must always include the basePath\n      // if it is set\n      let currentPathname = parsedUrlUpdated.pathname;\n      const originalPathname = currentPathname;\n      const requireBasePath = testRoute.requireBasePath !== false;\n      const isCustomRoute = customRouteTypes.has(testRoute.type);\n      const isPublicFolderCatchall = testRoute.name === 'public folder catchall';\n      const keepBasePath = isCustomRoute || isPublicFolderCatchall;\n      const keepLocale = isCustomRoute;\n      const currentPathnameNoBasePath = replaceBasePath(this.basePath, currentPathname);\n\n      if (!keepBasePath) {\n        currentPathname = currentPathnameNoBasePath;\n      }\n\n      const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(currentPathnameNoBasePath, this.locales);\n      const activeBasePath = keepBasePath ? this.basePath : '';\n\n      if (keepLocale) {\n        if (!testRoute.internal && parsedUrl.query.__nextLocale && !localePathResult.detectedLocale) {\n          currentPathname = `${activeBasePath}/${parsedUrl.query.__nextLocale}${currentPathnameNoBasePath === '/' ? '' : currentPathnameNoBasePath}`;\n        }\n\n        if (req.__nextHadTrailingSlash && !currentPathname.endsWith('/')) {\n          currentPathname += '/';\n        }\n      } else {\n        currentPathname = `${req._nextHadBasePath ? activeBasePath : ''}${activeBasePath && localePathResult.pathname === '/' ? '' : localePathResult.pathname}`;\n      }\n\n      let newParams = testRoute.match(currentPathname);\n\n      if (testRoute.has && newParams) {\n        const hasParams = (0, _prepareDestination).matchHas(req, testRoute.has, parsedUrlUpdated.query);\n\n        if (hasParams) {\n          Object.assign(newParams, hasParams);\n        } else {\n          newParams = false;\n        }\n      } // Check if the match function matched\n\n\n      if (newParams) {\n        // since we require basePath be present for non-custom-routes we\n        // 404 here when we matched an fs route\n        if (!keepBasePath) {\n          if (!originallyHadBasePath && !req._nextDidRewrite) {\n            if (requireBasePath) {\n              // consider this a non-match so the 404 renders\n              return false;\n            }\n\n            continue;\n          }\n\n          parsedUrlUpdated.pathname = currentPathname;\n        }\n\n        const result = await testRoute.fn(req, res, newParams, parsedUrlUpdated); // The response was handled\n\n        if (result.finished) {\n          return true;\n        } // since the fs route didn't match we need to re-add the basePath\n        // to continue checking rewrites with the basePath present\n\n\n        if (!keepBasePath) {\n          parsedUrlUpdated.pathname = originalPathname;\n        }\n\n        if (result.pathname) {\n          parsedUrlUpdated.pathname = result.pathname;\n        }\n\n        if (result.query) {\n          parsedUrlUpdated.query = { ...parsedUrlUpdated.query,\n            ...result.query\n          };\n        } // check filesystem\n\n\n        if (testRoute.check === true) {\n          if (await applyCheckTrue(parsedUrlUpdated)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n}\n\nexports.default = Router;","map":{"version":3,"sources":["../../server/router.ts"],"names":[],"mappings":"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","sourcesContent":["import { IncomingMessage, ServerResponse } from 'http'\nimport { UrlWithParsedQuery } from 'url'\n\nimport pathMatch from '../shared/lib/router/utils/path-match'\nimport { removePathTrailingSlash } from '../client/normalize-trailing-slash'\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\nimport { RouteHas } from '../lib/load-custom-routes'\nimport { matchHas } from '../shared/lib/router/utils/prepare-destination'\n\nexport const route = pathMatch()\n\nexport type Params = { [param: string]: any }\n\nexport type RouteMatch = (pathname: string | null | undefined) => false | Params\n\ntype RouteResult = {\n  finished: boolean\n  pathname?: string\n  query?: { [k: string]: string }\n}\n\nexport type Route = {\n  match: RouteMatch\n  has?: RouteHas[]\n  type: string\n  check?: boolean\n  statusCode?: number\n  name: string\n  requireBasePath?: false\n  internal?: true\n  fn: (\n    req: IncomingMessage,\n    res: ServerResponse,\n    params: Params,\n    parsedUrl: UrlWithParsedQuery\n  ) => Promise<RouteResult> | RouteResult\n}\n\nexport type DynamicRoutes = Array<{ page: string; match: RouteMatch }>\n\nexport type PageChecker = (pathname: string) => Promise<boolean>\n\nconst customRouteTypes = new Set(['rewrite', 'redirect', 'header'])\n\nfunction replaceBasePath(basePath: string, pathname: string) {\n  // If replace ends up replacing the full url it'll be `undefined`, meaning we have to default it to `/`\n  return pathname!.replace(basePath, '') || '/'\n}\n\nexport default class Router {\n  basePath: string\n  headers: Route[]\n  fsRoutes: Route[]\n  redirects: Route[]\n  rewrites: {\n    beforeFiles: Route[]\n    afterFiles: Route[]\n    fallback: Route[]\n  }\n  catchAllRoute: Route\n  pageChecker: PageChecker\n  dynamicRoutes: DynamicRoutes\n  useFileSystemPublicRoutes: boolean\n  locales: string[]\n\n  constructor({\n    basePath = '',\n    headers = [],\n    fsRoutes = [],\n    rewrites = {\n      beforeFiles: [],\n      afterFiles: [],\n      fallback: [],\n    },\n    redirects = [],\n    catchAllRoute,\n    dynamicRoutes = [],\n    pageChecker,\n    useFileSystemPublicRoutes,\n    locales = [],\n  }: {\n    basePath: string\n    headers: Route[]\n    fsRoutes: Route[]\n    rewrites: {\n      beforeFiles: Route[]\n      afterFiles: Route[]\n      fallback: Route[]\n    }\n    redirects: Route[]\n    catchAllRoute: Route\n    dynamicRoutes: DynamicRoutes | undefined\n    pageChecker: PageChecker\n    useFileSystemPublicRoutes: boolean\n    locales: string[]\n  }) {\n    this.basePath = basePath\n    this.headers = headers\n    this.fsRoutes = fsRoutes\n    this.rewrites = rewrites\n    this.redirects = redirects\n    this.pageChecker = pageChecker\n    this.catchAllRoute = catchAllRoute\n    this.dynamicRoutes = dynamicRoutes\n    this.useFileSystemPublicRoutes = useFileSystemPublicRoutes\n    this.locales = locales\n  }\n\n  setDynamicRoutes(routes: DynamicRoutes = []) {\n    this.dynamicRoutes = routes\n  }\n\n  addFsRoute(fsRoute: Route) {\n    this.fsRoutes.unshift(fsRoute)\n  }\n\n  async execute(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<boolean> {\n    // memoize page check calls so we don't duplicate checks for pages\n    const pageChecks: { [name: string]: Promise<boolean> } = {}\n    const memoizedPageChecker = async (p: string): Promise<boolean> => {\n      p = normalizeLocalePath(p, this.locales).pathname\n\n      if (pageChecks[p]) {\n        return pageChecks[p]\n      }\n      const result = this.pageChecker(p)\n      pageChecks[p] = result\n      return result\n    }\n\n    let parsedUrlUpdated = parsedUrl\n\n    const applyCheckTrue = async (checkParsedUrl: UrlWithParsedQuery) => {\n      const originalFsPathname = checkParsedUrl.pathname\n      const fsPathname = replaceBasePath(this.basePath, originalFsPathname!)\n\n      for (const fsRoute of this.fsRoutes) {\n        const fsParams = fsRoute.match(fsPathname)\n\n        if (fsParams) {\n          checkParsedUrl.pathname = fsPathname\n\n          const fsResult = await fsRoute.fn(req, res, fsParams, checkParsedUrl)\n\n          if (fsResult.finished) {\n            return true\n          }\n\n          checkParsedUrl.pathname = originalFsPathname\n        }\n      }\n      let matchedPage = await memoizedPageChecker(fsPathname)\n\n      // If we didn't match a page check dynamic routes\n      if (!matchedPage) {\n        const normalizedFsPathname = normalizeLocalePath(\n          fsPathname,\n          this.locales\n        ).pathname\n\n        for (const dynamicRoute of this.dynamicRoutes) {\n          if (dynamicRoute.match(normalizedFsPathname)) {\n            matchedPage = true\n          }\n        }\n      }\n\n      // Matched a page or dynamic route so render it using catchAllRoute\n      if (matchedPage) {\n        const pageParams = this.catchAllRoute.match(checkParsedUrl.pathname)\n        checkParsedUrl.pathname = fsPathname\n        checkParsedUrl.query._nextBubbleNoFallback = '1'\n\n        const result = await this.catchAllRoute.fn(\n          req,\n          res,\n          pageParams as Params,\n          checkParsedUrl\n        )\n        return result.finished\n      }\n    }\n\n    /*\n      Desired routes order\n      - headers\n      - redirects\n      - Check filesystem (including pages), if nothing found continue\n      - User rewrites (checking filesystem and pages each match)\n    */\n\n    const allRoutes = [\n      ...this.headers,\n      ...this.redirects,\n      ...this.rewrites.beforeFiles,\n      ...this.fsRoutes,\n      // We only check the catch-all route if public page routes hasn't been\n      // disabled\n      ...(this.useFileSystemPublicRoutes\n        ? [\n            {\n              type: 'route',\n              name: 'page checker',\n              requireBasePath: false,\n              match: route('/:path*'),\n              fn: async (checkerReq, checkerRes, params, parsedCheckerUrl) => {\n                let { pathname } = parsedCheckerUrl\n                pathname = removePathTrailingSlash(pathname || '/')\n\n                if (!pathname) {\n                  return { finished: false }\n                }\n\n                if (await memoizedPageChecker(pathname)) {\n                  return this.catchAllRoute.fn(\n                    checkerReq,\n                    checkerRes,\n                    params,\n                    parsedCheckerUrl\n                  )\n                }\n                return { finished: false }\n              },\n            } as Route,\n          ]\n        : []),\n      ...this.rewrites.afterFiles,\n      ...(this.rewrites.fallback.length\n        ? [\n            {\n              type: 'route',\n              name: 'dynamic route/page check',\n              requireBasePath: false,\n              match: route('/:path*'),\n              fn: async (\n                _checkerReq,\n                _checkerRes,\n                _params,\n                parsedCheckerUrl\n              ) => {\n                return {\n                  finished: await applyCheckTrue(parsedCheckerUrl),\n                }\n              },\n            } as Route,\n            ...this.rewrites.fallback,\n          ]\n        : []),\n\n      // We only check the catch-all route if public page routes hasn't been\n      // disabled\n      ...(this.useFileSystemPublicRoutes ? [this.catchAllRoute] : []),\n    ]\n    const originallyHadBasePath =\n      !this.basePath || (req as any)._nextHadBasePath\n\n    for (const testRoute of allRoutes) {\n      // if basePath is being used, the basePath will still be included\n      // in the pathname here to allow custom-routes to require containing\n      // it or not, filesystem routes and pages must always include the basePath\n      // if it is set\n      let currentPathname = parsedUrlUpdated.pathname as string\n      const originalPathname = currentPathname\n      const requireBasePath = testRoute.requireBasePath !== false\n      const isCustomRoute = customRouteTypes.has(testRoute.type)\n      const isPublicFolderCatchall = testRoute.name === 'public folder catchall'\n      const keepBasePath = isCustomRoute || isPublicFolderCatchall\n      const keepLocale = isCustomRoute\n\n      const currentPathnameNoBasePath = replaceBasePath(\n        this.basePath,\n        currentPathname\n      )\n\n      if (!keepBasePath) {\n        currentPathname = currentPathnameNoBasePath\n      }\n\n      const localePathResult = normalizeLocalePath(\n        currentPathnameNoBasePath,\n        this.locales\n      )\n      const activeBasePath = keepBasePath ? this.basePath : ''\n\n      if (keepLocale) {\n        if (\n          !testRoute.internal &&\n          parsedUrl.query.__nextLocale &&\n          !localePathResult.detectedLocale\n        ) {\n          currentPathname = `${activeBasePath}/${parsedUrl.query.__nextLocale}${\n            currentPathnameNoBasePath === '/' ? '' : currentPathnameNoBasePath\n          }`\n        }\n\n        if (\n          (req as any).__nextHadTrailingSlash &&\n          !currentPathname.endsWith('/')\n        ) {\n          currentPathname += '/'\n        }\n      } else {\n        currentPathname = `${\n          (req as any)._nextHadBasePath ? activeBasePath : ''\n        }${\n          activeBasePath && localePathResult.pathname === '/'\n            ? ''\n            : localePathResult.pathname\n        }`\n      }\n\n      let newParams = testRoute.match(currentPathname)\n\n      if (testRoute.has && newParams) {\n        const hasParams = matchHas(req, testRoute.has, parsedUrlUpdated.query)\n\n        if (hasParams) {\n          Object.assign(newParams, hasParams)\n        } else {\n          newParams = false\n        }\n      }\n\n      // Check if the match function matched\n      if (newParams) {\n        // since we require basePath be present for non-custom-routes we\n        // 404 here when we matched an fs route\n        if (!keepBasePath) {\n          if (!originallyHadBasePath && !(req as any)._nextDidRewrite) {\n            if (requireBasePath) {\n              // consider this a non-match so the 404 renders\n              return false\n            }\n            // page checker occurs before rewrites so we need to continue\n            // to check those since they don't always require basePath\n            continue\n          }\n\n          parsedUrlUpdated.pathname = currentPathname\n        }\n\n        const result = await testRoute.fn(req, res, newParams, parsedUrlUpdated)\n\n        // The response was handled\n        if (result.finished) {\n          return true\n        }\n\n        // since the fs route didn't match we need to re-add the basePath\n        // to continue checking rewrites with the basePath present\n        if (!keepBasePath) {\n          parsedUrlUpdated.pathname = originalPathname\n        }\n\n        if (result.pathname) {\n          parsedUrlUpdated.pathname = result.pathname\n        }\n\n        if (result.query) {\n          parsedUrlUpdated.query = {\n            ...parsedUrlUpdated.query,\n            ...result.query,\n          }\n        }\n\n        // check filesystem\n        if (testRoute.check === true) {\n          if (await applyCheckTrue(parsedUrlUpdated)) {\n            return true\n          }\n        }\n      }\n    }\n    return false\n  }\n}\n"]},"metadata":{},"sourceType":"script"}