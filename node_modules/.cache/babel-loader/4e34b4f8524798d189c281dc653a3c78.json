{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flushAllTraces = exports.trace = exports.SpanStatus = void 0;\n\nvar _crypto = require(\"crypto\");\n\nvar _report = require(\"./report\");\n\nconst NUM_OF_MICROSEC_IN_SEC = BigInt('1000');\n\nconst getId = () => (0, _crypto).randomBytes(8).toString('hex');\n\nvar SpanStatus;\nexports.SpanStatus = SpanStatus;\n\n(function (SpanStatus1) {\n  SpanStatus1[SpanStatus1[\"Started\"] = 0] = \"Started\";\n  SpanStatus1[SpanStatus1[\"Stopped\"] = 1] = \"Stopped\";\n})(SpanStatus || (exports.SpanStatus = SpanStatus = {}));\n\nclass Span {\n  constructor(name1, parentId, attrs1) {\n    this.name = name1;\n    this.parentId = parentId;\n    this.duration = null;\n    this.attrs = attrs1 ? { ...attrs1\n    } : {};\n    this.status = SpanStatus.Started;\n    this.id = getId();\n    this._start = process.hrtime.bigint();\n  } // Durations are reported as microseconds. This gives 1000x the precision\n  // of something like Date.now(), which reports in milliseconds.\n  // Additionally, ~285 years can be safely represented as microseconds as\n  // a float64 in both JSON and JavaScript.\n\n\n  stop() {\n    const end = process.hrtime.bigint();\n    const duration = (end - this._start) / NUM_OF_MICROSEC_IN_SEC;\n    this.status = SpanStatus.Stopped;\n\n    if (duration > Number.MAX_SAFE_INTEGER) {\n      throw new Error(`Duration is too long to express as float64: ${duration}`);\n    }\n\n    const timestamp = this._start / NUM_OF_MICROSEC_IN_SEC;\n\n    _report.reporter.report(this.name, Number(duration), Number(timestamp), this.id, this.parentId, this.attrs);\n  }\n\n  traceChild(name, attrs) {\n    return new Span(name, this.id, attrs);\n  }\n\n  setAttribute(key, value) {\n    this.attrs[key] = String(value);\n  }\n\n  traceFn(fn) {\n    try {\n      return fn();\n    } finally {\n      this.stop();\n    }\n  }\n\n  async traceAsyncFn(fn) {\n    try {\n      return await fn();\n    } finally {\n      this.stop();\n    }\n  }\n\n}\n\nexports.Span = Span;\n\nconst trace = (name2, parentId1, attrs2) => {\n  return new Span(name2, parentId1, attrs2);\n};\n\nexports.trace = trace;\n\nconst flushAllTraces = () => _report.reporter.flushAll();\n\nexports.flushAllTraces = flushAllTraces;","map":{"version":3,"sources":["../../../telemetry/trace/trace.ts"],"names":[],"mappings":";;;;;;;AAA4B,IAAA,OAAQ,GAAA,OAAA,CAAA,QAAA,CAAR;;AAEH,IAAA,OAAU,GAAA,OAAA,CAAA,UAAA,CAAV;;AAEzB,MAAM,sBAAsB,GAAG,MAAM,CAAA,MAAA,CAArC;;AAEA,MAAM,KAAK,GAAA,MAAA,CAAA,GANiB,OAMjB,EANyB,WAMzB,CAAqB,CAArB,EAAwB,QAAxB,CAAgC,KAAhC,CAAX;;;;;WAIY,W,EAAU;AAAV,EAAA,WAAU,CAAV,WAAU,CAAA,SAAA,CAAV,GACV,CADoB,CAAV,GACV,SADU;AAAA,EAAA,WAAU,CAAV,WAAU,CAAA,SAAA,CAAV,GAEV,CAFoB,CAAV,GAEV,SAFU;GAAA,UAAU,KAAA,OAAA,CAAA,UAAA,GAAV,UAAU,GAAA,EAAA,C;;MAKT,I,CAAI;cAUH,K,EAAc,Q,EAAmB,M,EAAgB;SACtD,I,GAAO,K;SACP,Q,GAAW,Q;SACX,Q,GAAW,I;SACX,K,GAAQ,MAAK,GAAA,E,GAAQ;AAAR,KAAA,G;SACb,M,GAAS,UAAU,CAAC,O;SACpB,E,GAAK,KAAK,E;SACV,M,GAAS,OAAO,CAAC,MAAR,CAAe,MAAf,E;AACf,GAlBc,CAoBf;AACA;AACA;AACA;;;AACA,EAAA,IAAI,GAAG;AACL,UAAM,GAAG,GAAW,OAAO,CAAC,MAAR,CAAe,MAAf,EAApB;AACA,UAAM,QAAQ,GAAA,CAAI,GAAG,GAAA,KAAQ,MAAf,IAAyB,sBAAvC;SACK,M,GAAS,UAAU,CAAC,O;;AACzB,QAAI,QAAQ,GAAG,MAAM,CAAC,gBAAtB,EAAwC;AACtC,YAAM,IAAI,KAAJ,CAAW,+CAA8C,QAAQ,EAAjE,CAAN;AACD;;AACD,UAAM,SAAS,GAAA,KAAQ,MAAR,GAAiB,sBAAhC;;AA5CqB,IAAA,OAAU,CAAA,QAAV,CA6CZ,MA7CY,CA6CN,KACR,IA9Cc,EA+CnB,MAAM,CAAC,QAAD,CA/Ca,EAgDnB,MAAM,CAAC,SAAD,CAhDa,EAgDH,KACX,EAjDc,EAiDZ,KACF,QAlDc,EAkDN,KACR,KAnDc;AAqDtB;;AAED,EAAA,UAAU,CAAC,IAAD,EAAe,KAAf,EAA+B;WAChC,IAAI,IAAJ,CAAS,IAAT,EAAa,KAAO,EAApB,EAAwB,KAAxB,C;AACR;;AAED,EAAA,YAAY,CAAC,GAAD,EAAc,KAAd,EAA0B;SAC/B,K,CAAM,G,IAAO,MAAM,CAAC,KAAD,C;AACzB;;AAED,EAAA,OAAO,CAAC,EAAD,EAAU;QACX;aACK,EAAE,E;AACV,K,SAAS;WACH,I;AACN;AACF;;AAEiB,QAAZ,YAAY,CAAI,EAAJ,EAA0C;QACtD;mBACW,EAAE,E;AAChB,K,SAAS;WACH,I;AACN;AACF;;AAhEc;;QAAJ,I,GAAA,I;;AAmEN,MAAM,KAAK,GAAA,CAAI,KAAJ,EAAkB,SAAlB,EAAqC,MAArC,KAAwD;SACjE,IAAI,IAAJ,CAAS,KAAT,EAAe,SAAf,EAAyB,MAAzB,C;AACR,CAFM;;QAAM,K,GAAA,K;;AAIN,MAAM,cAAc,GAAA,MApFF,OAAU,CAAA,QAAV,CAoFoB,QApFpB,EAoFlB;;QAAM,c,GAAA,c","sourcesContent":["import { randomBytes } from 'crypto'\nimport { SpanId } from './shared'\nimport { reporter } from './report'\n\nconst NUM_OF_MICROSEC_IN_SEC = BigInt('1000')\n\nconst getId = () => randomBytes(8).toString('hex')\n\n// eslint typescript has a bug with TS enums\n/* eslint-disable no-shadow */\nexport enum SpanStatus {\n  Started,\n  Stopped,\n}\n\nexport class Span {\n  name: string\n  id: SpanId\n  parentId?: SpanId\n  duration: number | null\n  attrs: { [key: string]: any }\n  status: SpanStatus\n\n  _start: bigint\n\n  constructor(name: string, parentId?: SpanId, attrs?: Object) {\n    this.name = name\n    this.parentId = parentId\n    this.duration = null\n    this.attrs = attrs ? { ...attrs } : {}\n    this.status = SpanStatus.Started\n    this.id = getId()\n    this._start = process.hrtime.bigint()\n  }\n\n  // Durations are reported as microseconds. This gives 1000x the precision\n  // of something like Date.now(), which reports in milliseconds.\n  // Additionally, ~285 years can be safely represented as microseconds as\n  // a float64 in both JSON and JavaScript.\n  stop() {\n    const end: bigint = process.hrtime.bigint()\n    const duration = (end - this._start) / NUM_OF_MICROSEC_IN_SEC\n    this.status = SpanStatus.Stopped\n    if (duration > Number.MAX_SAFE_INTEGER) {\n      throw new Error(`Duration is too long to express as float64: ${duration}`)\n    }\n    const timestamp = this._start / NUM_OF_MICROSEC_IN_SEC\n    reporter.report(\n      this.name,\n      Number(duration),\n      Number(timestamp),\n      this.id,\n      this.parentId,\n      this.attrs\n    )\n  }\n\n  traceChild(name: string, attrs?: Object) {\n    return new Span(name, this.id, attrs)\n  }\n\n  setAttribute(key: string, value: any) {\n    this.attrs[key] = String(value)\n  }\n\n  traceFn(fn: any) {\n    try {\n      return fn()\n    } finally {\n      this.stop()\n    }\n  }\n\n  async traceAsyncFn<T>(fn: () => T | Promise<T>): Promise<T> {\n    try {\n      return await fn()\n    } finally {\n      this.stop()\n    }\n  }\n}\n\nexport const trace = (name: string, parentId?: SpanId, attrs?: Object) => {\n  return new Span(name, parentId, attrs)\n}\n\nexport const flushAllTraces = () => reporter.flushAll()\n"]},"metadata":{},"sourceType":"script"}