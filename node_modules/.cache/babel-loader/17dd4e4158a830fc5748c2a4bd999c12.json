{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _escapeStringRegexp = _interopRequireDefault(require(\"next/dist/compiled/escape-string-regexp\"));\n\nvar _nodeHtmlParser = require(\"node-html-parser\");\n\nvar _constants = require(\"./constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // const MIDDLEWARE_TIME_BUDGET = parseInt(process.env.__POST_PROCESS_MIDDLEWARE_TIME_BUDGET || '', 10) || 10\n\n\nconst MAXIMUM_IMAGE_PRELOADS = 2;\nconst IMAGE_PRELOAD_SIZE_THRESHOLD = 2500;\nconst middlewareRegistry = [];\n\nfunction registerPostProcessor(name, middleware, condition) {\n  middlewareRegistry.push({\n    name,\n    middleware,\n    condition: condition || null\n  });\n}\n\nasync function processHTML(html, data, options) {\n  // Don't parse unless there's at least one processor middleware\n  if (!middlewareRegistry[0]) {\n    return html;\n  }\n\n  const root = (0, _nodeHtmlParser).parse(html);\n  let document = html; // Calls the middleware, with some instrumentation and logging\n\n  async function callMiddleWare(middleware) {\n    // let timer = Date.now()\n    const inspectData = middleware.inspect(root, data);\n    document = await middleware.mutate(document, inspectData, data); // timer = Date.now() - timer\n    // if (timer > MIDDLEWARE_TIME_BUDGET) {\n    // TODO: Identify a correct upper limit for the postprocess step\n    // and add a warning to disable the optimization\n    // }\n\n    return;\n  }\n\n  for (let i = 0; i < middlewareRegistry.length; i++) {\n    let middleware = middlewareRegistry[i];\n\n    if (!middleware.condition || middleware.condition(options)) {\n      await callMiddleWare(middlewareRegistry[i].middleware);\n    }\n  }\n\n  return document;\n}\n\nclass FontOptimizerMiddleware {\n  inspect(originalDom, options) {\n    if (!options.getFontDefinition) {\n      return;\n    }\n\n    const fontDefinitions = []; // collecting all the requested font definitions\n\n    originalDom.querySelectorAll('link').filter(tag => tag.getAttribute('rel') === 'stylesheet' && tag.hasAttribute('data-href') && _constants.OPTIMIZED_FONT_PROVIDERS.some(({\n      url\n    }) => {\n      const dataHref = tag.getAttribute('data-href');\n      return dataHref ? dataHref.startsWith(url) : false;\n    })).forEach(element => {\n      const url = element.getAttribute('data-href');\n      const nonce = element.getAttribute('nonce');\n\n      if (url) {\n        fontDefinitions.push([url, nonce]);\n      }\n    });\n    return fontDefinitions;\n  }\n\n  constructor() {\n    this.mutate = async (markup, fontDefinitions, options) => {\n      let result = markup;\n      let preconnectUrls = new Set();\n\n      if (!options.getFontDefinition) {\n        return markup;\n      }\n\n      fontDefinitions.forEach(fontDef => {\n        const [url, nonce] = fontDef;\n        const fallBackLinkTag = `<link rel=\"stylesheet\" href=\"${url}\"/>`;\n\n        if (result.indexOf(`<style data-href=\"${url}\">`) > -1 || result.indexOf(fallBackLinkTag) > -1) {\n          // The font is already optimized and probably the response is cached\n          return;\n        }\n\n        const fontContent = options.getFontDefinition ? options.getFontDefinition(url) : null;\n\n        if (!fontContent) {\n          /**\n          * In case of unreachable font definitions, fallback to default link tag.\n          */\n          result = result.replace('</head>', `${fallBackLinkTag}</head>`);\n        } else {\n          const nonceStr = nonce ? ` nonce=\"${nonce}\"` : '';\n          result = result.replace('</head>', `<style data-href=\"${url}\"${nonceStr}>${fontContent}</style></head>`);\n\n          const provider = _constants.OPTIMIZED_FONT_PROVIDERS.find(p => url.startsWith(p.url));\n\n          if (provider) {\n            preconnectUrls.add(provider.preconnect);\n          }\n        }\n      });\n      let preconnectTag = '';\n      preconnectUrls.forEach(url => {\n        preconnectTag += `<link rel=\"preconnect\" href=\"${url}\" crossorigin />`;\n      });\n      result = result.replace('<meta name=\"next-font-preconnect\"/>', preconnectTag);\n      return result;\n    };\n  }\n\n}\n\nclass ImageOptimizerMiddleware {\n  inspect(originalDom) {\n    const imgPreloads = [];\n    const imgElements = originalDom.querySelectorAll('img');\n    let eligibleImages = [];\n\n    for (let i = 0; i < imgElements.length; i++) {\n      if (isImgEligible(imgElements[i])) {\n        eligibleImages.push(imgElements[i]);\n      }\n\n      if (eligibleImages.length >= MAXIMUM_IMAGE_PRELOADS) {\n        break;\n      }\n    }\n\n    for (const imgEl of eligibleImages) {\n      const src = imgEl.getAttribute('src');\n\n      if (src) {\n        imgPreloads.push(src);\n      }\n    }\n\n    return imgPreloads;\n  }\n\n  constructor() {\n    this.mutate = async (markup, imgPreloads) => {\n      let result = markup;\n      let imagePreloadTags = imgPreloads.filter(imgHref => !preloadTagAlreadyExists(markup, imgHref)).reduce((acc, imgHref) => acc + `<link rel=\"preload\" href=\"${imgHref}\" as=\"image\"/>`, '');\n      return result.replace('<meta name=\"next-image-preload\"/>', imagePreloadTags);\n    };\n  }\n\n}\n\nfunction isImgEligible(imgElement) {\n  let imgSrc = imgElement.getAttribute('src');\n  return !!imgSrc && sourceIsSupportedType(imgSrc) && imageIsNotTooSmall(imgElement) && imageIsNotHidden(imgElement);\n}\n\nfunction preloadTagAlreadyExists(html, href) {\n  const escapedHref = (0, _escapeStringRegexp).default(href);\n  const regex = new RegExp(`<link[^>]*href[^>]*${escapedHref}`);\n  return html.match(regex);\n}\n\nfunction imageIsNotTooSmall(imgElement) {\n  // Skip images without both height and width--we don't know enough to say if\n  // they are too small\n  if (!(imgElement.hasAttribute('height') && imgElement.hasAttribute('width'))) {\n    return true;\n  }\n\n  try {\n    const heightAttr = imgElement.getAttribute('height');\n    const widthAttr = imgElement.getAttribute('width');\n\n    if (!heightAttr || !widthAttr) {\n      return true;\n    }\n\n    if (parseInt(heightAttr) * parseInt(widthAttr) <= IMAGE_PRELOAD_SIZE_THRESHOLD) {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  return true;\n} // Traverse up the dom from each image to see if it or any of it's\n// ancestors have the hidden attribute.\n\n\nfunction imageIsNotHidden(imgElement) {\n  let activeElement = imgElement;\n\n  while (activeElement.parentNode) {\n    if (activeElement.hasAttribute('hidden')) {\n      return false;\n    }\n\n    activeElement = activeElement.parentNode;\n  }\n\n  return true;\n} // Currently only filters out svg images--could be made more specific in the future.\n\n\nfunction sourceIsSupportedType(imgSrc) {\n  return !imgSrc.includes('.svg');\n} // Initialization\n\n\nregisterPostProcessor('Inline-Fonts', new FontOptimizerMiddleware(), // Using process.env because passing Experimental flag through loader is not possible.\n// @ts-ignore\noptions => options.optimizeFonts || process.env.__NEXT_OPTIMIZE_FONTS);\nregisterPostProcessor('Preload Images', new ImageOptimizerMiddleware(), // @ts-ignore\noptions => options.optimizeImages || process.env.__NEXT_OPTIMIZE_IMAGES);\nvar _default = processHTML;\nexports.default = _default;","map":{"version":3,"sources":["../../../shared/lib/post-process.ts"],"names":[],"mappings":"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","sourcesContent":["import escapeRegexp from 'next/dist/compiled/escape-string-regexp'\nimport { parse, HTMLElement } from 'node-html-parser'\nimport { OPTIMIZED_FONT_PROVIDERS } from './constants'\n\n// const MIDDLEWARE_TIME_BUDGET = parseInt(process.env.__POST_PROCESS_MIDDLEWARE_TIME_BUDGET || '', 10) || 10\nconst MAXIMUM_IMAGE_PRELOADS = 2\nconst IMAGE_PRELOAD_SIZE_THRESHOLD = 2500\n\ntype postProcessOptions = {\n  optimizeFonts: boolean\n  optimizeImages: boolean\n}\n\ntype renderOptions = {\n  getFontDefinition?: (url: string) => string\n}\ninterface PostProcessMiddleware {\n  inspect: (originalDom: HTMLElement, options: renderOptions) => any\n  mutate: (markup: string, data: any, options: renderOptions) => Promise<string>\n}\n\ntype middlewareSignature = {\n  name: string\n  middleware: PostProcessMiddleware\n  condition: ((options: postProcessOptions) => boolean) | null\n}\n\nconst middlewareRegistry: Array<middlewareSignature> = []\n\nfunction registerPostProcessor(\n  name: string,\n  middleware: PostProcessMiddleware,\n  condition?: (options: postProcessOptions) => boolean\n) {\n  middlewareRegistry.push({ name, middleware, condition: condition || null })\n}\n\nasync function processHTML(\n  html: string,\n  data: renderOptions,\n  options: postProcessOptions\n): Promise<string> {\n  // Don't parse unless there's at least one processor middleware\n  if (!middlewareRegistry[0]) {\n    return html\n  }\n  const root: HTMLElement = parse(html)\n  let document = html\n  // Calls the middleware, with some instrumentation and logging\n  async function callMiddleWare(middleware: PostProcessMiddleware) {\n    // let timer = Date.now()\n    const inspectData = middleware.inspect(root, data)\n    document = await middleware.mutate(document, inspectData, data)\n    // timer = Date.now() - timer\n    // if (timer > MIDDLEWARE_TIME_BUDGET) {\n    // TODO: Identify a correct upper limit for the postprocess step\n    // and add a warning to disable the optimization\n    // }\n    return\n  }\n\n  for (let i = 0; i < middlewareRegistry.length; i++) {\n    let middleware = middlewareRegistry[i]\n    if (!middleware.condition || middleware.condition(options)) {\n      await callMiddleWare(middlewareRegistry[i].middleware)\n    }\n  }\n\n  return document\n}\n\nclass FontOptimizerMiddleware implements PostProcessMiddleware {\n  inspect(originalDom: HTMLElement, options: renderOptions) {\n    if (!options.getFontDefinition) {\n      return\n    }\n    const fontDefinitions: (string | undefined)[][] = []\n    // collecting all the requested font definitions\n    originalDom\n      .querySelectorAll('link')\n      .filter(\n        (tag: HTMLElement) =>\n          tag.getAttribute('rel') === 'stylesheet' &&\n          tag.hasAttribute('data-href') &&\n          OPTIMIZED_FONT_PROVIDERS.some(({ url }) => {\n            const dataHref = tag.getAttribute('data-href')\n            return dataHref ? dataHref.startsWith(url) : false\n          })\n      )\n      .forEach((element: HTMLElement) => {\n        const url = element.getAttribute('data-href')\n        const nonce = element.getAttribute('nonce')\n\n        if (url) {\n          fontDefinitions.push([url, nonce])\n        }\n      })\n\n    return fontDefinitions\n  }\n  mutate = async (\n    markup: string,\n    fontDefinitions: string[][],\n    options: renderOptions\n  ) => {\n    let result = markup\n    let preconnectUrls = new Set<string>()\n\n    if (!options.getFontDefinition) {\n      return markup\n    }\n\n    fontDefinitions.forEach((fontDef) => {\n      const [url, nonce] = fontDef\n      const fallBackLinkTag = `<link rel=\"stylesheet\" href=\"${url}\"/>`\n      if (\n        result.indexOf(`<style data-href=\"${url}\">`) > -1 ||\n        result.indexOf(fallBackLinkTag) > -1\n      ) {\n        // The font is already optimized and probably the response is cached\n        return\n      }\n      const fontContent = options.getFontDefinition\n        ? options.getFontDefinition(url as string)\n        : null\n      if (!fontContent) {\n        /**\n         * In case of unreachable font definitions, fallback to default link tag.\n         */\n        result = result.replace('</head>', `${fallBackLinkTag}</head>`)\n      } else {\n        const nonceStr = nonce ? ` nonce=\"${nonce}\"` : ''\n        result = result.replace(\n          '</head>',\n          `<style data-href=\"${url}\"${nonceStr}>${fontContent}</style></head>`\n        )\n\n        const provider = OPTIMIZED_FONT_PROVIDERS.find((p) =>\n          url.startsWith(p.url)\n        )\n\n        if (provider) {\n          preconnectUrls.add(provider.preconnect)\n        }\n      }\n    })\n\n    let preconnectTag = ''\n    preconnectUrls.forEach((url) => {\n      preconnectTag += `<link rel=\"preconnect\" href=\"${url}\" crossorigin />`\n    })\n\n    result = result.replace(\n      '<meta name=\"next-font-preconnect\"/>',\n      preconnectTag\n    )\n\n    return result\n  }\n}\n\nclass ImageOptimizerMiddleware implements PostProcessMiddleware {\n  inspect(originalDom: HTMLElement) {\n    const imgPreloads = []\n    const imgElements = originalDom.querySelectorAll('img')\n    let eligibleImages: Array<HTMLElement> = []\n    for (let i = 0; i < imgElements.length; i++) {\n      if (isImgEligible(imgElements[i])) {\n        eligibleImages.push(imgElements[i])\n      }\n      if (eligibleImages.length >= MAXIMUM_IMAGE_PRELOADS) {\n        break\n      }\n    }\n\n    for (const imgEl of eligibleImages) {\n      const src = imgEl.getAttribute('src')\n      if (src) {\n        imgPreloads.push(src)\n      }\n    }\n\n    return imgPreloads\n  }\n  mutate = async (markup: string, imgPreloads: string[]) => {\n    let result = markup\n    let imagePreloadTags = imgPreloads\n      .filter((imgHref) => !preloadTagAlreadyExists(markup, imgHref))\n      .reduce(\n        (acc, imgHref) =>\n          acc + `<link rel=\"preload\" href=\"${imgHref}\" as=\"image\"/>`,\n        ''\n      )\n    return result.replace('<meta name=\"next-image-preload\"/>', imagePreloadTags)\n  }\n}\n\nfunction isImgEligible(imgElement: HTMLElement): boolean {\n  let imgSrc = imgElement.getAttribute('src')\n  return (\n    !!imgSrc &&\n    sourceIsSupportedType(imgSrc) &&\n    imageIsNotTooSmall(imgElement) &&\n    imageIsNotHidden(imgElement)\n  )\n}\n\nfunction preloadTagAlreadyExists(html: string, href: string) {\n  const escapedHref = escapeRegexp(href)\n  const regex = new RegExp(`<link[^>]*href[^>]*${escapedHref}`)\n  return html.match(regex)\n}\n\nfunction imageIsNotTooSmall(imgElement: HTMLElement): boolean {\n  // Skip images without both height and width--we don't know enough to say if\n  // they are too small\n  if (\n    !(imgElement.hasAttribute('height') && imgElement.hasAttribute('width'))\n  ) {\n    return true\n  }\n  try {\n    const heightAttr = imgElement.getAttribute('height')\n    const widthAttr = imgElement.getAttribute('width')\n    if (!heightAttr || !widthAttr) {\n      return true\n    }\n\n    if (\n      parseInt(heightAttr) * parseInt(widthAttr) <=\n      IMAGE_PRELOAD_SIZE_THRESHOLD\n    ) {\n      return false\n    }\n  } catch (err) {\n    return true\n  }\n  return true\n}\n\n// Traverse up the dom from each image to see if it or any of it's\n// ancestors have the hidden attribute.\nfunction imageIsNotHidden(imgElement: HTMLElement): boolean {\n  let activeElement = imgElement\n  while (activeElement.parentNode) {\n    if (activeElement.hasAttribute('hidden')) {\n      return false\n    }\n    activeElement = activeElement.parentNode as HTMLElement\n  }\n  return true\n}\n\n// Currently only filters out svg images--could be made more specific in the future.\nfunction sourceIsSupportedType(imgSrc: string): boolean {\n  return !imgSrc.includes('.svg')\n}\n\n// Initialization\nregisterPostProcessor(\n  'Inline-Fonts',\n  new FontOptimizerMiddleware(),\n  // Using process.env because passing Experimental flag through loader is not possible.\n  // @ts-ignore\n  (options) => options.optimizeFonts || process.env.__NEXT_OPTIMIZE_FONTS\n)\n\nregisterPostProcessor(\n  'Preload Images',\n  new ImageOptimizerMiddleware(),\n  // @ts-ignore\n  (options) => options.optimizeImages || process.env.__NEXT_OPTIMIZE_IMAGES\n)\n\nexport default processHTML\n"]},"metadata":{},"sourceType":"script"}