{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFontDefinitionFromNetwork = getFontDefinitionFromNetwork;\nexports.getFontDefinitionFromManifest = getFontDefinitionFromManifest;\n\nvar Log = _interopRequireWildcard(require(\"../build/output/log\"));\n\nvar _constants = require(\"../shared/lib/constants\");\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nconst https = require('https');\n\nconst CHROME_UA = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36';\nconst IE_UA = 'Mozilla/5.0 (Windows NT 10.0; Trident/7.0; rv:11.0) like Gecko';\n\nfunction isGoogleFont(url) {\n  return url.startsWith(_constants.GOOGLE_FONT_PROVIDER);\n}\n\nfunction getFontForUA(url, UA) {\n  return new Promise((resolve, reject) => {\n    let rawData = '';\n    https.get(url, {\n      headers: {\n        'user-agent': UA\n      }\n    }, res => {\n      res.on('data', chunk => {\n        rawData += chunk;\n      });\n      res.on('end', () => {\n        resolve(rawData.toString('utf8'));\n      });\n    }).on('error', e => {\n      reject(e);\n    });\n  });\n}\n\nasync function getFontDefinitionFromNetwork(url) {\n  let result = '';\n  /**\n  * The order of IE -> Chrome is important, other wise chrome starts loading woff1.\n  * CSS cascading 🤷‍♂️.\n  */\n\n  try {\n    if (isGoogleFont(url)) {\n      result += await getFontForUA(url, IE_UA);\n    }\n\n    result += await getFontForUA(url, CHROME_UA);\n  } catch (e) {\n    Log.warn(`Failed to download the stylesheet for ${url}. Skipped optimizing this font.`);\n    return '';\n  }\n\n  return result;\n}\n\nfunction getFontDefinitionFromManifest(url, manifest) {\n  var ref;\n  return ((ref = manifest.find(font => {\n    if (font && font.url === url) {\n      return true;\n    }\n\n    return false;\n  })) === null || ref === void 0 ? void 0 : ref.content) || '';\n}","map":{"version":3,"sources":["../../server/font-utils.ts"],"names":[],"mappings":";;;;;QA2CsB,4B,GAAA,4B;QAuBN,6B,GAAA,6B;;AAlEJ,IAAA,GAAG,GAAA,uBAAA,CAAA,OAAA,CAAA,qBAAA,CAAA,CAAH;;AACyB,IAAA,UAAyB,GAAA,OAAA,CAAA,yBAAA,CAAzB;;;;;;;;;;;;;;;;;;;;;;;;;;;AACrC,MAAM,KAAK,GAAG,OAAO,CAAA,OAAA,CAArB;;AAEA,MAAM,SAAS,GAAA,0HAAf;AAEA,MAAM,KAAK,GAAA,gEAAX;;SAOS,Y,CAAa,G,EAAsB;SACnC,GAAG,CAAC,UAAJ,CAb4B,UAAyB,CAAA,oBAarD,C;AACR;;SAEQ,Y,CAAa,G,EAAa,E,EAA6B;SACvD,IAAI,OAAJ,CAAW,CAAE,OAAF,EAAW,MAAX,KAAsB;AACtC,QAAI,OAAO,GAAA,EAAX;AACA,IAAA,KAAK,CACF,GADH,CAEI,GAFJ,EAEO;AAED,MAAA,OAAO,EAAA;AACL,sBAAc;AADT;AAFN,KAFP,EAQK,G,IAAa;AACZ,MAAA,GAAG,CAAC,EAAJ,CAAM,MAAN,EAAgB,KAAH,IAAkB;AAC7B,QAAA,OAAO,IAAI,KAAX;AACD,OAFD;AAGA,MAAA,GAAG,CAAC,EAAJ,CAAM,KAAN,EAAY,MAAQ;AAClB,QAAA,OAAO,CAAC,OAAO,CAAC,QAAR,CAAgB,MAAhB,CAAD,CAAP;AACD,OAFD;AAGD,KAfL,EAiBG,EAjBH,CAiBK,OAjBL,EAiBgB,CAAH,IAAgB;AACzB,MAAA,MAAM,CAAC,CAAD,CAAN;AACD,KAnBH;AAoBD,GAtBM,C;AAuBR;;eAEqB,4B,CACpB,G,EACiB;AACjB,MAAI,MAAM,GAAA,EAAV;AACA;;;AAAA;;AAGG,MACC;AACF,QAAI,YAAY,CAAC,GAAD,CAAhB,EAAuB;AACrB,MAAA,MAAM,IAAA,MAAU,YAAY,CAAC,GAAD,EAAM,KAAN,CAA5B;AACD;;AACD,IAAA,MAAM,IAAA,MAAU,YAAY,CAAC,GAAD,EAAM,SAAN,CAA5B;AACD,GANE,CAMF,OAAQ,CAAR,EAAW;AAxDF,IAAA,GAAG,CAyDP,IAzDI,CA0DL,yCAAwC,GAAI,iCA1DvC;;AA6DT;;SAEM,M;AACR;;SAEe,6B,CACd,G,EACA,Q,EACQ;MAEN,G;WAAA,GAKE,GALF,QAAQ,CAAC,IAAT,CAAe,IAAF,IAAW;AACtB,QAAI,IAAI,IAAI,IAAI,CAAC,GAAL,KAAa,GAAzB,EAA8B;aACrB,I;AACR;;WACM,K;AACR,GALD,C,MAKC,I,IALD,GAKE,KAAA,KALF,C,GAKW,KALX,C,GAAA,GAKE,CAAE,O,KAAO,E;AAEd","sourcesContent":["import * as Log from '../build/output/log'\nimport { GOOGLE_FONT_PROVIDER } from '../shared/lib/constants'\nconst https = require('https')\n\nconst CHROME_UA =\n  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36'\nconst IE_UA = 'Mozilla/5.0 (Windows NT 10.0; Trident/7.0; rv:11.0) like Gecko'\n\nexport type FontManifest = Array<{\n  url: string\n  content: string\n}>\n\nfunction isGoogleFont(url: string): boolean {\n  return url.startsWith(GOOGLE_FONT_PROVIDER)\n}\n\nfunction getFontForUA(url: string, UA: string): Promise<String> {\n  return new Promise((resolve, reject) => {\n    let rawData: any = ''\n    https\n      .get(\n        url,\n        {\n          headers: {\n            'user-agent': UA,\n          },\n        },\n        (res: any) => {\n          res.on('data', (chunk: any) => {\n            rawData += chunk\n          })\n          res.on('end', () => {\n            resolve(rawData.toString('utf8'))\n          })\n        }\n      )\n      .on('error', (e: Error) => {\n        reject(e)\n      })\n  })\n}\n\nexport async function getFontDefinitionFromNetwork(\n  url: string\n): Promise<string> {\n  let result = ''\n  /**\n   * The order of IE -> Chrome is important, other wise chrome starts loading woff1.\n   * CSS cascading 🤷‍♂️.\n   */\n  try {\n    if (isGoogleFont(url)) {\n      result += await getFontForUA(url, IE_UA)\n    }\n    result += await getFontForUA(url, CHROME_UA)\n  } catch (e) {\n    Log.warn(\n      `Failed to download the stylesheet for ${url}. Skipped optimizing this font.`\n    )\n    return ''\n  }\n\n  return result\n}\n\nexport function getFontDefinitionFromManifest(\n  url: string,\n  manifest: FontManifest\n): string {\n  return (\n    manifest.find((font) => {\n      if (font && font.url === url) {\n        return true\n      }\n      return false\n    })?.content || ''\n  )\n}\n"]},"metadata":{},"sourceType":"script"}