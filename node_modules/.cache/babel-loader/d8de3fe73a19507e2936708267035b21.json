{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.processBuffer = processBuffer;\n\nvar _jestWorker = require(\"jest-worker\");\n\nvar path = _interopRequireWildcard(require(\"path\"));\n\nvar _utils = require(\"../../../shared/lib/utils\");\n\nvar _os = require(\"os\");\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nconst getWorker = (0, _utils).execOnce(() => new _jestWorker.Worker(path.resolve(__dirname, 'impl'), {\n  enableWorkerThreads: true,\n  // There will be at most 6 workers needed since each worker will take\n  // at least 1 operation type.\n  numWorkers: Math.max(1, Math.min((0, _os).cpus().length - 1, 6)),\n  computeWorkerKey: method => method\n}));\n\nasync function processBuffer(buffer, operations, encoding, quality) {\n  const worker = getWorker();\n  let imageData = await worker.decodeBuffer(buffer);\n\n  for (const operation of operations) {\n    if (operation.type === 'rotate') {\n      imageData = await worker.rotate(imageData, operation.numRotations);\n    } else if (operation.type === 'resize') {\n      if (operation.width && imageData.width && imageData.width > operation.width) {\n        imageData = await worker.resize({\n          image: imageData,\n          width: operation.width\n        });\n      } else if (operation.height && imageData.height && imageData.height > operation.height) {\n        imageData = await worker.resize({\n          image: imageData,\n          height: operation.height\n        });\n      }\n    }\n  }\n\n  switch (encoding) {\n    case 'jpeg':\n      return Buffer.from(await worker.encodeJpeg(imageData, {\n        quality\n      }));\n\n    case 'webp':\n      return Buffer.from(await worker.encodeWebp(imageData, {\n        quality\n      }));\n\n    case 'png':\n      return Buffer.from(await worker.encodePng(imageData));\n\n    default:\n      throw Error(`Unsupported encoding format`);\n  }\n}","map":{"version":3,"sources":["../../../../server/lib/squoosh/main.ts"],"names":[],"mappings":";;;;;QA0BsB,a,GAAA,a;;AA1BC,IAAA,WAAa,GAAA,OAAA,CAAA,aAAA,CAAb;;AACX,IAAA,IAAI,GAAA,uBAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAJ;;AACa,IAAA,MAA2B,GAAA,OAAA,CAAA,2BAAA,CAA3B;;AACJ,IAAA,GAAI,GAAA,OAAA,CAAA,IAAA,CAAJ;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYrB,MAAM,SAAS,GAAA,CAAA,GAbU,MAaV,EAbqC,QAarC,CAbqC,MAehD,IAjBmB,WAAa,CAAA,MAiBhC,CAhBQ,IAAI,CAgBI,OAhBR,CAgBgB,SAhBhB,EAgByB,MAhBzB,CAgBR,EAAyC;AACvC,EAAA,mBAAmB,EAAE,IADkB;AAEvC;AACA;AACA,EAAA,UAAU,EAAE,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,GAAL,CAAQ,CAAA,GAlBjB,GAkBiB,EAlBb,IAkBa,GAAQ,MAAR,GAAiB,CAAzB,EAA4B,CAA5B,CAAZ,CAJ2B;AAKvC,EAAA,gBAAgB,EAAG,MAAH,IAAc;AALS,CAAzC,CAFW,CAAf;;eAWsB,a,CACpB,M,EACA,U,EACA,Q,EACA,O,EACiB;AACjB,QAAM,MAAM,GAA4B,SAAS,EAAjD;AAEA,MAAI,SAAS,GAAA,MAAS,MAAM,CAAC,YAAP,CAAoB,MAApB,CAAtB;;OACK,MAAM,S,IAAa,U,EAAY;AAClC,QAAI,SAAS,CAAC,IAAV,KAAc,QAAlB,EAAiC;AAC/B,MAAA,SAAS,GAAA,MAAS,MAAM,CAAC,MAAP,CAAc,SAAd,EAAyB,SAAS,CAAC,YAAnC,CAAlB;AACD,KAFD,MAEO,IAAI,SAAS,CAAC,IAAV,KAAc,QAAlB,EAAiC;AACtC,UACE,SAAS,CAAC,KAAV,IACA,SAAS,CAAC,KADV,IAEA,SAAS,CAAC,KAAV,GAAkB,SAAS,CAAC,KAH9B,EAIE;AACA,QAAA,SAAS,GAAA,MAAS,MAAM,CAAC,MAAP,CAAa;AAC7B,UAAA,KAAK,EAAE,SADsB;AAE7B,UAAA,KAAK,EAAE,SAAS,CAAC;AAFY,SAAb,CAAlB;AAID,OATD,MASO,IACL,SAAS,CAAC,MAAV,IACA,SAAS,CAAC,MADV,IAEA,SAAS,CAAC,MAAV,GAAmB,SAAS,CAAC,MAHxB,EAIL;AACA,QAAA,SAAS,GAAA,MAAS,MAAM,CAAC,MAAP,CAAa;AAC7B,UAAA,KAAK,EAAE,SADsB;AAE7B,UAAA,MAAM,EAAE,SAAS,CAAC;AAFW,SAAb,CAAlB;AAID;AACF;AACF;;UAEO,Q;SACD,M;aACI,MAAM,CAAC,IAAP,CAAW,MAAO,MAAM,CAAC,UAAP,CAAkB,SAAlB,EAA2B;AAAI,QAAA;AAAJ,OAA3B,CAAlB,C;;SACJ,M;aACI,MAAM,CAAC,IAAP,CAAW,MAAO,MAAM,CAAC,UAAP,CAAkB,SAAlB,EAA2B;AAAI,QAAA;AAAJ,OAA3B,CAAlB,C;;SACJ,K;aACI,MAAM,CAAC,IAAP,CAAW,MAAO,MAAM,CAAC,SAAP,CAAiB,SAAjB,CAAlB,C;;;AAEP,YAAM,KAAK,CAAE,6BAAF,CAAX;;AAEL","sourcesContent":["import { Worker } from 'jest-worker'\nimport * as path from 'path'\nimport { execOnce } from '../../../shared/lib/utils'\nimport { cpus } from 'os'\n\ntype RotateOperation = {\n  type: 'rotate'\n  numRotations: number\n}\ntype ResizeOperation = {\n  type: 'resize'\n} & ({ width: number; height?: never } | { height: number; width?: never })\nexport type Operation = RotateOperation | ResizeOperation\nexport type Encoding = 'jpeg' | 'png' | 'webp'\n\nconst getWorker = execOnce(\n  () =>\n    new Worker(path.resolve(__dirname, 'impl'), {\n      enableWorkerThreads: true,\n      // There will be at most 6 workers needed since each worker will take\n      // at least 1 operation type.\n      numWorkers: Math.max(1, Math.min(cpus().length - 1, 6)),\n      computeWorkerKey: (method) => method,\n    })\n)\n\nexport async function processBuffer(\n  buffer: Buffer,\n  operations: Operation[],\n  encoding: Encoding,\n  quality: number\n): Promise<Buffer> {\n  const worker: typeof import('./impl') = getWorker() as any\n\n  let imageData = await worker.decodeBuffer(buffer)\n  for (const operation of operations) {\n    if (operation.type === 'rotate') {\n      imageData = await worker.rotate(imageData, operation.numRotations)\n    } else if (operation.type === 'resize') {\n      if (\n        operation.width &&\n        imageData.width &&\n        imageData.width > operation.width\n      ) {\n        imageData = await worker.resize({\n          image: imageData,\n          width: operation.width,\n        })\n      } else if (\n        operation.height &&\n        imageData.height &&\n        imageData.height > operation.height\n      ) {\n        imageData = await worker.resize({\n          image: imageData,\n          height: operation.height,\n        })\n      }\n    }\n  }\n\n  switch (encoding) {\n    case 'jpeg':\n      return Buffer.from(await worker.encodeJpeg(imageData, { quality }))\n    case 'webp':\n      return Buffer.from(await worker.encodeWebp(imageData, { quality }))\n    case 'png':\n      return Buffer.from(await worker.encodePng(imageData))\n    default:\n      throw Error(`Unsupported encoding format`)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}