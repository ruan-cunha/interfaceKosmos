{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRedirectStatus = getRedirectStatus;\nexports.normalizeRouteRegex = normalizeRouteRegex;\nexports.modifyRouteRegex = modifyRouteRegex;\nexports.default = loadCustomRoutes;\nexports.allowedStatusCodes = void 0;\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _url = require(\"url\");\n\nvar pathToRegexp = _interopRequireWildcard(require(\"next/dist/compiled/path-to-regexp\"));\n\nvar _escapeStringRegexp = _interopRequireDefault(require(\"next/dist/compiled/escape-string-regexp\"));\n\nvar _constants = require(\"../shared/lib/constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nconst allowedStatusCodes = new Set([301, 302, 303, 307, 308]);\nexports.allowedStatusCodes = allowedStatusCodes;\nconst allowedHasTypes = new Set(['header', 'cookie', 'query', 'host']);\nconst namedGroupsRegex = /\\(\\?<([a-zA-Z][a-zA-Z0-9]*)>/g;\n\nfunction getRedirectStatus(route) {\n  return route.statusCode || (route.permanent ? _constants.PERMANENT_REDIRECT_STATUS : _constants.TEMPORARY_REDIRECT_STATUS);\n}\n\nfunction normalizeRouteRegex(regex) {\n  // clean up un-necessary escaping from regex.source which turns / into \\\\/\n  return regex.replace(/\\\\\\//g, '/');\n}\n\nfunction modifyRouteRegex(regex, restrictedPaths) {\n  if (restrictedPaths) {\n    regex = regex.replace(/\\^/, `^(?!${restrictedPaths.map(path => path.replace(/\\//g, '\\\\/')).join('|')})`);\n  }\n\n  regex = regex.replace(/\\$$/, '(?:\\\\/)?$');\n  return regex;\n}\n\nfunction checkRedirect(route) {\n  const invalidParts = [];\n  let hadInvalidStatus = false;\n\n  if (route.statusCode && !allowedStatusCodes.has(route.statusCode)) {\n    hadInvalidStatus = true;\n    invalidParts.push(`\\`statusCode\\` is not undefined or valid statusCode`);\n  }\n\n  if (typeof route.permanent !== 'boolean' && !route.statusCode) {\n    invalidParts.push(`\\`permanent\\` is not set to \\`true\\` or \\`false\\``);\n  }\n\n  return {\n    invalidParts,\n    hadInvalidStatus\n  };\n}\n\nfunction checkHeader(route) {\n  const invalidParts = [];\n\n  if (!Array.isArray(route.headers)) {\n    invalidParts.push('`headers` field must be an array');\n  } else if (route.headers.length === 0) {\n    invalidParts.push('`headers` field cannot be empty');\n  } else {\n    for (const header of route.headers) {\n      if (!header || typeof header !== 'object') {\n        invalidParts.push(\"`headers` items must be object with { key: '', value: '' }\");\n        break;\n      }\n\n      if (typeof header.key !== 'string') {\n        invalidParts.push('`key` in header item must be string');\n        break;\n      }\n\n      if (typeof header.value !== 'string') {\n        invalidParts.push('`value` in header item must be string');\n        break;\n      }\n    }\n  }\n\n  return invalidParts;\n}\n\nfunction tryParsePath(route, handleUrl) {\n  const result = {};\n  let routePath = route;\n\n  try {\n    if (handleUrl) {\n      const parsedDestination = (0, _url).parse(route, true);\n      routePath = `${parsedDestination.pathname}${parsedDestination.hash || ''}`;\n    } // Make sure we can parse the source properly\n\n\n    result.tokens = pathToRegexp.parse(routePath);\n    const regex = pathToRegexp.tokensToRegexp(result.tokens);\n    result.regexStr = regex.source;\n  } catch (err) {\n    // If there is an error show our error link but still show original error or a formatted one if we can\n    const errMatches = err.message.match(/at (\\d{0,})/);\n\n    if (errMatches) {\n      const position = parseInt(errMatches[1], 10);\n      console.error(`\\nError parsing \\`${route}\\` ` + `https://nextjs.org/docs/messages/invalid-route-source\\n` + `Reason: ${err.message}\\n\\n` + `  ${routePath}\\n` + `  ${new Array(position).fill(' ').join('')}^\\n`);\n    } else {\n      console.error(`\\nError parsing ${route} https://nextjs.org/docs/messages/invalid-route-source`, err);\n    }\n\n    result.error = true;\n  }\n\n  return result;\n}\n\nfunction checkCustomRoutes(routes, type) {\n  if (!Array.isArray(routes)) {\n    console.error(`Error: ${type}s must return an array, received ${typeof routes}.\\n` + `See here for more info: https://nextjs.org/docs/messages/routes-must-be-array`);\n    process.exit(1);\n  }\n\n  let numInvalidRoutes = 0;\n  let hadInvalidStatus = false;\n  let hadInvalidHas = false;\n  const allowedKeys = new Set(['source', 'basePath', 'locale', 'has']);\n\n  if (type === 'rewrite') {\n    allowedKeys.add('destination');\n  }\n\n  if (type === 'redirect') {\n    allowedKeys.add('statusCode');\n    allowedKeys.add('permanent');\n    allowedKeys.add('destination');\n  }\n\n  if (type === 'header') {\n    allowedKeys.add('headers');\n  }\n\n  for (const route of routes) {\n    if (!route || typeof route !== 'object') {\n      console.error(`The route ${JSON.stringify(route)} is not a valid object with \\`source\\` and \\`${type === 'header' ? 'headers' : 'destination'}\\``);\n      numInvalidRoutes++;\n      continue;\n    }\n\n    if (type === 'rewrite' && route.basePath === false && !(route.destination.startsWith('http://') || route.destination.startsWith('https://'))) {\n      console.error(`The route ${route.source} rewrites urls outside of the basePath. Please use a destination that starts with \\`http://\\` or \\`https://\\` https://nextjs.org/docs/messages/invalid-external-rewrite`);\n      numInvalidRoutes++;\n      continue;\n    }\n\n    const keys = Object.keys(route);\n    const invalidKeys = keys.filter(key => !allowedKeys.has(key));\n    const invalidParts = [];\n\n    if (typeof route.basePath !== 'undefined' && route.basePath !== false) {\n      invalidParts.push('`basePath` must be undefined or false');\n    }\n\n    if (typeof route.locale !== 'undefined' && route.locale !== false) {\n      invalidParts.push('`locale` must be undefined or false');\n    }\n\n    if (typeof route.has !== 'undefined' && !Array.isArray(route.has)) {\n      invalidParts.push('`has` must be undefined or valid has object');\n      hadInvalidHas = true;\n    } else if (route.has) {\n      const invalidHasItems = [];\n\n      for (const hasItem of route.has) {\n        let invalidHasParts = [];\n\n        if (!allowedHasTypes.has(hasItem.type)) {\n          invalidHasParts.push(`invalid type \"${hasItem.type}\"`);\n        }\n\n        if (typeof hasItem.key !== 'string' && hasItem.type !== 'host') {\n          invalidHasParts.push(`invalid key \"${hasItem.key}\"`);\n        }\n\n        if (typeof hasItem.value !== 'undefined' && typeof hasItem.value !== 'string') {\n          invalidHasParts.push(`invalid value \"${hasItem.value}\"`);\n        }\n\n        if (typeof hasItem.value === 'undefined' && hasItem.type === 'host') {\n          invalidHasParts.push(`value is required for \"host\" type`);\n        }\n\n        if (invalidHasParts.length > 0) {\n          invalidHasItems.push(`${invalidHasParts.join(', ')} for ${JSON.stringify(hasItem)}`);\n        }\n      }\n\n      if (invalidHasItems.length > 0) {\n        hadInvalidHas = true;\n        const itemStr = `item${invalidHasItems.length === 1 ? '' : 's'}`;\n        console.error(`Invalid \\`has\\` ${itemStr}:\\n` + invalidHasItems.join('\\n'));\n        console.error();\n        invalidParts.push(`invalid \\`has\\` ${itemStr} found`);\n      }\n    }\n\n    if (!route.source) {\n      invalidParts.push('`source` is missing');\n    } else if (typeof route.source !== 'string') {\n      invalidParts.push('`source` is not a string');\n    } else if (!route.source.startsWith('/')) {\n      invalidParts.push('`source` does not start with /');\n    }\n\n    if (type === 'header') {\n      invalidParts.push(...checkHeader(route));\n    } else {\n      let _route = route;\n\n      if (!_route.destination) {\n        invalidParts.push('`destination` is missing');\n      } else if (typeof _route.destination !== 'string') {\n        invalidParts.push('`destination` is not a string');\n      } else if (type === 'rewrite' && !_route.destination.match(/^(\\/|https:\\/\\/|http:\\/\\/)/)) {\n        invalidParts.push('`destination` does not start with `/`, `http://`, or `https://`');\n      }\n    }\n\n    if (type === 'redirect') {\n      const result = checkRedirect(route);\n      hadInvalidStatus = hadInvalidStatus || result.hadInvalidStatus;\n      invalidParts.push(...result.invalidParts);\n    }\n\n    let sourceTokens;\n\n    if (typeof route.source === 'string' && route.source.startsWith('/')) {\n      // only show parse error if we didn't already show error\n      // for not being a string\n      const {\n        tokens,\n        error,\n        regexStr\n      } = tryParsePath(route.source);\n\n      if (error) {\n        invalidParts.push('`source` parse failed');\n      }\n\n      if (regexStr && regexStr.length > 4096) {\n        invalidParts.push('`source` exceeds max built length of 4096');\n      }\n\n      sourceTokens = tokens;\n    }\n\n    const hasSegments = new Set();\n\n    if (route.has) {\n      for (const hasItem of route.has) {\n        if (!hasItem.value && hasItem.key) {\n          hasSegments.add(hasItem.key);\n        }\n\n        if (hasItem.value) {\n          for (const match of hasItem.value.matchAll(namedGroupsRegex)) {\n            if (match[1]) {\n              hasSegments.add(match[1]);\n            }\n          }\n\n          if (hasItem.type === 'host') {\n            hasSegments.add('host');\n          }\n        }\n      }\n    } // make sure no unnamed patterns are attempted to be used in the\n    // destination as this can cause confusion and is not allowed\n\n\n    if (typeof route.destination === 'string') {\n      if (route.destination.startsWith('/') && Array.isArray(sourceTokens)) {\n        const unnamedInDest = new Set();\n\n        for (const token of sourceTokens) {\n          if (typeof token === 'object' && typeof token.name === 'number') {\n            const unnamedIndex = new RegExp(`:${token.name}(?!\\\\d)`);\n\n            if (route.destination.match(unnamedIndex)) {\n              unnamedInDest.add(`:${token.name}`);\n            }\n          }\n        }\n\n        if (unnamedInDest.size > 0) {\n          invalidParts.push(`\\`destination\\` has unnamed params ${[...unnamedInDest].join(', ')}`);\n        } else {\n          const {\n            tokens: destTokens,\n            regexStr: destRegexStr,\n            error: destinationParseFailed\n          } = tryParsePath(route.destination, true);\n\n          if (destRegexStr && destRegexStr.length > 4096) {\n            invalidParts.push('`destination` exceeds max built length of 4096');\n          }\n\n          if (destinationParseFailed) {\n            invalidParts.push('`destination` parse failed');\n          } else {\n            const sourceSegments = new Set(sourceTokens.map(item => typeof item === 'object' && item.name).filter(Boolean));\n            const invalidDestSegments = new Set();\n\n            for (const token1 of destTokens) {\n              if (typeof token1 === 'object' && !sourceSegments.has(token1.name) && !hasSegments.has(token1.name)) {\n                invalidDestSegments.add(token1.name);\n              }\n            }\n\n            if (invalidDestSegments.size) {\n              invalidParts.push(`\\`destination\\` has segments not in \\`source\\` or \\`has\\` (${[...invalidDestSegments].join(', ')})`);\n            }\n          }\n        }\n      }\n    }\n\n    const hasInvalidKeys = invalidKeys.length > 0;\n    const hasInvalidParts = invalidParts.length > 0;\n\n    if (hasInvalidKeys || hasInvalidParts) {\n      console.error(`${invalidParts.join(', ')}${invalidKeys.length ? (hasInvalidParts ? ',' : '') + ` invalid field${invalidKeys.length === 1 ? '' : 's'}: ` + invalidKeys.join(',') : ''} for route ${JSON.stringify(route)}`);\n      console.error();\n      numInvalidRoutes++;\n    }\n  }\n\n  if (numInvalidRoutes > 0) {\n    if (hadInvalidStatus) {\n      console.error(`\\nValid redirect statusCode values are ${[...allowedStatusCodes].join(', ')}`);\n    }\n\n    if (hadInvalidHas) {\n      console.error(`\\nValid \\`has\\` object shape is ${JSON.stringify({\n        type: [...allowedHasTypes].join(', '),\n        key: 'the key to check for',\n        value: 'undefined or a value string to match against'\n      }, null, 2)}`);\n    }\n\n    console.error();\n    console.error(`Error: Invalid ${type}${numInvalidRoutes === 1 ? '' : 's'} found`);\n    process.exit(1);\n  }\n}\n\nfunction processRoutes(routes, config, type) {\n  const _routes = routes;\n  const newRoutes = [];\n  const defaultLocales = [];\n\n  if (config.i18n && type === 'redirect') {\n    var ref;\n\n    for (const item of ((ref = config.i18n) === null || ref === void 0 ? void 0 : ref.domains) || []) {\n      defaultLocales.push({\n        locale: item.defaultLocale,\n        base: `http${item.http ? '' : 's'}://${item.domain}`\n      });\n    }\n\n    defaultLocales.push({\n      locale: config.i18n.defaultLocale,\n      base: ''\n    });\n  }\n\n  for (const r of _routes) {\n    var ref;\n    const srcBasePath = config.basePath && r.basePath !== false ? config.basePath : '';\n    const isExternal = !((ref = r.destination) === null || ref === void 0 ? void 0 : ref.startsWith('/'));\n    const destBasePath = srcBasePath && !isExternal ? srcBasePath : '';\n\n    if (config.i18n && r.locale !== false) {\n      var ref1;\n\n      if (!isExternal) {\n        defaultLocales.forEach(item => {\n          let destination;\n\n          if (r.destination) {\n            destination = item.base ? `${item.base}${destBasePath}${r.destination}` : `${destBasePath}${r.destination}`;\n          }\n\n          newRoutes.push({ ...r,\n            destination,\n            source: `${srcBasePath}/${item.locale}${r.source}`\n          });\n        });\n      }\n\n      r.source = `/:nextInternalLocale(${config.i18n.locales.map(locale => (0, _escapeStringRegexp).default(locale)).join('|')})${r.source === '/' && !config.trailingSlash ? '' : r.source}`;\n\n      if (r.destination && ((ref1 = r.destination) === null || ref1 === void 0 ? void 0 : ref1.startsWith('/'))) {\n        r.destination = `/:nextInternalLocale${r.destination === '/' && !config.trailingSlash ? '' : r.destination}`;\n      }\n    }\n\n    r.source = `${srcBasePath}${r.source === '/' && srcBasePath ? '' : r.source}`;\n\n    if (r.destination) {\n      r.destination = `${destBasePath}${r.destination === '/' && destBasePath ? '' : r.destination}`;\n    }\n\n    newRoutes.push(r);\n  }\n\n  return newRoutes;\n}\n\nasync function loadRedirects(config) {\n  if (typeof config.redirects !== 'function') {\n    return [];\n  }\n\n  let redirects = await config.redirects(); // check before we process the routes and after to ensure\n  // they are still valid\n\n  checkCustomRoutes(redirects, 'redirect');\n  redirects = processRoutes(redirects, config, 'redirect');\n  checkCustomRoutes(redirects, 'redirect');\n  return redirects;\n}\n\nasync function loadRewrites(config) {\n  if (typeof config.rewrites !== 'function') {\n    return {\n      beforeFiles: [],\n      afterFiles: [],\n      fallback: []\n    };\n  }\n\n  const _rewrites = await config.rewrites();\n\n  let beforeFiles = [];\n  let afterFiles = [];\n  let fallback = [];\n\n  if (!Array.isArray(_rewrites) && typeof _rewrites === 'object' && Object.keys(_rewrites).every(key => key === 'beforeFiles' || key === 'afterFiles' || key === 'fallback')) {\n    beforeFiles = _rewrites.beforeFiles || [];\n    afterFiles = _rewrites.afterFiles || [];\n    fallback = _rewrites.fallback || [];\n  } else {\n    afterFiles = _rewrites;\n  } // check before we process the routes and after to ensure\n  // they are still valid\n\n\n  checkCustomRoutes(beforeFiles, 'rewrite');\n  checkCustomRoutes(afterFiles, 'rewrite');\n  checkCustomRoutes(fallback, 'rewrite');\n  beforeFiles = processRoutes(beforeFiles, config, 'rewrite');\n  afterFiles = processRoutes(afterFiles, config, 'rewrite');\n  fallback = processRoutes(fallback, config, 'rewrite');\n  checkCustomRoutes(beforeFiles, 'rewrite');\n  checkCustomRoutes(afterFiles, 'rewrite');\n  checkCustomRoutes(fallback, 'rewrite');\n  return {\n    beforeFiles,\n    afterFiles,\n    fallback\n  };\n}\n\nasync function loadHeaders(config) {\n  if (typeof config.headers !== 'function') {\n    return [];\n  }\n\n  let headers = await config.headers(); // check before we process the routes and after to ensure\n  // they are still valid\n\n  checkCustomRoutes(headers, 'header');\n  headers = processRoutes(headers, config, 'header');\n  checkCustomRoutes(headers, 'header');\n  return headers;\n}\n\nasync function loadCustomRoutes(config) {\n  const [headers, rewrites, redirects] = await Promise.all([loadHeaders(config), loadRewrites(config), loadRedirects(config)]);\n  const totalRewrites = rewrites.beforeFiles.length + rewrites.afterFiles.length + rewrites.fallback.length;\n  const totalRoutes = headers.length + redirects.length + totalRewrites;\n\n  if (totalRoutes > 1000) {\n    console.warn(_chalk.default.bold.yellow(`Warning: `) + `total number of custom routes exceeds 1000, this can reduce performance. Route counts:\\n` + `headers: ${headers.length}\\n` + `rewrites: ${totalRewrites}\\n` + `redirects: ${redirects.length}\\n` + `See more info: https://nextjs.org/docs/messages/max-custom-routes-reached`);\n  }\n\n  if (config.trailingSlash) {\n    redirects.unshift({\n      source: '/:file((?!\\\\.well-known(?:/.*)?)(?:[^/]+/)*[^/]+\\\\.\\\\w+)/',\n      destination: '/:file',\n      permanent: true,\n      locale: config.i18n ? false : undefined,\n      internal: true\n    }, {\n      source: '/:notfile((?!\\\\.well-known(?:/.*)?)(?:[^/]+/)*[^/\\\\.]+)',\n      destination: '/:notfile/',\n      permanent: true,\n      locale: config.i18n ? false : undefined,\n      internal: true\n    });\n\n    if (config.basePath) {\n      redirects.unshift({\n        source: config.basePath,\n        destination: config.basePath + '/',\n        permanent: true,\n        basePath: false,\n        locale: config.i18n ? false : undefined,\n        internal: true\n      });\n    }\n  } else {\n    redirects.unshift({\n      source: '/:path+/',\n      destination: '/:path+',\n      permanent: true,\n      locale: config.i18n ? false : undefined,\n      internal: true\n    });\n\n    if (config.basePath) {\n      redirects.unshift({\n        source: config.basePath + '/',\n        destination: config.basePath,\n        permanent: true,\n        basePath: false,\n        locale: config.i18n ? false : undefined,\n        internal: true\n      });\n    }\n  }\n\n  return {\n    headers,\n    rewrites,\n    redirects\n  };\n}","map":{"version":3,"sources":["../../lib/load-custom-routes.ts"],"names":[],"mappings":"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","sourcesContent":["import chalk from 'chalk'\nimport { parse as parseUrl } from 'url'\nimport { NextConfig } from '../server/config'\nimport * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\nimport escapeStringRegexp from 'next/dist/compiled/escape-string-regexp'\nimport {\n  PERMANENT_REDIRECT_STATUS,\n  TEMPORARY_REDIRECT_STATUS,\n} from '../shared/lib/constants'\n\nexport type RouteHas =\n  | {\n      type: 'header' | 'query' | 'cookie'\n      key: string\n      value?: string\n    }\n  | {\n      type: 'host'\n      key?: undefined\n      value: string\n    }\n\nexport type Rewrite = {\n  source: string\n  destination: string\n  basePath?: false\n  locale?: false\n  has?: RouteHas[]\n}\n\nexport type Header = {\n  source: string\n  basePath?: false\n  locale?: false\n  headers: Array<{ key: string; value: string }>\n  has?: RouteHas[]\n}\n\n// internal type used for validation (not user facing)\nexport type Redirect = {\n  source: string\n  destination: string\n  basePath?: false\n  locale?: false\n  has?: RouteHas[]\n  statusCode?: number\n  permanent?: boolean\n}\n\nexport const allowedStatusCodes = new Set([301, 302, 303, 307, 308])\nconst allowedHasTypes = new Set(['header', 'cookie', 'query', 'host'])\nconst namedGroupsRegex = /\\(\\?<([a-zA-Z][a-zA-Z0-9]*)>/g\n\nexport function getRedirectStatus(route: {\n  statusCode?: number\n  permanent?: boolean\n}): number {\n  return (\n    route.statusCode ||\n    (route.permanent ? PERMANENT_REDIRECT_STATUS : TEMPORARY_REDIRECT_STATUS)\n  )\n}\n\nexport function normalizeRouteRegex(regex: string) {\n  // clean up un-necessary escaping from regex.source which turns / into \\\\/\n  return regex.replace(/\\\\\\//g, '/')\n}\n\n// for redirects we restrict matching /_next and for all routes\n// we add an optional trailing slash at the end for easier\n// configuring between trailingSlash: true/false\nexport function modifyRouteRegex(regex: string, restrictedPaths?: string[]) {\n  if (restrictedPaths) {\n    regex = regex.replace(\n      /\\^/,\n      `^(?!${restrictedPaths\n        .map((path) => path.replace(/\\//g, '\\\\/'))\n        .join('|')})`\n    )\n  }\n  regex = regex.replace(/\\$$/, '(?:\\\\/)?$')\n  return regex\n}\n\nfunction checkRedirect(route: Redirect): {\n  invalidParts: string[]\n  hadInvalidStatus: boolean\n} {\n  const invalidParts: string[] = []\n  let hadInvalidStatus: boolean = false\n\n  if (route.statusCode && !allowedStatusCodes.has(route.statusCode)) {\n    hadInvalidStatus = true\n    invalidParts.push(`\\`statusCode\\` is not undefined or valid statusCode`)\n  }\n  if (typeof route.permanent !== 'boolean' && !route.statusCode) {\n    invalidParts.push(`\\`permanent\\` is not set to \\`true\\` or \\`false\\``)\n  }\n\n  return {\n    invalidParts,\n    hadInvalidStatus,\n  }\n}\n\nfunction checkHeader(route: Header): string[] {\n  const invalidParts: string[] = []\n\n  if (!Array.isArray(route.headers)) {\n    invalidParts.push('`headers` field must be an array')\n  } else if (route.headers.length === 0) {\n    invalidParts.push('`headers` field cannot be empty')\n  } else {\n    for (const header of route.headers) {\n      if (!header || typeof header !== 'object') {\n        invalidParts.push(\n          \"`headers` items must be object with { key: '', value: '' }\"\n        )\n        break\n      }\n      if (typeof header.key !== 'string') {\n        invalidParts.push('`key` in header item must be string')\n        break\n      }\n      if (typeof header.value !== 'string') {\n        invalidParts.push('`value` in header item must be string')\n        break\n      }\n    }\n  }\n  return invalidParts\n}\n\ntype ParseAttemptResult = {\n  error?: boolean\n  tokens?: pathToRegexp.Token[]\n  regexStr?: string\n}\n\nfunction tryParsePath(route: string, handleUrl?: boolean): ParseAttemptResult {\n  const result: ParseAttemptResult = {}\n  let routePath = route\n\n  try {\n    if (handleUrl) {\n      const parsedDestination = parseUrl(route, true)\n      routePath = `${parsedDestination.pathname!}${\n        parsedDestination.hash || ''\n      }`\n    }\n\n    // Make sure we can parse the source properly\n    result.tokens = pathToRegexp.parse(routePath)\n\n    const regex = pathToRegexp.tokensToRegexp(result.tokens)\n    result.regexStr = regex.source\n  } catch (err) {\n    // If there is an error show our error link but still show original error or a formatted one if we can\n    const errMatches = err.message.match(/at (\\d{0,})/)\n\n    if (errMatches) {\n      const position = parseInt(errMatches[1], 10)\n      console.error(\n        `\\nError parsing \\`${route}\\` ` +\n          `https://nextjs.org/docs/messages/invalid-route-source\\n` +\n          `Reason: ${err.message}\\n\\n` +\n          `  ${routePath}\\n` +\n          `  ${new Array(position).fill(' ').join('')}^\\n`\n      )\n    } else {\n      console.error(\n        `\\nError parsing ${route} https://nextjs.org/docs/messages/invalid-route-source`,\n        err\n      )\n    }\n    result.error = true\n  }\n\n  return result\n}\n\nexport type RouteType = 'rewrite' | 'redirect' | 'header'\n\nfunction checkCustomRoutes(\n  routes: Redirect[] | Header[] | Rewrite[],\n  type: RouteType\n): void {\n  if (!Array.isArray(routes)) {\n    console.error(\n      `Error: ${type}s must return an array, received ${typeof routes}.\\n` +\n        `See here for more info: https://nextjs.org/docs/messages/routes-must-be-array`\n    )\n    process.exit(1)\n  }\n\n  let numInvalidRoutes = 0\n  let hadInvalidStatus = false\n  let hadInvalidHas = false\n\n  const allowedKeys = new Set<string>(['source', 'basePath', 'locale', 'has'])\n\n  if (type === 'rewrite') {\n    allowedKeys.add('destination')\n  }\n  if (type === 'redirect') {\n    allowedKeys.add('statusCode')\n    allowedKeys.add('permanent')\n    allowedKeys.add('destination')\n  }\n  if (type === 'header') {\n    allowedKeys.add('headers')\n  }\n\n  for (const route of routes) {\n    if (!route || typeof route !== 'object') {\n      console.error(\n        `The route ${JSON.stringify(\n          route\n        )} is not a valid object with \\`source\\` and \\`${\n          type === 'header' ? 'headers' : 'destination'\n        }\\``\n      )\n      numInvalidRoutes++\n      continue\n    }\n\n    if (\n      type === 'rewrite' &&\n      (route as Rewrite).basePath === false &&\n      !(\n        (route as Rewrite).destination.startsWith('http://') ||\n        (route as Rewrite).destination.startsWith('https://')\n      )\n    ) {\n      console.error(\n        `The route ${\n          (route as Rewrite).source\n        } rewrites urls outside of the basePath. Please use a destination that starts with \\`http://\\` or \\`https://\\` https://nextjs.org/docs/messages/invalid-external-rewrite`\n      )\n      numInvalidRoutes++\n      continue\n    }\n\n    const keys = Object.keys(route)\n    const invalidKeys = keys.filter((key) => !allowedKeys.has(key))\n    const invalidParts: string[] = []\n\n    if (typeof route.basePath !== 'undefined' && route.basePath !== false) {\n      invalidParts.push('`basePath` must be undefined or false')\n    }\n\n    if (typeof route.locale !== 'undefined' && route.locale !== false) {\n      invalidParts.push('`locale` must be undefined or false')\n    }\n\n    if (typeof route.has !== 'undefined' && !Array.isArray(route.has)) {\n      invalidParts.push('`has` must be undefined or valid has object')\n      hadInvalidHas = true\n    } else if (route.has) {\n      const invalidHasItems = []\n\n      for (const hasItem of route.has) {\n        let invalidHasParts = []\n\n        if (!allowedHasTypes.has(hasItem.type)) {\n          invalidHasParts.push(`invalid type \"${hasItem.type}\"`)\n        }\n        if (typeof hasItem.key !== 'string' && hasItem.type !== 'host') {\n          invalidHasParts.push(`invalid key \"${hasItem.key}\"`)\n        }\n        if (\n          typeof hasItem.value !== 'undefined' &&\n          typeof hasItem.value !== 'string'\n        ) {\n          invalidHasParts.push(`invalid value \"${hasItem.value}\"`)\n        }\n        if (typeof hasItem.value === 'undefined' && hasItem.type === 'host') {\n          invalidHasParts.push(`value is required for \"host\" type`)\n        }\n\n        if (invalidHasParts.length > 0) {\n          invalidHasItems.push(\n            `${invalidHasParts.join(', ')} for ${JSON.stringify(hasItem)}`\n          )\n        }\n      }\n\n      if (invalidHasItems.length > 0) {\n        hadInvalidHas = true\n        const itemStr = `item${invalidHasItems.length === 1 ? '' : 's'}`\n\n        console.error(\n          `Invalid \\`has\\` ${itemStr}:\\n` + invalidHasItems.join('\\n')\n        )\n        console.error()\n        invalidParts.push(`invalid \\`has\\` ${itemStr} found`)\n      }\n    }\n\n    if (!route.source) {\n      invalidParts.push('`source` is missing')\n    } else if (typeof route.source !== 'string') {\n      invalidParts.push('`source` is not a string')\n    } else if (!route.source.startsWith('/')) {\n      invalidParts.push('`source` does not start with /')\n    }\n\n    if (type === 'header') {\n      invalidParts.push(...checkHeader(route as Header))\n    } else {\n      let _route = route as Rewrite | Redirect\n      if (!_route.destination) {\n        invalidParts.push('`destination` is missing')\n      } else if (typeof _route.destination !== 'string') {\n        invalidParts.push('`destination` is not a string')\n      } else if (\n        type === 'rewrite' &&\n        !_route.destination.match(/^(\\/|https:\\/\\/|http:\\/\\/)/)\n      ) {\n        invalidParts.push(\n          '`destination` does not start with `/`, `http://`, or `https://`'\n        )\n      }\n    }\n\n    if (type === 'redirect') {\n      const result = checkRedirect(route as Redirect)\n      hadInvalidStatus = hadInvalidStatus || result.hadInvalidStatus\n      invalidParts.push(...result.invalidParts)\n    }\n\n    let sourceTokens: pathToRegexp.Token[] | undefined\n\n    if (typeof route.source === 'string' && route.source.startsWith('/')) {\n      // only show parse error if we didn't already show error\n      // for not being a string\n      const { tokens, error, regexStr } = tryParsePath(route.source)\n\n      if (error) {\n        invalidParts.push('`source` parse failed')\n      }\n\n      if (regexStr && regexStr.length > 4096) {\n        invalidParts.push('`source` exceeds max built length of 4096')\n      }\n\n      sourceTokens = tokens\n    }\n    const hasSegments = new Set<string>()\n\n    if (route.has) {\n      for (const hasItem of route.has) {\n        if (!hasItem.value && hasItem.key) {\n          hasSegments.add(hasItem.key)\n        }\n\n        if (hasItem.value) {\n          for (const match of hasItem.value.matchAll(namedGroupsRegex)) {\n            if (match[1]) {\n              hasSegments.add(match[1])\n            }\n          }\n\n          if (hasItem.type === 'host') {\n            hasSegments.add('host')\n          }\n        }\n      }\n    }\n\n    // make sure no unnamed patterns are attempted to be used in the\n    // destination as this can cause confusion and is not allowed\n    if (typeof (route as Rewrite).destination === 'string') {\n      if (\n        (route as Rewrite).destination.startsWith('/') &&\n        Array.isArray(sourceTokens)\n      ) {\n        const unnamedInDest = new Set()\n\n        for (const token of sourceTokens) {\n          if (typeof token === 'object' && typeof token.name === 'number') {\n            const unnamedIndex = new RegExp(`:${token.name}(?!\\\\d)`)\n            if ((route as Rewrite).destination.match(unnamedIndex)) {\n              unnamedInDest.add(`:${token.name}`)\n            }\n          }\n        }\n\n        if (unnamedInDest.size > 0) {\n          invalidParts.push(\n            `\\`destination\\` has unnamed params ${[...unnamedInDest].join(\n              ', '\n            )}`\n          )\n        } else {\n          const {\n            tokens: destTokens,\n            regexStr: destRegexStr,\n            error: destinationParseFailed,\n          } = tryParsePath((route as Rewrite).destination, true)\n\n          if (destRegexStr && destRegexStr.length > 4096) {\n            invalidParts.push('`destination` exceeds max built length of 4096')\n          }\n\n          if (destinationParseFailed) {\n            invalidParts.push('`destination` parse failed')\n          } else {\n            const sourceSegments = new Set(\n              sourceTokens\n                .map((item) => typeof item === 'object' && item.name)\n                .filter(Boolean)\n            )\n            const invalidDestSegments = new Set()\n\n            for (const token of destTokens!) {\n              if (\n                typeof token === 'object' &&\n                !sourceSegments.has(token.name) &&\n                !hasSegments.has(token.name as string)\n              ) {\n                invalidDestSegments.add(token.name)\n              }\n            }\n\n            if (invalidDestSegments.size) {\n              invalidParts.push(\n                `\\`destination\\` has segments not in \\`source\\` or \\`has\\` (${[\n                  ...invalidDestSegments,\n                ].join(', ')})`\n              )\n            }\n          }\n        }\n      }\n    }\n\n    const hasInvalidKeys = invalidKeys.length > 0\n    const hasInvalidParts = invalidParts.length > 0\n\n    if (hasInvalidKeys || hasInvalidParts) {\n      console.error(\n        `${invalidParts.join(', ')}${\n          invalidKeys.length\n            ? (hasInvalidParts ? ',' : '') +\n              ` invalid field${invalidKeys.length === 1 ? '' : 's'}: ` +\n              invalidKeys.join(',')\n            : ''\n        } for route ${JSON.stringify(route)}`\n      )\n      console.error()\n      numInvalidRoutes++\n    }\n  }\n\n  if (numInvalidRoutes > 0) {\n    if (hadInvalidStatus) {\n      console.error(\n        `\\nValid redirect statusCode values are ${[...allowedStatusCodes].join(\n          ', '\n        )}`\n      )\n    }\n    if (hadInvalidHas) {\n      console.error(\n        `\\nValid \\`has\\` object shape is ${JSON.stringify(\n          {\n            type: [...allowedHasTypes].join(', '),\n            key: 'the key to check for',\n            value: 'undefined or a value string to match against',\n          },\n          null,\n          2\n        )}`\n      )\n    }\n    console.error()\n    console.error(\n      `Error: Invalid ${type}${numInvalidRoutes === 1 ? '' : 's'} found`\n    )\n    process.exit(1)\n  }\n}\n\nexport interface CustomRoutes {\n  headers: Header[]\n  rewrites: {\n    fallback: Rewrite[]\n    afterFiles: Rewrite[]\n    beforeFiles: Rewrite[]\n  }\n  redirects: Redirect[]\n}\n\nfunction processRoutes<T>(\n  routes: T,\n  config: NextConfig,\n  type: 'redirect' | 'rewrite' | 'header'\n): T {\n  const _routes = routes as any as Array<{\n    source: string\n    locale?: false\n    basePath?: false\n    destination?: string\n  }>\n  const newRoutes: typeof _routes = []\n  const defaultLocales: Array<{\n    locale: string\n    base: string\n  }> = []\n\n  if (config.i18n && type === 'redirect') {\n    for (const item of config.i18n?.domains || []) {\n      defaultLocales.push({\n        locale: item.defaultLocale,\n        base: `http${item.http ? '' : 's'}://${item.domain}`,\n      })\n    }\n\n    defaultLocales.push({\n      locale: config.i18n.defaultLocale,\n      base: '',\n    })\n  }\n\n  for (const r of _routes) {\n    const srcBasePath =\n      config.basePath && r.basePath !== false ? config.basePath : ''\n    const isExternal = !r.destination?.startsWith('/')\n    const destBasePath = srcBasePath && !isExternal ? srcBasePath : ''\n\n    if (config.i18n && r.locale !== false) {\n      if (!isExternal) {\n        defaultLocales.forEach((item) => {\n          let destination\n\n          if (r.destination) {\n            destination = item.base\n              ? `${item.base}${destBasePath}${r.destination}`\n              : `${destBasePath}${r.destination}`\n          }\n\n          newRoutes.push({\n            ...r,\n            destination,\n            source: `${srcBasePath}/${item.locale}${r.source}`,\n          })\n        })\n      }\n\n      r.source = `/:nextInternalLocale(${config.i18n.locales\n        .map((locale: string) => escapeStringRegexp(locale))\n        .join('|')})${\n        r.source === '/' && !config.trailingSlash ? '' : r.source\n      }`\n\n      if (r.destination && r.destination?.startsWith('/')) {\n        r.destination = `/:nextInternalLocale${\n          r.destination === '/' && !config.trailingSlash ? '' : r.destination\n        }`\n      }\n    }\n    r.source = `${srcBasePath}${\n      r.source === '/' && srcBasePath ? '' : r.source\n    }`\n\n    if (r.destination) {\n      r.destination = `${destBasePath}${\n        r.destination === '/' && destBasePath ? '' : r.destination\n      }`\n    }\n    newRoutes.push(r)\n  }\n  return newRoutes as any as T\n}\n\nasync function loadRedirects(config: NextConfig) {\n  if (typeof config.redirects !== 'function') {\n    return []\n  }\n  let redirects = await config.redirects()\n  // check before we process the routes and after to ensure\n  // they are still valid\n  checkCustomRoutes(redirects, 'redirect')\n\n  redirects = processRoutes(redirects, config, 'redirect')\n  checkCustomRoutes(redirects, 'redirect')\n  return redirects\n}\n\nasync function loadRewrites(config: NextConfig) {\n  if (typeof config.rewrites !== 'function') {\n    return {\n      beforeFiles: [],\n      afterFiles: [],\n      fallback: [],\n    }\n  }\n  const _rewrites = await config.rewrites()\n  let beforeFiles: Rewrite[] = []\n  let afterFiles: Rewrite[] = []\n  let fallback: Rewrite[] = []\n\n  if (\n    !Array.isArray(_rewrites) &&\n    typeof _rewrites === 'object' &&\n    Object.keys(_rewrites).every(\n      (key) =>\n        key === 'beforeFiles' || key === 'afterFiles' || key === 'fallback'\n    )\n  ) {\n    beforeFiles = _rewrites.beforeFiles || []\n    afterFiles = _rewrites.afterFiles || []\n    fallback = _rewrites.fallback || []\n  } else {\n    afterFiles = _rewrites as any\n  }\n  // check before we process the routes and after to ensure\n  // they are still valid\n  checkCustomRoutes(beforeFiles, 'rewrite')\n  checkCustomRoutes(afterFiles, 'rewrite')\n  checkCustomRoutes(fallback, 'rewrite')\n\n  beforeFiles = processRoutes(beforeFiles, config, 'rewrite')\n  afterFiles = processRoutes(afterFiles, config, 'rewrite')\n  fallback = processRoutes(fallback, config, 'rewrite')\n\n  checkCustomRoutes(beforeFiles, 'rewrite')\n  checkCustomRoutes(afterFiles, 'rewrite')\n  checkCustomRoutes(fallback, 'rewrite')\n\n  return {\n    beforeFiles,\n    afterFiles,\n    fallback,\n  }\n}\n\nasync function loadHeaders(config: NextConfig) {\n  if (typeof config.headers !== 'function') {\n    return []\n  }\n  let headers = await config.headers()\n  // check before we process the routes and after to ensure\n  // they are still valid\n  checkCustomRoutes(headers, 'header')\n\n  headers = processRoutes(headers, config, 'header')\n  checkCustomRoutes(headers, 'header')\n  return headers\n}\n\nexport default async function loadCustomRoutes(\n  config: NextConfig\n): Promise<CustomRoutes> {\n  const [headers, rewrites, redirects] = await Promise.all([\n    loadHeaders(config),\n    loadRewrites(config),\n    loadRedirects(config),\n  ])\n\n  const totalRewrites =\n    rewrites.beforeFiles.length +\n    rewrites.afterFiles.length +\n    rewrites.fallback.length\n\n  const totalRoutes = headers.length + redirects.length + totalRewrites\n\n  if (totalRoutes > 1000) {\n    console.warn(\n      chalk.bold.yellow(`Warning: `) +\n        `total number of custom routes exceeds 1000, this can reduce performance. Route counts:\\n` +\n        `headers: ${headers.length}\\n` +\n        `rewrites: ${totalRewrites}\\n` +\n        `redirects: ${redirects.length}\\n` +\n        `See more info: https://nextjs.org/docs/messages/max-custom-routes-reached`\n    )\n  }\n\n  if (config.trailingSlash) {\n    redirects.unshift(\n      {\n        source: '/:file((?!\\\\.well-known(?:/.*)?)(?:[^/]+/)*[^/]+\\\\.\\\\w+)/',\n        destination: '/:file',\n        permanent: true,\n        locale: config.i18n ? false : undefined,\n        internal: true,\n      } as Redirect,\n      {\n        source: '/:notfile((?!\\\\.well-known(?:/.*)?)(?:[^/]+/)*[^/\\\\.]+)',\n        destination: '/:notfile/',\n        permanent: true,\n        locale: config.i18n ? false : undefined,\n        internal: true,\n      } as Redirect\n    )\n    if (config.basePath) {\n      redirects.unshift({\n        source: config.basePath,\n        destination: config.basePath + '/',\n        permanent: true,\n        basePath: false,\n        locale: config.i18n ? false : undefined,\n        internal: true,\n      } as Redirect)\n    }\n  } else {\n    redirects.unshift({\n      source: '/:path+/',\n      destination: '/:path+',\n      permanent: true,\n      locale: config.i18n ? false : undefined,\n      internal: true,\n    } as Redirect)\n    if (config.basePath) {\n      redirects.unshift({\n        source: config.basePath + '/',\n        destination: config.basePath,\n        permanent: true,\n        basePath: false,\n        locale: config.i18n ? false : undefined,\n        internal: true,\n      } as Redirect)\n    }\n  }\n\n  return {\n    headers,\n    rewrites,\n    redirects,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}