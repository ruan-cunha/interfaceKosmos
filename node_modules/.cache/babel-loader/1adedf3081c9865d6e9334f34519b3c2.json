{"ast":null,"code":"exports.quote = function (xs) {\n  return xs.map(function (s) {\n    if (s && typeof s === 'object') {\n      return s.op.replace(/(.)/g, '\\\\$1');\n    } else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\n      return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n    } else if (/[\"'\\s]/.test(s)) {\n      return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n    } else {\n      return String(s).replace(/([A-z]:)?([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '$1\\\\$2');\n    }\n  }).join(' ');\n}; // '<(' is process substitution operator and\n// can be parsed the same as control operator\n\n\nvar CONTROL = '(?:' + ['\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '>>', '>\\\\&', '[&;()|<>]'].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar TOKEN = '';\n\nfor (var i = 0; i < 4; i++) {\n  TOKEN += (Math.pow(16, 8) * Math.random()).toString(16);\n}\n\nexports.parse = function (s, env, opts) {\n  var mapped = parse(s, env, opts);\n  if (typeof env !== 'function') return mapped;\n  return mapped.reduce(function (acc, s) {\n    if (typeof s === 'object') return acc.concat(s);\n    var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n    if (xs.length === 1) return acc.concat(xs[0]);\n    return acc.concat(xs.filter(Boolean).map(function (x) {\n      if (RegExp('^' + TOKEN).test(x)) {\n        return JSON.parse(x.split(TOKEN)[1]);\n      } else return x;\n    }));\n  }, []);\n};\n\nfunction parse(s, env, opts) {\n  var chunker = new RegExp(['(' + CONTROL + ')', // control chars\n  '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'].join('|'), 'g');\n  var match = s.match(chunker).filter(Boolean);\n  var commented = false;\n  if (!match) return [];\n  if (!env) env = {};\n  if (!opts) opts = {};\n  return match.map(function (s, j) {\n    if (commented) {\n      return;\n    }\n\n    if (RegExp('^' + CONTROL + '$').test(s)) {\n      return {\n        op: s\n      };\n    } // Hand-written scanner/parser for Bash quoting rules:\n    //\n    //  1. inside single quotes, all characters are printed literally.\n    //  2. inside double quotes, all characters are printed literally\n    //     except variables prefixed by '$' and backslashes followed by\n    //     either a double quote or another backslash.\n    //  3. outside of any quotes, backslashes are treated as escape\n    //     characters and not printed (unless they are themselves escaped)\n    //  4. quote context can switch mid-token if there is no whitespace\n    //     between the two quote contexts (e.g. all'one'\"token\" parses as\n    //     \"allonetoken\")\n\n\n    var SQ = \"'\";\n    var DQ = '\"';\n    var DS = '$';\n    var BS = opts.escape || '\\\\';\n    var quote = false;\n    var esc = false;\n    var out = '';\n    var isGlob = false;\n\n    for (var i = 0, len = s.length; i < len; i++) {\n      var c = s.charAt(i);\n      isGlob = isGlob || !quote && (c === '*' || c === '?');\n\n      if (esc) {\n        out += c;\n        esc = false;\n      } else if (quote) {\n        if (c === quote) {\n          quote = false;\n        } else if (quote == SQ) {\n          out += c;\n        } else {\n          // Double quote\n          if (c === BS) {\n            i += 1;\n            c = s.charAt(i);\n\n            if (c === DQ || c === BS || c === DS) {\n              out += c;\n            } else {\n              out += BS + c;\n            }\n          } else if (c === DS) {\n            out += parseEnvVar();\n          } else {\n            out += c;\n          }\n        }\n      } else if (c === DQ || c === SQ) {\n        quote = c;\n      } else if (RegExp('^' + CONTROL + '$').test(c)) {\n        return {\n          op: s\n        };\n      } else if (RegExp('^#$').test(c)) {\n        commented = true;\n\n        if (out.length) {\n          return [out, {\n            comment: s.slice(i + 1) + match.slice(j + 1).join(' ')\n          }];\n        }\n\n        return [{\n          comment: s.slice(i + 1) + match.slice(j + 1).join(' ')\n        }];\n      } else if (c === BS) {\n        esc = true;\n      } else if (c === DS) {\n        out += parseEnvVar();\n      } else out += c;\n    }\n\n    if (isGlob) return {\n      op: 'glob',\n      pattern: out\n    };\n    return out;\n\n    function parseEnvVar() {\n      i += 1;\n      var varend, varname; //debugger\n\n      if (s.charAt(i) === '{') {\n        i += 1;\n\n        if (s.charAt(i) === '}') {\n          throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\n        }\n\n        varend = s.indexOf('}', i);\n\n        if (varend < 0) {\n          throw new Error(\"Bad substitution: \" + s.substr(i));\n        }\n\n        varname = s.substr(i, varend - i);\n        i = varend;\n      } else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\n        varname = s.charAt(i);\n        i += 1;\n      } else {\n        varend = s.substr(i).match(/[^\\w\\d_]/);\n\n        if (!varend) {\n          varname = s.substr(i);\n          i = s.length;\n        } else {\n          varname = s.substr(i, varend.index);\n          i += varend.index - 1;\n        }\n      }\n\n      return getVar(null, '', varname);\n    }\n  }) // finalize parsed aruments\n  .reduce(function (prev, arg) {\n    if (arg === undefined) {\n      return prev;\n    }\n\n    return prev.concat(arg);\n  }, []);\n\n  function getVar(_, pre, key) {\n    var r = typeof env === 'function' ? env(key) : env[key];\n    if (r === undefined && key != '') r = '';else if (r === undefined) r = '$';\n\n    if (typeof r === 'object') {\n      return pre + TOKEN + JSON.stringify(r) + TOKEN;\n    } else return pre + r;\n  }\n}","map":{"version":3,"sources":["C:/xampp/public_html/vamo/interface2/node_modules/shell-quote/index.js"],"names":["exports","quote","xs","map","s","op","replace","test","String","join","CONTROL","META","BAREWORD","SINGLE_QUOTE","DOUBLE_QUOTE","TOKEN","i","Math","pow","random","toString","parse","env","opts","mapped","reduce","acc","concat","split","RegExp","length","filter","Boolean","x","JSON","chunker","match","commented","j","SQ","DQ","DS","BS","escape","esc","out","isGlob","len","c","charAt","parseEnvVar","comment","slice","pattern","varend","varname","Error","substr","indexOf","index","getVar","prev","arg","undefined","_","pre","key","r","stringify"],"mappings":"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","sourcesContent":["exports.quote = function (xs) {\n    return xs.map(function (s) {\n        if (s && typeof s === 'object') {\n            return s.op.replace(/(.)/g, '\\\\$1');\n        }\n        else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\n            return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n        }\n        else if (/[\"'\\s]/.test(s)) {\n            return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n        }\n        else {\n            return String(s).replace(/([A-z]:)?([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '$1\\\\$2');\n        }\n    }).join(' ');\n};\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n    '\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '>>', '>\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);\n}\n\nexports.parse = function (s, env, opts) {\n    var mapped = parse(s, env, opts);\n    if (typeof env !== 'function') return mapped;\n    return mapped.reduce(function (acc, s) {\n        if (typeof s === 'object') return acc.concat(s);\n        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n        if (xs.length === 1) return acc.concat(xs[0]);\n        return acc.concat(xs.filter(Boolean).map(function (x) {\n            if (RegExp('^' + TOKEN).test(x)) {\n                return JSON.parse(x.split(TOKEN)[1]);\n            }\n            else return x;\n        }));\n    }, []);\n};\n\nfunction parse (s, env, opts) {\n    var chunker = new RegExp([\n        '(' + CONTROL + ')', // control chars\n        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n    ].join('|'), 'g');\n    var match = s.match(chunker).filter(Boolean);\n    var commented = false;\n\n    if (!match) return [];\n    if (!env) env = {};\n    if (!opts) opts = {};\n    return match.map(function (s, j) {\n        if (commented) {\n            return;\n        }\n        if (RegExp('^' + CONTROL + '$').test(s)) {\n            return { op: s };\n        }\n\n        // Hand-written scanner/parser for Bash quoting rules:\n        //\n        //  1. inside single quotes, all characters are printed literally.\n        //  2. inside double quotes, all characters are printed literally\n        //     except variables prefixed by '$' and backslashes followed by\n        //     either a double quote or another backslash.\n        //  3. outside of any quotes, backslashes are treated as escape\n        //     characters and not printed (unless they are themselves escaped)\n        //  4. quote context can switch mid-token if there is no whitespace\n        //     between the two quote contexts (e.g. all'one'\"token\" parses as\n        //     \"allonetoken\")\n        var SQ = \"'\";\n        var DQ = '\"';\n        var DS = '$';\n        var BS = opts.escape || '\\\\';\n        var quote = false;\n        var esc = false;\n        var out = '';\n        var isGlob = false;\n\n        for (var i = 0, len = s.length; i < len; i++) {\n            var c = s.charAt(i);\n            isGlob = isGlob || (!quote && (c === '*' || c === '?'));\n            if (esc) {\n                out += c;\n                esc = false;\n            }\n            else if (quote) {\n                if (c === quote) {\n                    quote = false;\n                }\n                else if (quote == SQ) {\n                    out += c;\n                }\n                else { // Double quote\n                    if (c === BS) {\n                        i += 1;\n                        c = s.charAt(i);\n                        if (c === DQ || c === BS || c === DS) {\n                            out += c;\n                        } else {\n                            out += BS + c;\n                        }\n                    }\n                    else if (c === DS) {\n                        out += parseEnvVar();\n                    }\n                    else {\n                        out += c;\n                    }\n                }\n            }\n            else if (c === DQ || c === SQ) {\n                quote = c;\n            }\n            else if (RegExp('^' + CONTROL + '$').test(c)) {\n                return { op: s };\n            }\n            else if (RegExp('^#$').test(c)) {\n                commented = true;\n                if (out.length){\n                    return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n                }\n                return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n            }\n            else if (c === BS) {\n                esc = true;\n            }\n            else if (c === DS) {\n                out += parseEnvVar();\n            }\n            else out += c;\n        }\n\n        if (isGlob) return {op: 'glob', pattern: out};\n\n        return out;\n\n        function parseEnvVar() {\n            i += 1;\n            var varend, varname;\n            //debugger\n            if (s.charAt(i) === '{') {\n                i += 1;\n                if (s.charAt(i) === '}') {\n                    throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\n                }\n                varend = s.indexOf('}', i);\n                if (varend < 0) {\n                    throw new Error(\"Bad substitution: \" + s.substr(i));\n                }\n                varname = s.substr(i, varend - i);\n                i = varend;\n            }\n            else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\n                varname = s.charAt(i);\n                i += 1;\n            }\n            else {\n                varend = s.substr(i).match(/[^\\w\\d_]/);\n                if (!varend) {\n                    varname = s.substr(i);\n                    i = s.length;\n                } else {\n                    varname = s.substr(i, varend.index);\n                    i += varend.index - 1;\n                }\n            }\n            return getVar(null, '', varname);\n        }\n    })\n    // finalize parsed aruments\n    .reduce(function(prev, arg){\n        if (arg === undefined){\n            return prev;\n        }\n        return prev.concat(arg);\n    },[]);\n\n    function getVar (_, pre, key) {\n        var r = typeof env === 'function' ? env(key) : env[key];\n        if (r === undefined && key != '')\n            r = '';\n        else if (r === undefined)\n            r = '$';\n\n        if (typeof r === 'object') {\n            return pre + TOKEN + JSON.stringify(r) + TOKEN;\n        }\n        else return pre + r;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}