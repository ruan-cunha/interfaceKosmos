{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nconst URL = require(\"./url\");\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\n\n\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  }\n\n  throw new Error('\"' + aName + '\" is a required argument.');\n}\n\nexports.getArg = getArg;\n\nconst supportsNullProto = function () {\n  const obj = Object.create(null);\n  return !(\"__proto__\" in obj);\n}();\n\nfunction identity(s) {\n  return s;\n}\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\n\n\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return \"$\" + aStr;\n  }\n\n  return aStr;\n}\n\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\n\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  const length = s.length;\n\n  if (length < 9\n  /* \"__proto__\".length */\n  ) {\n    return false;\n  }\n  /* eslint-disable no-multi-spaces */\n\n\n  if (s.charCodeAt(length - 1) !== 95\n  /* '_' */\n  || s.charCodeAt(length - 2) !== 95\n  /* '_' */\n  || s.charCodeAt(length - 3) !== 111\n  /* 'o' */\n  || s.charCodeAt(length - 4) !== 116\n  /* 't' */\n  || s.charCodeAt(length - 5) !== 111\n  /* 'o' */\n  || s.charCodeAt(length - 6) !== 114\n  /* 'r' */\n  || s.charCodeAt(length - 7) !== 112\n  /* 'p' */\n  || s.charCodeAt(length - 8) !== 95\n  /* '_' */\n  || s.charCodeAt(length - 9) !== 95\n  /* '_' */\n  ) {\n    return false;\n  }\n  /* eslint-enable no-multi-spaces */\n\n\n  for (let i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36\n    /* '$' */\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\n\n\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\n\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\n\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\n\nexports.parseSourceMapInput = parseSourceMapInput; // We use 'http' as the base here because we want URLs processed relative\n// to the safe base to be treated as \"special\" URLs during parsing using\n// the WHATWG URL parsing. This ensures that backslash normalization\n// applies to the path and such.\n\nconst PROTOCOL = \"http:\";\nconst PROTOCOL_AND_HOST = `${PROTOCOL}//host`;\n/**\n * Make it easy to create small utilities that tweak a URL's path.\n */\n\nfunction createSafeHandler(cb) {\n  return input => {\n    const type = getURLType(input);\n    const base = buildSafeBase(input);\n    const url = new URL(input, base);\n    cb(url);\n    const result = url.toString();\n\n    if (type === \"absolute\") {\n      return result;\n    } else if (type === \"scheme-relative\") {\n      return result.slice(PROTOCOL.length);\n    } else if (type === \"path-absolute\") {\n      return result.slice(PROTOCOL_AND_HOST.length);\n    } // This assumes that the callback will only change\n    // the path, search and hash values.\n\n\n    return computeRelativeURL(base, result);\n  };\n}\n\nfunction withBase(url, base) {\n  return new URL(url, base).toString();\n}\n\nfunction buildUniqueSegment(prefix, str) {\n  let id = 0;\n\n  do {\n    const ident = prefix + id++;\n    if (str.indexOf(ident) === -1) return ident;\n  } while (true);\n}\n\nfunction buildSafeBase(str) {\n  const maxDotParts = str.split(\"..\").length - 1; // If we used a segment that also existed in `str`, then we would be unable\n  // to compute relative paths. For example, if `segment` were just \"a\":\n  //\n  //   const url = \"../../a/\"\n  //   const base = buildSafeBase(url); // http://host/a/a/\n  //   const joined = \"http://host/a/\";\n  //   const result = relative(base, joined);\n  //\n  // Expected: \"../../a/\";\n  // Actual: \"a/\"\n  //\n\n  const segment = buildUniqueSegment(\"p\", str);\n  let base = `${PROTOCOL_AND_HOST}/`;\n\n  for (let i = 0; i < maxDotParts; i++) {\n    base += `${segment}/`;\n  }\n\n  return base;\n}\n\nconst ABSOLUTE_SCHEME = /^[A-Za-z0-9\\+\\-\\.]+:/;\n\nfunction getURLType(url) {\n  if (url[0] === \"/\") {\n    if (url[1] === \"/\") return \"scheme-relative\";\n    return \"path-absolute\";\n  }\n\n  return ABSOLUTE_SCHEME.test(url) ? \"absolute\" : \"path-relative\";\n}\n/**\n * Given two URLs that are assumed to be on the same\n * protocol/host/user/password build a relative URL from the\n * path, params, and hash values.\n *\n * @param rootURL The root URL that the target will be relative to.\n * @param targetURL The target that the relative URL points to.\n * @return A rootURL-relative, normalized URL value.\n */\n\n\nfunction computeRelativeURL(rootURL, targetURL) {\n  if (typeof rootURL === \"string\") rootURL = new URL(rootURL);\n  if (typeof targetURL === \"string\") targetURL = new URL(targetURL);\n  const targetParts = targetURL.pathname.split(\"/\");\n  const rootParts = rootURL.pathname.split(\"/\"); // If we've got a URL path ending with a \"/\", we remove it since we'd\n  // otherwise be relative to the wrong location.\n\n  if (rootParts.length > 0 && !rootParts[rootParts.length - 1]) {\n    rootParts.pop();\n  }\n\n  while (targetParts.length > 0 && rootParts.length > 0 && targetParts[0] === rootParts[0]) {\n    targetParts.shift();\n    rootParts.shift();\n  }\n\n  const relativePath = rootParts.map(() => \"..\").concat(targetParts).join(\"/\");\n  return relativePath + targetURL.search + targetURL.hash;\n}\n/**\n * Given a URL, ensure that it is treated as a directory URL.\n *\n * @param url\n * @return A normalized URL value.\n */\n\n\nconst ensureDirectory = createSafeHandler(url => {\n  url.pathname = url.pathname.replace(/\\/?$/, \"/\");\n});\n/**\n * Given a URL, strip off any filename if one is present.\n *\n * @param url\n * @return A normalized URL value.\n */\n\nconst trimFilename = createSafeHandler(url => {\n  url.href = new URL(\".\", url.toString()).toString();\n});\n/**\n * Normalize a given URL.\n * * Convert backslashes.\n * * Remove any \"..\" and \".\" segments.\n *\n * @param url\n * @return A normalized URL value.\n */\n\nconst normalize = createSafeHandler(url => {});\nexports.normalize = normalize;\n/**\n * Joins two paths/URLs.\n *\n * All returned URLs will be normalized.\n *\n * @param aRoot The root path or URL. Assumed to reference a directory.\n * @param aPath The path or URL to be joined with the root.\n * @return A joined and normalized URL value.\n */\n\nfunction join(aRoot, aPath) {\n  const pathType = getURLType(aPath);\n  const rootType = getURLType(aRoot);\n  aRoot = ensureDirectory(aRoot);\n\n  if (pathType === \"absolute\") {\n    return withBase(aPath, undefined);\n  }\n\n  if (rootType === \"absolute\") {\n    return withBase(aPath, aRoot);\n  }\n\n  if (pathType === \"scheme-relative\") {\n    return normalize(aPath);\n  }\n\n  if (rootType === \"scheme-relative\") {\n    return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(PROTOCOL.length);\n  }\n\n  if (pathType === \"path-absolute\") {\n    return normalize(aPath);\n  }\n\n  if (rootType === \"path-absolute\") {\n    return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(PROTOCOL_AND_HOST.length);\n  }\n\n  const base = buildSafeBase(aPath + aRoot);\n  const newPath = withBase(aPath, withBase(aRoot, base));\n  return computeRelativeURL(base, newPath);\n}\n\nexports.join = join;\n/**\n * Make a path relative to a URL or another path. If returning a\n * relative URL is not possible, the original target will be returned.\n * All returned URLs will be normalized.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n * @return A rootURL-relative (if possible), normalized URL value.\n */\n\nfunction relative(rootURL, targetURL) {\n  const result = relativeIfPossible(rootURL, targetURL);\n  return typeof result === \"string\" ? result : normalize(targetURL);\n}\n\nexports.relative = relative;\n\nfunction relativeIfPossible(rootURL, targetURL) {\n  const urlType = getURLType(rootURL);\n\n  if (urlType !== getURLType(targetURL)) {\n    return null;\n  }\n\n  const base = buildSafeBase(rootURL + targetURL);\n  const root = new URL(rootURL, base);\n  const target = new URL(targetURL, base);\n\n  try {\n    new URL(\"\", target.toString());\n  } catch (err) {\n    // Bail if the URL doesn't support things being relative to it,\n    // For example, data: and blob: URLs.\n    return null;\n  }\n\n  if (target.protocol !== root.protocol || target.user !== root.user || target.password !== root.password || target.hostname !== root.hostname || target.port !== root.port) {\n    return null;\n  }\n\n  return computeRelativeURL(root, target);\n}\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\n\n\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  // The source map spec states that \"sourceRoot\" and \"sources\" entries are to be appended. While\n  // that is a little vague, implementations have generally interpreted that as joining the\n  // URLs with a `/` between then, assuming the \"sourceRoot\" doesn't already end with one.\n  // For example,\n  //\n  //   sourceRoot: \"some-dir\",\n  //   sources: [\"/some-path.js\"]\n  //\n  // and\n  //\n  //   sourceRoot: \"some-dir/\",\n  //   sources: [\"/some-path.js\"]\n  //\n  // must behave as \"some-dir/some-path.js\".\n  //\n  // With this library's the transition to a more URL-focused implementation, that behavior is\n  // preserved here. To acheive that, we trim the \"/\" from absolute-path when a sourceRoot value\n  // is present in order to make the sources entries behave as if they are relative to the\n  // \"sourceRoot\", as they would have if the two strings were simply concated.\n  if (sourceRoot && getURLType(sourceURL) === \"path-absolute\") {\n    sourceURL = sourceURL.replace(/^\\//, \"\");\n  }\n\n  let url = normalize(sourceURL || \"\"); // Parsing URLs can be expensive, so we only perform these joins when needed.\n\n  if (sourceRoot) url = join(sourceRoot, url);\n  if (sourceMapURL) url = join(trimFilename(sourceMapURL), url);\n  return url;\n}\n\nexports.computeSourceURL = computeSourceURL;","map":{"version":3,"sources":["C:/xampp/public_html/vamo/interface2/node_modules/@next/react-dev-overlay/node_modules/source-map/lib/util.js"],"names":["URL","require","getArg","aArgs","aName","aDefaultValue","arguments","length","Error","exports","supportsNullProto","obj","Object","create","identity","s","toSetString","aStr","isProtoString","fromSetString","slice","charCodeAt","i","strcmp","aStr1","aStr2","compareByGeneratedPositionsInflated","mappingA","mappingB","cmp","generatedLine","generatedColumn","source","originalLine","originalColumn","name","parseSourceMapInput","str","JSON","parse","replace","PROTOCOL","PROTOCOL_AND_HOST","createSafeHandler","cb","input","type","getURLType","base","buildSafeBase","url","result","toString","computeRelativeURL","withBase","buildUniqueSegment","prefix","id","ident","indexOf","maxDotParts","split","segment","ABSOLUTE_SCHEME","test","rootURL","targetURL","targetParts","pathname","rootParts","pop","shift","relativePath","map","concat","join","search","hash","ensureDirectory","trimFilename","href","normalize","aRoot","aPath","pathType","rootType","undefined","newPath","relative","relativeIfPossible","urlType","root","target","err","protocol","user","password","hostname","port","computeSourceURL","sourceRoot","sourceURL","sourceMapURL"],"mappings":"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","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst URL = require(\"./url\");\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  }\n    throw new Error('\"' + aName + '\" is a required argument.');\n\n}\nexports.getArg = getArg;\n\nconst supportsNullProto = (function() {\n  const obj = Object.create(null);\n  return !(\"__proto__\" in obj);\n}());\n\nfunction identity(s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return \"$\" + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  const length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  /* eslint-disable no-multi-spaces */\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n  /* eslint-enable no-multi-spaces */\n\n  for (let i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n// We use 'http' as the base here because we want URLs processed relative\n// to the safe base to be treated as \"special\" URLs during parsing using\n// the WHATWG URL parsing. This ensures that backslash normalization\n// applies to the path and such.\nconst PROTOCOL = \"http:\";\nconst PROTOCOL_AND_HOST = `${PROTOCOL}//host`;\n\n/**\n * Make it easy to create small utilities that tweak a URL's path.\n */\nfunction createSafeHandler(cb) {\n  return input => {\n    const type = getURLType(input);\n    const base = buildSafeBase(input);\n    const url = new URL(input, base);\n\n    cb(url);\n\n    const result = url.toString();\n\n    if (type === \"absolute\") {\n      return result;\n    } else if (type === \"scheme-relative\") {\n      return result.slice(PROTOCOL.length);\n    } else if (type === \"path-absolute\") {\n      return result.slice(PROTOCOL_AND_HOST.length);\n    }\n\n    // This assumes that the callback will only change\n    // the path, search and hash values.\n    return computeRelativeURL(base, result);\n  };\n}\n\nfunction withBase(url, base) {\n  return new URL(url, base).toString();\n}\n\nfunction buildUniqueSegment(prefix, str) {\n  let id = 0;\n  do {\n    const ident = prefix + (id++);\n    if (str.indexOf(ident) === -1) return ident;\n  } while (true);\n}\n\nfunction buildSafeBase(str) {\n  const maxDotParts = str.split(\"..\").length - 1;\n\n  // If we used a segment that also existed in `str`, then we would be unable\n  // to compute relative paths. For example, if `segment` were just \"a\":\n  //\n  //   const url = \"../../a/\"\n  //   const base = buildSafeBase(url); // http://host/a/a/\n  //   const joined = \"http://host/a/\";\n  //   const result = relative(base, joined);\n  //\n  // Expected: \"../../a/\";\n  // Actual: \"a/\"\n  //\n  const segment = buildUniqueSegment(\"p\", str);\n\n  let base = `${PROTOCOL_AND_HOST}/`;\n  for (let i = 0; i < maxDotParts; i++) {\n    base += `${segment}/`;\n  }\n  return base;\n}\n\nconst ABSOLUTE_SCHEME = /^[A-Za-z0-9\\+\\-\\.]+:/;\nfunction getURLType(url) {\n  if (url[0] === \"/\") {\n    if (url[1] === \"/\") return \"scheme-relative\";\n    return \"path-absolute\";\n  }\n\n  return ABSOLUTE_SCHEME.test(url) ? \"absolute\" : \"path-relative\";\n}\n\n/**\n * Given two URLs that are assumed to be on the same\n * protocol/host/user/password build a relative URL from the\n * path, params, and hash values.\n *\n * @param rootURL The root URL that the target will be relative to.\n * @param targetURL The target that the relative URL points to.\n * @return A rootURL-relative, normalized URL value.\n */\nfunction computeRelativeURL(rootURL, targetURL) {\n  if (typeof rootURL === \"string\") rootURL = new URL(rootURL);\n  if (typeof targetURL === \"string\") targetURL = new URL(targetURL);\n\n  const targetParts = targetURL.pathname.split(\"/\");\n  const rootParts = rootURL.pathname.split(\"/\");\n\n  // If we've got a URL path ending with a \"/\", we remove it since we'd\n  // otherwise be relative to the wrong location.\n  if (rootParts.length > 0 && !rootParts[rootParts.length - 1]) {\n    rootParts.pop();\n  }\n\n  while (\n    targetParts.length > 0 &&\n    rootParts.length > 0 &&\n    targetParts[0] === rootParts[0]\n  ) {\n    targetParts.shift();\n    rootParts.shift();\n  }\n\n  const relativePath = rootParts\n    .map(() => \"..\")\n    .concat(targetParts)\n    .join(\"/\");\n\n  return relativePath + targetURL.search + targetURL.hash;\n}\n\n/**\n * Given a URL, ensure that it is treated as a directory URL.\n *\n * @param url\n * @return A normalized URL value.\n */\nconst ensureDirectory = createSafeHandler(url => {\n  url.pathname = url.pathname.replace(/\\/?$/, \"/\");\n});\n\n/**\n * Given a URL, strip off any filename if one is present.\n *\n * @param url\n * @return A normalized URL value.\n */\nconst trimFilename = createSafeHandler(url => {\n  url.href = new URL(\".\", url.toString()).toString();\n});\n\n/**\n * Normalize a given URL.\n * * Convert backslashes.\n * * Remove any \"..\" and \".\" segments.\n *\n * @param url\n * @return A normalized URL value.\n */\nconst normalize = createSafeHandler(url => {});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * All returned URLs will be normalized.\n *\n * @param aRoot The root path or URL. Assumed to reference a directory.\n * @param aPath The path or URL to be joined with the root.\n * @return A joined and normalized URL value.\n */\nfunction join(aRoot, aPath) {\n  const pathType = getURLType(aPath);\n  const rootType = getURLType(aRoot);\n\n  aRoot = ensureDirectory(aRoot);\n\n  if (pathType === \"absolute\") {\n    return withBase(aPath, undefined);\n  }\n  if (rootType === \"absolute\") {\n    return withBase(aPath, aRoot);\n  }\n\n  if (pathType === \"scheme-relative\") {\n    return normalize(aPath);\n  }\n  if (rootType === \"scheme-relative\") {\n    return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(PROTOCOL.length);\n  }\n\n  if (pathType === \"path-absolute\") {\n    return normalize(aPath);\n  }\n  if (rootType === \"path-absolute\") {\n    return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(PROTOCOL_AND_HOST.length);\n  }\n\n  const base = buildSafeBase(aPath + aRoot);\n  const newPath = withBase(aPath, withBase(aRoot, base));\n  return computeRelativeURL(base, newPath);\n}\nexports.join = join;\n\n/**\n * Make a path relative to a URL or another path. If returning a\n * relative URL is not possible, the original target will be returned.\n * All returned URLs will be normalized.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n * @return A rootURL-relative (if possible), normalized URL value.\n */\nfunction relative(rootURL, targetURL) {\n  const result = relativeIfPossible(rootURL, targetURL);\n\n  return typeof result === \"string\" ? result : normalize(targetURL);\n}\nexports.relative = relative;\n\nfunction relativeIfPossible(rootURL, targetURL) {\n  const urlType = getURLType(rootURL);\n  if (urlType !== getURLType(targetURL)) {\n    return null;\n  }\n\n  const base = buildSafeBase(rootURL + targetURL);\n  const root = new URL(rootURL, base);\n  const target = new URL(targetURL, base);\n\n  try {\n    new URL(\"\", target.toString());\n  } catch (err) {\n    // Bail if the URL doesn't support things being relative to it,\n    // For example, data: and blob: URLs.\n    return null;\n  }\n\n  if (\n    target.protocol !== root.protocol ||\n    target.user !== root.user ||\n    target.password !== root.password ||\n    target.hostname !== root.hostname ||\n    target.port !== root.port\n  ) {\n    return null;\n  }\n\n  return computeRelativeURL(root, target);\n}\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  // The source map spec states that \"sourceRoot\" and \"sources\" entries are to be appended. While\n  // that is a little vague, implementations have generally interpreted that as joining the\n  // URLs with a `/` between then, assuming the \"sourceRoot\" doesn't already end with one.\n  // For example,\n  //\n  //   sourceRoot: \"some-dir\",\n  //   sources: [\"/some-path.js\"]\n  //\n  // and\n  //\n  //   sourceRoot: \"some-dir/\",\n  //   sources: [\"/some-path.js\"]\n  //\n  // must behave as \"some-dir/some-path.js\".\n  //\n  // With this library's the transition to a more URL-focused implementation, that behavior is\n  // preserved here. To acheive that, we trim the \"/\" from absolute-path when a sourceRoot value\n  // is present in order to make the sources entries behave as if they are relative to the\n  // \"sourceRoot\", as they would have if the two strings were simply concated.\n  if (sourceRoot && getURLType(sourceURL) === \"path-absolute\") {\n    sourceURL = sourceURL.replace(/^\\//, \"\");\n  }\n\n  let url = normalize(sourceURL || \"\");\n\n  // Parsing URLs can be expensive, so we only perform these joins when needed.\n  if (sourceRoot) url = join(sourceRoot, url);\n  if (sourceMapURL) url = join(trimFilename(sourceMapURL), url);\n  return url;\n}\nexports.computeSourceURL = computeSourceURL;\n"]},"metadata":{},"sourceType":"script"}