{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = onDemandEntryHandler;\nexports.entries = exports.BUILDING = exports.ADDED = exports.BUILT = void 0;\n\nvar _events = require(\"events\");\n\nvar _path = require(\"path\");\n\nvar _url = require(\"url\");\n\nvar _webpack = require(\"next/dist/compiled/webpack/webpack\");\n\nvar Log = _interopRequireWildcard(require(\"../../build/output/log\"));\n\nvar _normalizePagePath = require(\"../normalize-page-path\");\n\nvar _require = require(\"../require\");\n\nvar _findPageFile = require(\"../lib/find-page-file\");\n\nvar _getRouteFromEntrypoint = _interopRequireDefault(require(\"../get-route-from-entrypoint\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nconst ADDED = Symbol('added');\nexports.ADDED = ADDED;\nconst BUILDING = Symbol('building');\nexports.BUILDING = BUILDING;\nconst BUILT = Symbol('built');\nexports.BUILT = BUILT;\nlet entries = {};\nexports.entries = entries;\n\nfunction onDemandEntryHandler(watcher, multiCompiler, {\n  pagesDir,\n  pageExtensions,\n  maxInactiveAge,\n  pagesBufferLength\n}) {\n  const {\n    compilers\n  } = multiCompiler;\n  const invalidator = new Invalidator(watcher, multiCompiler);\n  let lastAccessPages = [''];\n  let doneCallbacks = new _events.EventEmitter();\n\n  for (const compiler of compilers) {\n    compiler.hooks.make.tap('NextJsOnDemandEntries', _compilation => {\n      invalidator.startBuilding();\n    });\n  }\n\n  function getPagePathsFromEntrypoints(entrypoints) {\n    const pagePaths = [];\n\n    for (const entrypoint of entrypoints.values()) {\n      const page = (0, _getRouteFromEntrypoint).default(entrypoint.name);\n\n      if (page) {\n        pagePaths.push(page);\n      }\n    }\n\n    return pagePaths;\n  }\n\n  multiCompiler.hooks.done.tap('NextJsOnDemandEntries', multiStats => {\n    const [clientStats, serverStats] = multiStats.stats;\n    const pagePaths = new Set([...getPagePathsFromEntrypoints(clientStats.compilation.entrypoints), ...getPagePathsFromEntrypoints(serverStats.compilation.entrypoints)]);\n\n    for (const page of pagePaths) {\n      const entry = entries[page];\n\n      if (!entry) {\n        continue;\n      }\n\n      if (entry.status !== BUILDING) {\n        continue;\n      }\n\n      entry.status = BUILT;\n      entry.lastActiveTime = Date.now();\n      doneCallbacks.emit(page);\n    }\n\n    invalidator.doneBuilding();\n  });\n  const disposeHandler = setInterval(function () {\n    disposeInactiveEntries(watcher, lastAccessPages, maxInactiveAge);\n  }, 5000);\n  disposeHandler.unref();\n\n  function handlePing(pg) {\n    const page = (0, _normalizePagePath).normalizePathSep(pg);\n    const entryInfo = entries[page];\n    let toSend; // If there's no entry, it may have been invalidated and needs to be re-built.\n\n    if (!entryInfo) {\n      // if (page !== lastEntry) client pings, but there's no entry for page\n      return {\n        invalid: true\n      };\n    } // 404 is an on demand entry but when a new page is added we have to refresh the page\n\n\n    if (page === '/_error') {\n      toSend = {\n        invalid: true\n      };\n    } else {\n      toSend = {\n        success: true\n      };\n    } // We don't need to maintain active state of anything other than BUILT entries\n\n\n    if (entryInfo.status !== BUILT) return; // If there's an entryInfo\n\n    if (!lastAccessPages.includes(page)) {\n      lastAccessPages.unshift(page); // Maintain the buffer max length\n\n      if (lastAccessPages.length > pagesBufferLength) {\n        lastAccessPages.pop();\n      }\n    }\n\n    entryInfo.lastActiveTime = Date.now();\n    return toSend;\n  }\n\n  return {\n    async ensurePage(page) {\n      let normalizedPagePath;\n\n      try {\n        normalizedPagePath = (0, _normalizePagePath).normalizePagePath(page);\n      } catch (err) {\n        console.error(err);\n        throw (0, _require).pageNotFoundError(page);\n      }\n\n      let pagePath = await (0, _findPageFile).findPageFile(pagesDir, normalizedPagePath, pageExtensions); // Default the /_error route to the Next.js provided default page\n\n      if (page === '/_error' && pagePath === null) {\n        pagePath = 'next/dist/pages/_error';\n      }\n\n      if (pagePath === null) {\n        throw (0, _require).pageNotFoundError(normalizedPagePath);\n      }\n\n      let pageUrl = pagePath.replace(/\\\\/g, '/');\n      pageUrl = `${pageUrl[0] !== '/' ? '/' : ''}${pageUrl.replace(new RegExp(`\\\\.+(?:${pageExtensions.join('|')})$`), '').replace(/\\/index$/, '')}`;\n      pageUrl = pageUrl === '' ? '/' : pageUrl;\n      const bundleFile = (0, _normalizePagePath).normalizePagePath(pageUrl);\n\n      const serverBundlePath = _path.posix.join('pages', bundleFile);\n\n      const clientBundlePath = _path.posix.join('pages', bundleFile);\n\n      const absolutePagePath = pagePath.startsWith('next/dist/pages') ? require.resolve(pagePath) : (0, _path).join(pagesDir, pagePath);\n      page = _path.posix.normalize(pageUrl);\n      return new Promise((resolve, reject) => {\n        // Makes sure the page that is being kept in on-demand-entries matches the webpack output\n        const normalizedPage = (0, _normalizePagePath).normalizePathSep(page);\n        const entryInfo = entries[normalizedPage];\n\n        if (entryInfo) {\n          if (entryInfo.status === BUILT) {\n            resolve();\n            return;\n          }\n\n          if (entryInfo.status === BUILDING) {\n            doneCallbacks.once(normalizedPage, handleCallback);\n            return;\n          }\n        }\n\n        Log.event(`build page: ${normalizedPage}`);\n        entries[normalizedPage] = {\n          serverBundlePath,\n          clientBundlePath,\n          absolutePagePath,\n          status: ADDED\n        };\n        doneCallbacks.once(normalizedPage, handleCallback);\n        invalidator.invalidate();\n\n        function handleCallback(err) {\n          if (err) return reject(err);\n          resolve();\n        }\n      });\n    },\n\n    middleware(req, res, next) {\n      var ref;\n      if (!((ref = req.url) === null || ref === void 0 ? void 0 : ref.startsWith('/_next/webpack-hmr'))) return next();\n      const {\n        query\n      } = (0, _url).parse(req.url, true);\n      const page = query.page;\n      if (!page) return next();\n\n      const runPing = () => {\n        const data = handlePing(query.page);\n        if (!data) return;\n        res.write('data: ' + JSON.stringify(data) + '\\n\\n');\n      };\n\n      const pingInterval = setInterval(() => runPing(), 5000);\n      req.on('close', () => {\n        clearInterval(pingInterval);\n      });\n      next();\n    }\n\n  };\n}\n\nfunction disposeInactiveEntries(watcher, lastAccessPages, maxInactiveAge) {\n  const disposingPages = [];\n  Object.keys(entries).forEach(page => {\n    const {\n      lastActiveTime,\n      status\n    } = entries[page]; // This means this entry is currently building or just added\n    // We don't need to dispose those entries.\n\n    if (status !== BUILT) return; // We should not build the last accessed page even we didn't get any pings\n    // Sometimes, it's possible our XHR ping to wait before completing other requests.\n    // In that case, we should not dispose the current viewing page\n\n    if (lastAccessPages.includes(page)) return;\n\n    if (lastActiveTime && Date.now() - lastActiveTime > maxInactiveAge) {\n      disposingPages.push(page);\n    }\n  });\n\n  if (disposingPages.length > 0) {\n    disposingPages.forEach(page => {\n      delete entries[page];\n    }); // disposing inactive page(s)\n\n    watcher.invalidate();\n  }\n} // Make sure only one invalidation happens at a time\n// Otherwise, webpack hash gets changed and it'll force the client to reload.\n\n\nclass Invalidator {\n  constructor(watcher, multiCompiler) {\n    this.multiCompiler = multiCompiler;\n    this.watcher = watcher; // contains an array of types of compilers currently building\n\n    this.building = false;\n    this.rebuildAgain = false;\n  }\n\n  invalidate() {\n    // If there's a current build is processing, we won't abort it by invalidating.\n    // (If aborted, it'll cause a client side hard reload)\n    // But let it to invalidate just after the completion.\n    // So, it can re-build the queued pages at once.\n    if (this.building) {\n      this.rebuildAgain = true;\n      return;\n    }\n\n    this.building = true;\n\n    if (!_webpack.isWebpack5) {\n      // Work around a bug in webpack, calling `invalidate` on Watching.js\n      // doesn't trigger the invalid call used to keep track of the `.done` hook on multiCompiler\n      for (const compiler of this.multiCompiler.compilers) {\n        compiler.hooks.invalid.call();\n      }\n    }\n\n    this.watcher.invalidate();\n  }\n\n  startBuilding() {\n    this.building = true;\n  }\n\n  doneBuilding() {\n    this.building = false;\n\n    if (this.rebuildAgain) {\n      this.rebuildAgain = false;\n      this.invalidate();\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../server/dev/on-demand-entry-handler.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events'\nimport { IncomingMessage, ServerResponse } from 'http'\nimport { join, posix } from 'path'\nimport { parse } from 'url'\nimport { webpack, isWebpack5 } from 'next/dist/compiled/webpack/webpack'\nimport * as Log from '../../build/output/log'\nimport { normalizePagePath, normalizePathSep } from '../normalize-page-path'\nimport { pageNotFoundError } from '../require'\nimport { findPageFile } from '../lib/find-page-file'\nimport getRouteFromEntrypoint from '../get-route-from-entrypoint'\n\nexport const ADDED = Symbol('added')\nexport const BUILDING = Symbol('building')\nexport const BUILT = Symbol('built')\n\nexport let entries: {\n  [page: string]: {\n    serverBundlePath: string\n    clientBundlePath: string\n    absolutePagePath: string\n    status?: typeof ADDED | typeof BUILDING | typeof BUILT\n    lastActiveTime?: number\n  }\n} = {}\n\nexport default function onDemandEntryHandler(\n  watcher: any,\n  multiCompiler: webpack.MultiCompiler,\n  {\n    pagesDir,\n    pageExtensions,\n    maxInactiveAge,\n    pagesBufferLength,\n  }: {\n    pagesDir: string\n    pageExtensions: string[]\n    maxInactiveAge: number\n    pagesBufferLength: number\n  }\n) {\n  const { compilers } = multiCompiler\n  const invalidator = new Invalidator(watcher, multiCompiler)\n\n  let lastAccessPages = ['']\n  let doneCallbacks: EventEmitter | null = new EventEmitter()\n\n  for (const compiler of compilers) {\n    compiler.hooks.make.tap(\n      'NextJsOnDemandEntries',\n      (_compilation: webpack.compilation.Compilation) => {\n        invalidator.startBuilding()\n      }\n    )\n  }\n\n  function getPagePathsFromEntrypoints(entrypoints: any): string[] {\n    const pagePaths = []\n    for (const entrypoint of entrypoints.values()) {\n      const page = getRouteFromEntrypoint(entrypoint.name)\n      if (page) {\n        pagePaths.push(page)\n      }\n    }\n\n    return pagePaths\n  }\n\n  multiCompiler.hooks.done.tap('NextJsOnDemandEntries', (multiStats) => {\n    const [clientStats, serverStats] = multiStats.stats\n    const pagePaths = new Set([\n      ...getPagePathsFromEntrypoints(clientStats.compilation.entrypoints),\n      ...getPagePathsFromEntrypoints(serverStats.compilation.entrypoints),\n    ])\n\n    for (const page of pagePaths) {\n      const entry = entries[page]\n      if (!entry) {\n        continue\n      }\n\n      if (entry.status !== BUILDING) {\n        continue\n      }\n\n      entry.status = BUILT\n      entry.lastActiveTime = Date.now()\n      doneCallbacks!.emit(page)\n    }\n\n    invalidator.doneBuilding()\n  })\n\n  const disposeHandler = setInterval(function () {\n    disposeInactiveEntries(watcher, lastAccessPages, maxInactiveAge)\n  }, 5000)\n\n  disposeHandler.unref()\n\n  function handlePing(pg: string) {\n    const page = normalizePathSep(pg)\n    const entryInfo = entries[page]\n    let toSend\n\n    // If there's no entry, it may have been invalidated and needs to be re-built.\n    if (!entryInfo) {\n      // if (page !== lastEntry) client pings, but there's no entry for page\n      return { invalid: true }\n    }\n\n    // 404 is an on demand entry but when a new page is added we have to refresh the page\n    if (page === '/_error') {\n      toSend = { invalid: true }\n    } else {\n      toSend = { success: true }\n    }\n\n    // We don't need to maintain active state of anything other than BUILT entries\n    if (entryInfo.status !== BUILT) return\n\n    // If there's an entryInfo\n    if (!lastAccessPages.includes(page)) {\n      lastAccessPages.unshift(page)\n\n      // Maintain the buffer max length\n      if (lastAccessPages.length > pagesBufferLength) {\n        lastAccessPages.pop()\n      }\n    }\n    entryInfo.lastActiveTime = Date.now()\n    return toSend\n  }\n\n  return {\n    async ensurePage(page: string) {\n      let normalizedPagePath: string\n      try {\n        normalizedPagePath = normalizePagePath(page)\n      } catch (err) {\n        console.error(err)\n        throw pageNotFoundError(page)\n      }\n\n      let pagePath = await findPageFile(\n        pagesDir,\n        normalizedPagePath,\n        pageExtensions\n      )\n\n      // Default the /_error route to the Next.js provided default page\n      if (page === '/_error' && pagePath === null) {\n        pagePath = 'next/dist/pages/_error'\n      }\n\n      if (pagePath === null) {\n        throw pageNotFoundError(normalizedPagePath)\n      }\n\n      let pageUrl = pagePath.replace(/\\\\/g, '/')\n\n      pageUrl = `${pageUrl[0] !== '/' ? '/' : ''}${pageUrl\n        .replace(new RegExp(`\\\\.+(?:${pageExtensions.join('|')})$`), '')\n        .replace(/\\/index$/, '')}`\n\n      pageUrl = pageUrl === '' ? '/' : pageUrl\n\n      const bundleFile = normalizePagePath(pageUrl)\n      const serverBundlePath = posix.join('pages', bundleFile)\n      const clientBundlePath = posix.join('pages', bundleFile)\n      const absolutePagePath = pagePath.startsWith('next/dist/pages')\n        ? require.resolve(pagePath)\n        : join(pagesDir, pagePath)\n\n      page = posix.normalize(pageUrl)\n\n      return new Promise<void>((resolve, reject) => {\n        // Makes sure the page that is being kept in on-demand-entries matches the webpack output\n        const normalizedPage = normalizePathSep(page)\n        const entryInfo = entries[normalizedPage]\n\n        if (entryInfo) {\n          if (entryInfo.status === BUILT) {\n            resolve()\n            return\n          }\n\n          if (entryInfo.status === BUILDING) {\n            doneCallbacks!.once(normalizedPage, handleCallback)\n            return\n          }\n        }\n\n        Log.event(`build page: ${normalizedPage}`)\n\n        entries[normalizedPage] = {\n          serverBundlePath,\n          clientBundlePath,\n          absolutePagePath,\n          status: ADDED,\n        }\n        doneCallbacks!.once(normalizedPage, handleCallback)\n\n        invalidator.invalidate()\n\n        function handleCallback(err: Error) {\n          if (err) return reject(err)\n          resolve()\n        }\n      })\n    },\n\n    middleware(req: IncomingMessage, res: ServerResponse, next: Function) {\n      if (!req.url?.startsWith('/_next/webpack-hmr')) return next()\n\n      const { query } = parse(req.url!, true)\n      const page = query.page\n      if (!page) return next()\n\n      const runPing = () => {\n        const data = handlePing(query.page as string)\n        if (!data) return\n        res.write('data: ' + JSON.stringify(data) + '\\n\\n')\n      }\n      const pingInterval = setInterval(() => runPing(), 5000)\n\n      req.on('close', () => {\n        clearInterval(pingInterval)\n      })\n      next()\n    },\n  }\n}\n\nfunction disposeInactiveEntries(\n  watcher: any,\n  lastAccessPages: any,\n  maxInactiveAge: number\n) {\n  const disposingPages: any = []\n\n  Object.keys(entries).forEach((page) => {\n    const { lastActiveTime, status } = entries[page]\n\n    // This means this entry is currently building or just added\n    // We don't need to dispose those entries.\n    if (status !== BUILT) return\n\n    // We should not build the last accessed page even we didn't get any pings\n    // Sometimes, it's possible our XHR ping to wait before completing other requests.\n    // In that case, we should not dispose the current viewing page\n    if (lastAccessPages.includes(page)) return\n\n    if (lastActiveTime && Date.now() - lastActiveTime > maxInactiveAge) {\n      disposingPages.push(page)\n    }\n  })\n\n  if (disposingPages.length > 0) {\n    disposingPages.forEach((page: any) => {\n      delete entries[page]\n    })\n    // disposing inactive page(s)\n    watcher.invalidate()\n  }\n}\n\n// Make sure only one invalidation happens at a time\n// Otherwise, webpack hash gets changed and it'll force the client to reload.\nclass Invalidator {\n  private multiCompiler: webpack.MultiCompiler\n  private watcher: any\n  private building: boolean\n  private rebuildAgain: boolean\n\n  constructor(watcher: any, multiCompiler: webpack.MultiCompiler) {\n    this.multiCompiler = multiCompiler\n    this.watcher = watcher\n    // contains an array of types of compilers currently building\n    this.building = false\n    this.rebuildAgain = false\n  }\n\n  invalidate() {\n    // If there's a current build is processing, we won't abort it by invalidating.\n    // (If aborted, it'll cause a client side hard reload)\n    // But let it to invalidate just after the completion.\n    // So, it can re-build the queued pages at once.\n    if (this.building) {\n      this.rebuildAgain = true\n      return\n    }\n\n    this.building = true\n    if (!isWebpack5) {\n      // Work around a bug in webpack, calling `invalidate` on Watching.js\n      // doesn't trigger the invalid call used to keep track of the `.done` hook on multiCompiler\n      for (const compiler of this.multiCompiler.compilers) {\n        compiler.hooks.invalid.call()\n      }\n    }\n\n    this.watcher.invalidate()\n  }\n\n  startBuilding() {\n    this.building = true\n  }\n\n  doneBuilding() {\n    this.building = false\n\n    if (this.rebuildAgain) {\n      this.rebuildAgain = false\n      this.invalidate()\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}