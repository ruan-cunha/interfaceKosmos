{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _zenObservable = _interopRequireDefault(require(\"next/dist/compiled/zen-observable\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nclass ResponseCache {\n  constructor(incrementalCache) {\n    this.incrementalCache = incrementalCache;\n    this.pendingResponses = new Map();\n  }\n\n  get(key, responseGenerator) {\n    const pendingResponse = key ? this.pendingResponses.get(key) : null;\n\n    if (pendingResponse) {\n      return pendingResponse;\n    }\n\n    let resolver = () => {};\n\n    let rejecter = () => {};\n\n    const promise = new Promise((resolve, reject) => {\n      resolver = resolve;\n      rejecter = reject;\n    });\n\n    if (key) {\n      this.pendingResponses.set(key, promise);\n    }\n\n    let resolved = false;\n\n    const resolve = cacheEntry => {\n      if (key) {\n        // Ensure all reads from the cache get the latest value.\n        this.pendingResponses.set(key, Promise.resolve(cacheEntry));\n      }\n\n      if (!resolved) {\n        resolved = true;\n        resolver(cacheEntry);\n      }\n    };\n\n    (async () => {\n      try {\n        const cachedResponse = key ? await this.incrementalCache.get(key) : null;\n\n        if (cachedResponse) {\n          var ref;\n          resolve({\n            revalidate: cachedResponse.curRevalidate,\n            value: ((ref = cachedResponse.value) === null || ref === void 0 ? void 0 : ref.kind) === 'PAGE' ? {\n              kind: 'PAGE',\n              html: _zenObservable.default.of(cachedResponse.value.html),\n              pageData: cachedResponse.value.pageData\n            } : cachedResponse.value\n          });\n\n          if (!cachedResponse.isStale) {\n            // The cached value is still valid, so we don't need\n            // to update it yet.\n            return;\n          }\n        }\n\n        const cacheEntry = await responseGenerator(resolved);\n        resolve(cacheEntry);\n\n        if (key && cacheEntry && typeof cacheEntry.revalidate !== 'undefined') {\n          var ref;\n          await this.incrementalCache.set(key, ((ref = cacheEntry.value) === null || ref === void 0 ? void 0 : ref.kind) === 'PAGE' ? {\n            kind: 'PAGE',\n            html: await (0, _utils).resultsToString([cacheEntry.value.html]),\n            pageData: cacheEntry.value.pageData\n          } : cacheEntry.value, cacheEntry.revalidate);\n        }\n      } catch (err) {\n        rejecter(err);\n      } finally {\n        if (key) {\n          this.pendingResponses.delete(key);\n        }\n      }\n    })();\n\n    return promise;\n  }\n\n}\n\nexports.default = ResponseCache;","map":{"version":3,"sources":["../../server/response-cache.ts"],"names":[],"mappings":"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","sourcesContent":["import Observable from 'next/dist/compiled/zen-observable'\nimport { IncrementalCache } from './incremental-cache'\nimport { RenderResult, resultsToString } from './utils'\n\ninterface CachedRedirectValue {\n  kind: 'REDIRECT'\n  props: Object\n}\n\ninterface CachedPageValue {\n  kind: 'PAGE'\n  html: RenderResult\n  pageData: Object\n}\n\nexport type ResponseCacheValue = CachedRedirectValue | CachedPageValue\n\nexport type ResponseCacheEntry = {\n  revalidate?: number | false\n  value: ResponseCacheValue | null\n}\n\ntype ResponseGenerator = (\n  hasResolved: boolean\n) => Promise<ResponseCacheEntry | null>\n\nexport default class ResponseCache {\n  incrementalCache: IncrementalCache\n  pendingResponses: Map<string, Promise<ResponseCacheEntry | null>>\n\n  constructor(incrementalCache: IncrementalCache) {\n    this.incrementalCache = incrementalCache\n    this.pendingResponses = new Map()\n  }\n\n  public get(\n    key: string | null,\n    responseGenerator: ResponseGenerator\n  ): Promise<ResponseCacheEntry | null> {\n    const pendingResponse = key ? this.pendingResponses.get(key) : null\n    if (pendingResponse) {\n      return pendingResponse\n    }\n\n    let resolver: (cacheEntry: ResponseCacheEntry | null) => void = () => {}\n    let rejecter: (error: Error) => void = () => {}\n    const promise: Promise<ResponseCacheEntry | null> = new Promise(\n      (resolve, reject) => {\n        resolver = resolve\n        rejecter = reject\n      }\n    )\n    if (key) {\n      this.pendingResponses.set(key, promise)\n    }\n\n    let resolved = false\n    const resolve = (cacheEntry: ResponseCacheEntry | null) => {\n      if (key) {\n        // Ensure all reads from the cache get the latest value.\n        this.pendingResponses.set(key, Promise.resolve(cacheEntry))\n      }\n      if (!resolved) {\n        resolved = true\n        resolver(cacheEntry)\n      }\n    }\n\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    ;(async () => {\n      try {\n        const cachedResponse = key ? await this.incrementalCache.get(key) : null\n        if (cachedResponse) {\n          resolve({\n            revalidate: cachedResponse.curRevalidate,\n            value:\n              cachedResponse.value?.kind === 'PAGE'\n                ? {\n                    kind: 'PAGE',\n                    html: Observable.of(cachedResponse.value.html),\n                    pageData: cachedResponse.value.pageData,\n                  }\n                : cachedResponse.value,\n          })\n          if (!cachedResponse.isStale) {\n            // The cached value is still valid, so we don't need\n            // to update it yet.\n            return\n          }\n        }\n\n        const cacheEntry = await responseGenerator(resolved)\n        resolve(cacheEntry)\n\n        if (key && cacheEntry && typeof cacheEntry.revalidate !== 'undefined') {\n          await this.incrementalCache.set(\n            key,\n            cacheEntry.value?.kind === 'PAGE'\n              ? {\n                  kind: 'PAGE',\n                  html: await resultsToString([cacheEntry.value.html]),\n                  pageData: cacheEntry.value.pageData,\n                }\n              : cacheEntry.value,\n            cacheEntry.revalidate\n          )\n        }\n      } catch (err) {\n        rejecter(err)\n      } finally {\n        if (key) {\n          this.pendingResponses.delete(key)\n        }\n      }\n    })()\n    return promise\n  }\n}\n"]},"metadata":{},"sourceType":"script"}