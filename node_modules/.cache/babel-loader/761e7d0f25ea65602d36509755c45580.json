{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = resolveRewrites;\n\nvar _pathMatch = _interopRequireDefault(require(\"./path-match\"));\n\nvar _prepareDestination = _interopRequireWildcard(require(\"./prepare-destination\"));\n\nvar _normalizeTrailingSlash = require(\"../../../../client/normalize-trailing-slash\");\n\nvar _normalizeLocalePath = require(\"../../i18n/normalize-locale-path\");\n\nvar _parseRelativeUrl = require(\"./parse-relative-url\");\n\nvar _router = require(\"../router\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nconst customRouteMatcher = (0, _pathMatch).default(true);\n\nfunction resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {\n  let matchedPage = false;\n  let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n  let fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath((0, _router).delBasePath(parsedAs.pathname), locales).pathname);\n  let resolvedHref;\n\n  const handleRewrite = rewrite => {\n    const matcher = customRouteMatcher(rewrite.source);\n    let params = matcher(parsedAs.pathname);\n\n    if (rewrite.has && params) {\n      const hasParams = (0, _prepareDestination).matchHas({\n        headers: {\n          host: document.location.hostname\n        },\n        cookies: document.cookie.split('; ').reduce((acc, item) => {\n          const [key, ...value] = item.split('=');\n          acc[key] = value.join('=');\n          return acc;\n        }, {})\n      }, rewrite.has, parsedAs.query);\n\n      if (hasParams) {\n        Object.assign(params, hasParams);\n      } else {\n        params = false;\n      }\n    }\n\n    if (params) {\n      if (!rewrite.destination) {\n        // this is a proxied rewrite which isn't handled on the client\n        return true;\n      }\n\n      const destRes = (0, _prepareDestination).default(rewrite.destination, params, query, true);\n      parsedAs = destRes.parsedDestination;\n      asPath = destRes.newUrl;\n      Object.assign(query, destRes.parsedDestination.query);\n      fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath((0, _router).delBasePath(asPath), locales).pathname);\n\n      if (pages.includes(fsPathname)) {\n        // check if we now match a page as this means we are done\n        // resolving the rewrites\n        matchedPage = true;\n        resolvedHref = fsPathname;\n        return true;\n      } // check if we match a dynamic-route, if so we break the rewrites chain\n\n\n      resolvedHref = resolveHref(fsPathname);\n\n      if (resolvedHref !== asPath && pages.includes(resolvedHref)) {\n        matchedPage = true;\n        return true;\n      }\n    }\n  };\n\n  let finished = false;\n\n  for (let i = 0; i < rewrites.beforeFiles.length; i++) {\n    // we don't end after match in beforeFiles to allow\n    // continuing through all beforeFiles rewrites\n    handleRewrite(rewrites.beforeFiles[i]);\n  }\n\n  matchedPage = pages.includes(fsPathname);\n\n  if (!matchedPage) {\n    if (!finished) {\n      for (let i1 = 0; i1 < rewrites.afterFiles.length; i1++) {\n        if (handleRewrite(rewrites.afterFiles[i1])) {\n          finished = true;\n          break;\n        }\n      }\n    } // check dynamic route before processing fallback rewrites\n\n\n    if (!finished) {\n      resolvedHref = resolveHref(fsPathname);\n      matchedPage = pages.includes(resolvedHref);\n      finished = matchedPage;\n    }\n\n    if (!finished) {\n      for (let i1 = 0; i1 < rewrites.fallback.length; i1++) {\n        if (handleRewrite(rewrites.fallback[i1])) {\n          finished = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return {\n    asPath,\n    parsedAs,\n    matchedPage,\n    resolvedHref\n  };\n}","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/resolve-rewrites.ts"],"names":[],"mappings":"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","sourcesContent":["import { ParsedUrlQuery } from 'querystring'\nimport pathMatch from './path-match'\nimport prepareDestination, { matchHas } from './prepare-destination'\nimport { Rewrite } from '../../../../lib/load-custom-routes'\nimport { removePathTrailingSlash } from '../../../../client/normalize-trailing-slash'\nimport { normalizeLocalePath } from '../../i18n/normalize-locale-path'\nimport { parseRelativeUrl } from './parse-relative-url'\nimport { delBasePath } from '../router'\n\nconst customRouteMatcher = pathMatch(true)\n\nexport default function resolveRewrites(\n  asPath: string,\n  pages: string[],\n  rewrites: {\n    beforeFiles: Rewrite[]\n    afterFiles: Rewrite[]\n    fallback: Rewrite[]\n  },\n  query: ParsedUrlQuery,\n  resolveHref: (path: string) => string,\n  locales?: string[]\n): {\n  matchedPage: boolean\n  parsedAs: ReturnType<typeof parseRelativeUrl>\n  asPath: string\n  resolvedHref?: string\n} {\n  let matchedPage = false\n  let parsedAs = parseRelativeUrl(asPath)\n  let fsPathname = removePathTrailingSlash(\n    normalizeLocalePath(delBasePath(parsedAs.pathname), locales).pathname\n  )\n  let resolvedHref\n\n  const handleRewrite = (rewrite: Rewrite) => {\n    const matcher = customRouteMatcher(rewrite.source)\n    let params = matcher(parsedAs.pathname)\n\n    if (rewrite.has && params) {\n      const hasParams = matchHas(\n        {\n          headers: {\n            host: document.location.hostname,\n          },\n          cookies: document.cookie\n            .split('; ')\n            .reduce<Record<string, string>>((acc, item) => {\n              const [key, ...value] = item.split('=')\n              acc[key] = value.join('=')\n              return acc\n            }, {}),\n        } as any,\n        rewrite.has,\n        parsedAs.query\n      )\n\n      if (hasParams) {\n        Object.assign(params, hasParams)\n      } else {\n        params = false\n      }\n    }\n\n    if (params) {\n      if (!rewrite.destination) {\n        // this is a proxied rewrite which isn't handled on the client\n        return true\n      }\n      const destRes = prepareDestination(\n        rewrite.destination,\n        params,\n        query,\n        true\n      )\n      parsedAs = destRes.parsedDestination\n      asPath = destRes.newUrl\n      Object.assign(query, destRes.parsedDestination.query)\n\n      fsPathname = removePathTrailingSlash(\n        normalizeLocalePath(delBasePath(asPath), locales).pathname\n      )\n\n      if (pages.includes(fsPathname)) {\n        // check if we now match a page as this means we are done\n        // resolving the rewrites\n        matchedPage = true\n        resolvedHref = fsPathname\n        return true\n      }\n\n      // check if we match a dynamic-route, if so we break the rewrites chain\n      resolvedHref = resolveHref(fsPathname)\n\n      if (resolvedHref !== asPath && pages.includes(resolvedHref)) {\n        matchedPage = true\n        return true\n      }\n    }\n  }\n  let finished = false\n\n  for (let i = 0; i < rewrites.beforeFiles.length; i++) {\n    // we don't end after match in beforeFiles to allow\n    // continuing through all beforeFiles rewrites\n    handleRewrite(rewrites.beforeFiles[i])\n  }\n  matchedPage = pages.includes(fsPathname)\n\n  if (!matchedPage) {\n    if (!finished) {\n      for (let i = 0; i < rewrites.afterFiles.length; i++) {\n        if (handleRewrite(rewrites.afterFiles[i])) {\n          finished = true\n          break\n        }\n      }\n    }\n\n    // check dynamic route before processing fallback rewrites\n    if (!finished) {\n      resolvedHref = resolveHref(fsPathname)\n      matchedPage = pages.includes(resolvedHref)\n      finished = matchedPage\n    }\n\n    if (!finished) {\n      for (let i = 0; i < rewrites.fallback.length; i++) {\n        if (handleRewrite(rewrites.fallback[i])) {\n          finished = true\n          break\n        }\n      }\n    }\n  }\n\n  return {\n    asPath,\n    parsedAs,\n    matchedPage,\n    resolvedHref,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}