{"ast":null,"code":"'use strict';\n\nconst Hoek = require('@hapi/hoek');\n\nconst Boom = require('@hapi/boom');\n\nconst internals = {};\n\nexports.selection = function (header, preferences) {\n  const selections = exports.selections(header, preferences);\n  return selections.length ? selections[0] : '';\n};\n\nexports.selections = function (header, preferences) {\n  Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');\n  return internals.parse(header, preferences);\n}; //      RFC 7231 Section 5.3.2 (https://tools.ietf.org/html/rfc7231#section-5.3.2)\n//\n//      Accept          = [ ( \",\" / ( media-range [ accept-params ] ) ) *( OWS \",\" [ OWS ( media-range [ accept-params ] ) ] ) ]\n//      media-range     = ( \"*/*\" / ( type \"/*\" ) / ( type \"/\" subtype ) ) *( OWS \";\" OWS parameter )\n//      accept-params   = weight *accept-ext\n//      accept-ext      = OWS \";\" OWS token [ \"=\" ( token / quoted-string ) ]\n//      type            = token\n//      subtype         = token\n//      parameter       = token \"=\" ( token / quoted-string )\n//\n//      quoted-string   = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n//      qdtext          = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text\n//      obs-text        = %x80-FF\n//      quoted-pair     = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n//      VCHAR           = %x21-7E                                ; visible (printing) characters\n//      token           = 1*tchar\n//      tchar           = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n//      OWS             = *( SP / HTAB )\n//\n//      Accept: audio/*; q=0.2, audio/basic\n//      Accept: text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c\n//      Accept: text/plain, application/json;q=0.5, text/html, */*; q = 0.1\n//      Accept: text/plain, application/json;q=0.5, text/html, text/drop;q=0\n//      Accept: text/*, text/plain, text/plain;format=flowed, */*\n//      Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5\n//      RFC 7231 Section 5.3.1 (https://tools.ietf.org/html/rfc7231#section-5.3.1)\n//\n//      The weight is normalized to a real number in the range 0 through 1,\n//      where 0.001 is the least preferred and 1 is the most preferred; a\n//      value of 0 means \"not acceptable\".  If no \"q\" parameter is present,\n//      the default weight is 1.\n//\n//       weight = OWS \";\" OWS \"q=\" qvalue\n//       qvalue = ( \"0\" [ \".\" 0*3DIGIT ] ) / ( \"1\" [ \".\" 0*3(\"0\") ] )\n//                         */*        type/*                              type/subtype\n\n\ninternals.validMediaRx = /^(?:\\*\\/\\*)|(?:[\\w\\!#\\$%&'\\*\\+\\-\\.\\^`\\|~]+\\/\\*)|(?:[\\w\\!#\\$%&'\\*\\+\\-\\.\\^`\\|~]+\\/[\\w\\!#\\$%&'\\*\\+\\-\\.\\^`\\|~]+)$/;\n\ninternals.parse = function (raw, preferences) {\n  // Normalize header (remove spaces and temporary remove quoted strings)\n  const {\n    header,\n    quoted\n  } = internals.normalize(raw); // Parse selections\n\n  const parts = header.split(',');\n  const selections = [];\n  const map = {};\n\n  for (let i = 0; i < parts.length; ++i) {\n    const part = parts[i];\n\n    if (!part) {\n      // Ignore empty parts or leading commas\n      continue;\n    } // Parse parameters\n\n\n    const pairs = part.split(';');\n    const token = pairs.shift().toLowerCase();\n\n    if (!internals.validMediaRx.test(token)) {\n      // Ignore invalid types\n      continue;\n    }\n\n    const selection = {\n      token,\n      params: {},\n      exts: {},\n      pos: i\n    }; // Parse key=value\n\n    let target = 'params';\n\n    for (const pair of pairs) {\n      const kv = pair.split('=');\n\n      if (kv.length !== 2 || !kv[1]) {\n        throw Boom.badRequest(`Invalid accept header`);\n      }\n\n      const key = kv[0];\n      let value = kv[1];\n\n      if (key === 'q' || key === 'Q') {\n        target = 'exts';\n        value = parseFloat(value);\n\n        if (!Number.isFinite(value) || value > 1 || value < 0.001 && value !== 0) {\n          value = 1;\n        }\n\n        selection.q = value;\n      } else {\n        if (value[0] === '\"') {\n          value = `\"${quoted[value]}\"`;\n        }\n\n        selection[target][kv[0]] = value;\n      }\n    }\n\n    const params = Object.keys(selection.params);\n    selection.original = [''].concat(params.map(key => `${key}=${selection.params[key]}`)).join(';');\n    selection.specificity = params.length;\n\n    if (selection.q === undefined) {\n      // Default no preference to q=1 (top preference)\n      selection.q = 1;\n    }\n\n    const tparts = selection.token.split('/');\n    selection.type = tparts[0];\n    selection.subtype = tparts[1];\n    map[selection.token] = selection;\n\n    if (selection.q) {\n      // Skip denied selections (q=0)\n      selections.push(selection);\n    }\n  } // Sort selection based on q and then position in header\n\n\n  selections.sort(internals.sort);\n  return internals.preferences(map, selections, preferences);\n};\n\ninternals.normalize = function (raw) {\n  raw = raw || '*/*';\n  const normalized = {\n    header: raw,\n    quoted: {}\n  };\n\n  if (raw.includes('\"')) {\n    let i = 0;\n    normalized.header = raw.replace(/=\"([^\"]*)\"/g, ($0, $1) => {\n      const key = '\"' + ++i;\n      normalized.quoted[key] = $1;\n      return '=' + key;\n    });\n  }\n\n  normalized.header = normalized.header.replace(/[ \\t]/g, '');\n  return normalized;\n};\n\ninternals.sort = function (a, b) {\n  // Sort by quality score\n  if (b.q !== a.q) {\n    return b.q - a.q;\n  } // Sort by type\n\n\n  if (a.type !== b.type) {\n    return internals.innerSort(a, b, 'type');\n  } // Sort by subtype\n\n\n  if (a.subtype !== b.subtype) {\n    return internals.innerSort(a, b, 'subtype');\n  } // Sort by specificity\n\n\n  if (a.specificity !== b.specificity) {\n    return b.specificity - a.specificity;\n  }\n\n  return a.pos - b.pos;\n};\n\ninternals.innerSort = function (a, b, key) {\n  const aFirst = -1;\n  const bFirst = 1;\n\n  if (a[key] === '*') {\n    return bFirst;\n  }\n\n  if (b[key] === '*') {\n    return aFirst;\n  }\n\n  return a[key] < b[key] ? aFirst : bFirst; // Group alphabetically\n};\n\ninternals.preferences = function (map, selections, preferences) {\n  // Return selections if no preferences\n  if (!preferences || !preferences.length) {\n    return selections.map(selection => selection.token + selection.original);\n  } // Map wildcards and filter selections to preferences\n\n\n  const lowers = Object.create(null);\n  const flat = Object.create(null);\n  let any = false;\n\n  for (const preference of preferences) {\n    const lower = preference.toLowerCase();\n    flat[lower] = preference;\n    const parts = lower.split('/');\n    const type = parts[0];\n    const subtype = parts[1];\n\n    if (type === '*') {\n      Hoek.assert(subtype === '*', 'Invalid media type preference contains wildcard type with a subtype');\n      any = true;\n      continue;\n    }\n\n    lowers[type] = lowers[type] || Object.create(null);\n    lowers[type][subtype] = preference;\n  }\n\n  const preferred = [];\n\n  for (const selection of selections) {\n    const token = selection.token;\n    const {\n      type,\n      subtype\n    } = map[token];\n    const subtypes = lowers[type]; // */*\n\n    if (type === '*') {\n      for (const preference of Object.keys(flat)) {\n        if (!map[preference]) {\n          preferred.push(flat[preference]);\n        }\n      }\n\n      if (any) {\n        preferred.push('*/*');\n      }\n\n      continue;\n    } // any\n\n\n    if (any) {\n      preferred.push((flat[token] || token) + selection.original);\n      continue;\n    } // type/subtype\n\n\n    if (subtype !== '*') {\n      const pref = flat[token];\n\n      if (pref || subtypes && subtypes['*']) {\n        preferred.push((pref || token) + selection.original);\n      }\n\n      continue;\n    } // type/*\n\n\n    if (subtypes) {\n      for (const psub of Object.keys(subtypes)) {\n        if (!map[`${type}/${psub}`]) {\n          preferred.push(subtypes[psub]);\n        }\n      }\n    }\n  }\n\n  return preferred;\n};","map":{"version":3,"sources":["C:/xampp/public_html/vamo/interface2/node_modules/@hapi/accept/lib/media.js"],"names":["Hoek","require","Boom","internals","exports","selection","header","preferences","selections","length","assert","Array","isArray","parse","validMediaRx","raw","quoted","normalize","parts","split","map","i","part","pairs","token","shift","toLowerCase","test","params","exts","pos","target","pair","kv","badRequest","key","value","parseFloat","Number","isFinite","q","Object","keys","original","concat","join","specificity","undefined","tparts","type","subtype","push","sort","normalized","includes","replace","$0","$1","a","b","innerSort","aFirst","bFirst","lowers","create","flat","any","preference","lower","preferred","subtypes","pref","psub"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Hoek = require('@hapi/hoek');\nconst Boom = require('@hapi/boom');\n\n\nconst internals = {};\n\n\nexports.selection = function (header, preferences) {\n\n    const selections = exports.selections(header, preferences);\n    return selections.length ? selections[0] : '';\n};\n\n\nexports.selections = function (header, preferences) {\n\n    Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');\n\n    return internals.parse(header, preferences);\n};\n\n\n//      RFC 7231 Section 5.3.2 (https://tools.ietf.org/html/rfc7231#section-5.3.2)\n//\n//      Accept          = [ ( \",\" / ( media-range [ accept-params ] ) ) *( OWS \",\" [ OWS ( media-range [ accept-params ] ) ] ) ]\n//      media-range     = ( \"*/*\" / ( type \"/*\" ) / ( type \"/\" subtype ) ) *( OWS \";\" OWS parameter )\n//      accept-params   = weight *accept-ext\n//      accept-ext      = OWS \";\" OWS token [ \"=\" ( token / quoted-string ) ]\n//      type            = token\n//      subtype         = token\n//      parameter       = token \"=\" ( token / quoted-string )\n//\n//      quoted-string   = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n//      qdtext          = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text\n//      obs-text        = %x80-FF\n//      quoted-pair     = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n//      VCHAR           = %x21-7E                                ; visible (printing) characters\n//      token           = 1*tchar\n//      tchar           = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n//      OWS             = *( SP / HTAB )\n//\n//      Accept: audio/*; q=0.2, audio/basic\n//      Accept: text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c\n//      Accept: text/plain, application/json;q=0.5, text/html, */*; q = 0.1\n//      Accept: text/plain, application/json;q=0.5, text/html, text/drop;q=0\n//      Accept: text/*, text/plain, text/plain;format=flowed, */*\n//      Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5\n\n\n//      RFC 7231 Section 5.3.1 (https://tools.ietf.org/html/rfc7231#section-5.3.1)\n//\n//      The weight is normalized to a real number in the range 0 through 1,\n//      where 0.001 is the least preferred and 1 is the most preferred; a\n//      value of 0 means \"not acceptable\".  If no \"q\" parameter is present,\n//      the default weight is 1.\n//\n//       weight = OWS \";\" OWS \"q=\" qvalue\n//       qvalue = ( \"0\" [ \".\" 0*3DIGIT ] ) / ( \"1\" [ \".\" 0*3(\"0\") ] )\n\n\n//                         */*        type/*                              type/subtype\ninternals.validMediaRx = /^(?:\\*\\/\\*)|(?:[\\w\\!#\\$%&'\\*\\+\\-\\.\\^`\\|~]+\\/\\*)|(?:[\\w\\!#\\$%&'\\*\\+\\-\\.\\^`\\|~]+\\/[\\w\\!#\\$%&'\\*\\+\\-\\.\\^`\\|~]+)$/;\n\n\ninternals.parse = function (raw, preferences) {\n\n    // Normalize header (remove spaces and temporary remove quoted strings)\n\n    const { header, quoted } = internals.normalize(raw);\n\n    // Parse selections\n\n    const parts = header.split(',');\n    const selections = [];\n    const map = {};\n\n    for (let i = 0; i < parts.length; ++i) {\n        const part = parts[i];\n        if (!part) {                                    // Ignore empty parts or leading commas\n            continue;\n        }\n\n        // Parse parameters\n\n        const pairs = part.split(';');\n        const token = pairs.shift().toLowerCase();\n\n        if (!internals.validMediaRx.test(token)) {       // Ignore invalid types\n            continue;\n        }\n\n        const selection = {\n            token,\n            params: {},\n            exts: {},\n            pos: i\n        };\n\n        // Parse key=value\n\n        let target = 'params';\n        for (const pair of pairs) {\n            const kv = pair.split('=');\n            if (kv.length !== 2 ||\n                !kv[1]) {\n\n                throw Boom.badRequest(`Invalid accept header`);\n            }\n\n            const key = kv[0];\n            let value = kv[1];\n\n            if (key === 'q' ||\n                key === 'Q') {\n\n                target = 'exts';\n\n                value = parseFloat(value);\n                if (!Number.isFinite(value) ||\n                    value > 1 ||\n                    (value < 0.001 && value !== 0)) {\n\n                    value = 1;\n                }\n\n                selection.q = value;\n            }\n            else {\n                if (value[0] === '\"') {\n                    value = `\"${quoted[value]}\"`;\n                }\n\n                selection[target][kv[0]] = value;\n            }\n        }\n\n        const params = Object.keys(selection.params);\n        selection.original = [''].concat(params.map((key) => `${key}=${selection.params[key]}`)).join(';');\n        selection.specificity = params.length;\n\n        if (selection.q === undefined) {     // Default no preference to q=1 (top preference)\n            selection.q = 1;\n        }\n\n        const tparts = selection.token.split('/');\n        selection.type = tparts[0];\n        selection.subtype = tparts[1];\n\n        map[selection.token] = selection;\n\n        if (selection.q) {                   // Skip denied selections (q=0)\n            selections.push(selection);\n        }\n    }\n\n    // Sort selection based on q and then position in header\n\n    selections.sort(internals.sort);\n\n    return internals.preferences(map, selections, preferences);\n};\n\n\ninternals.normalize = function (raw) {\n\n    raw = raw || '*/*';\n\n    const normalized = {\n        header: raw,\n        quoted: {}\n    };\n\n    if (raw.includes('\"')) {\n        let i = 0;\n        normalized.header = raw.replace(/=\"([^\"]*)\"/g, ($0, $1) => {\n\n            const key = '\"' + ++i;\n            normalized.quoted[key] = $1;\n            return '=' + key;\n        });\n    }\n\n    normalized.header = normalized.header.replace(/[ \\t]/g, '');\n    return normalized;\n};\n\n\ninternals.sort = function (a, b) {\n\n    // Sort by quality score\n\n    if (b.q !== a.q) {\n        return b.q - a.q;\n    }\n\n    // Sort by type\n\n    if (a.type !== b.type) {\n        return internals.innerSort(a, b, 'type');\n    }\n\n    // Sort by subtype\n\n    if (a.subtype !== b.subtype) {\n        return internals.innerSort(a, b, 'subtype');\n    }\n\n    // Sort by specificity\n\n    if (a.specificity !== b.specificity) {\n        return b.specificity - a.specificity;\n    }\n\n    return a.pos - b.pos;\n};\n\n\ninternals.innerSort = function (a, b, key) {\n\n    const aFirst = -1;\n    const bFirst = 1;\n\n    if (a[key] === '*') {\n        return bFirst;\n    }\n\n    if (b[key] === '*') {\n        return aFirst;\n    }\n\n    return a[key] < b[key] ? aFirst : bFirst;       // Group alphabetically\n};\n\n\ninternals.preferences = function (map, selections, preferences) {\n\n    // Return selections if no preferences\n\n    if (!preferences ||\n        !preferences.length) {\n\n        return selections.map((selection) => selection.token + selection.original);\n    }\n\n    // Map wildcards and filter selections to preferences\n\n    const lowers = Object.create(null);\n    const flat = Object.create(null);\n    let any = false;\n\n    for (const preference of preferences) {\n        const lower = preference.toLowerCase();\n        flat[lower] = preference;\n        const parts = lower.split('/');\n        const type = parts[0];\n        const subtype = parts[1];\n\n        if (type === '*') {\n            Hoek.assert(subtype === '*', 'Invalid media type preference contains wildcard type with a subtype');\n            any = true;\n            continue;\n        }\n\n        lowers[type] = lowers[type] || Object.create(null);\n        lowers[type][subtype] = preference;\n    }\n\n    const preferred = [];\n    for (const selection of selections) {\n        const token = selection.token;\n        const { type, subtype } = map[token];\n        const subtypes = lowers[type];\n\n        // */*\n\n        if (type === '*') {\n            for (const preference of Object.keys(flat)) {\n                if (!map[preference]) {\n                    preferred.push(flat[preference]);\n                }\n            }\n\n            if (any) {\n                preferred.push('*/*');\n            }\n\n            continue;\n        }\n\n        // any\n\n        if (any) {\n            preferred.push((flat[token] || token) + selection.original);\n            continue;\n        }\n\n        // type/subtype\n\n        if (subtype !== '*') {\n            const pref = flat[token];\n            if (pref ||\n                (subtypes && subtypes['*'])) {\n\n                preferred.push((pref || token) + selection.original);\n            }\n\n            continue;\n        }\n\n        // type/*\n\n        if (subtypes) {\n            for (const psub of Object.keys(subtypes)) {\n                if (!map[`${type}/${psub}`]) {\n                    preferred.push(subtypes[psub]);\n                }\n            }\n        }\n    }\n\n    return preferred;\n};\n"]},"metadata":{},"sourceType":"script"}