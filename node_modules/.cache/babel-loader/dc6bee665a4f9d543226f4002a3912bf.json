{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.runTypeCheck = runTypeCheck;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _diagnosticFormatter = require(\"./diagnosticFormatter\");\n\nvar _getTypeScriptConfiguration = require(\"./getTypeScriptConfiguration\");\n\nvar _writeConfigurationDefaults = require(\"./writeConfigurationDefaults\");\n\nvar _compileError = require(\"../compile-error\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nasync function runTypeCheck(ts, baseDir, tsConfigPath, cacheDir) {\n  const effectiveConfiguration = await (0, _getTypeScriptConfiguration).getTypeScriptConfiguration(ts, tsConfigPath);\n\n  if (effectiveConfiguration.fileNames.length < 1) {\n    return {\n      hasWarnings: false,\n      inputFilesCount: 0,\n      totalFilesCount: 0,\n      incremental: false\n    };\n  }\n\n  const requiredConfig = (0, _writeConfigurationDefaults).getRequiredConfiguration(ts);\n  const options = { ...effectiveConfiguration.options,\n    ...requiredConfig,\n    noEmit: true\n  };\n  let program;\n  let incremental = false;\n\n  if (options.incremental && cacheDir) {\n    incremental = true;\n    program = ts.createIncrementalProgram({\n      rootNames: effectiveConfiguration.fileNames,\n      options: { ...options,\n        incremental: true,\n        tsBuildInfoFile: _path.default.join(cacheDir, '.tsbuildinfo')\n      }\n    });\n  } else {\n    program = ts.createProgram(effectiveConfiguration.fileNames, options);\n  }\n\n  const result = program.emit(); // Intended to match:\n  // - pages/test.js\n  // - pages/apples.test.js\n  // - pages/__tests__/a.js\n  //\n  // But not:\n  // - pages/contest.js\n  // - pages/other.js\n  // - pages/test/a.js\n  //\n\n  const regexIgnoredFile = /[\\\\/]__(?:tests|mocks)__[\\\\/]|(?<=[\\\\/.])(?:spec|test)\\.[^\\\\/]+$/;\n  const allDiagnostics = ts.getPreEmitDiagnostics(program).concat(result.diagnostics).filter(d => !(d.file && regexIgnoredFile.test(d.file.fileName)));\n  var ref;\n  const firstError = (ref = allDiagnostics.find(d => d.category === _diagnosticFormatter.DiagnosticCategory.Error && Boolean(d.file))) !== null && ref !== void 0 ? ref : allDiagnostics.find(d => d.category === _diagnosticFormatter.DiagnosticCategory.Error);\n\n  if (firstError) {\n    throw new _compileError.CompileError(await (0, _diagnosticFormatter).getFormattedDiagnostic(ts, baseDir, firstError));\n  }\n\n  const warnings = await Promise.all(allDiagnostics.filter(d => d.category === _diagnosticFormatter.DiagnosticCategory.Warning).map(d => (0, _diagnosticFormatter).getFormattedDiagnostic(ts, baseDir, d)));\n  return {\n    hasWarnings: true,\n    warnings,\n    inputFilesCount: effectiveConfiguration.fileNames.length,\n    totalFilesCount: program.getSourceFiles().length,\n    incremental\n  };\n}","map":{"version":3,"sources":["../../../lib/typescript/runTypeCheck.ts"],"names":[],"mappings":"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","sourcesContent":["import path from 'path'\nimport {\n  DiagnosticCategory,\n  getFormattedDiagnostic,\n} from './diagnosticFormatter'\nimport { getTypeScriptConfiguration } from './getTypeScriptConfiguration'\nimport { getRequiredConfiguration } from './writeConfigurationDefaults'\n\nimport { CompileError } from '../compile-error'\n\nexport interface TypeCheckResult {\n  hasWarnings: boolean\n  warnings?: string[]\n  inputFilesCount: number\n  totalFilesCount: number\n  incremental: boolean\n}\n\nexport async function runTypeCheck(\n  ts: typeof import('typescript'),\n  baseDir: string,\n  tsConfigPath: string,\n  cacheDir?: string\n): Promise<TypeCheckResult> {\n  const effectiveConfiguration = await getTypeScriptConfiguration(\n    ts,\n    tsConfigPath\n  )\n\n  if (effectiveConfiguration.fileNames.length < 1) {\n    return {\n      hasWarnings: false,\n      inputFilesCount: 0,\n      totalFilesCount: 0,\n      incremental: false,\n    }\n  }\n  const requiredConfig = getRequiredConfiguration(ts)\n\n  const options = {\n    ...effectiveConfiguration.options,\n    ...requiredConfig,\n    noEmit: true,\n  }\n\n  let program:\n    | import('typescript').Program\n    | import('typescript').BuilderProgram\n  let incremental = false\n  if (options.incremental && cacheDir) {\n    incremental = true\n    program = ts.createIncrementalProgram({\n      rootNames: effectiveConfiguration.fileNames,\n      options: {\n        ...options,\n        incremental: true,\n        tsBuildInfoFile: path.join(cacheDir, '.tsbuildinfo'),\n      },\n    })\n  } else {\n    program = ts.createProgram(effectiveConfiguration.fileNames, options)\n  }\n  const result = program.emit()\n\n  // Intended to match:\n  // - pages/test.js\n  // - pages/apples.test.js\n  // - pages/__tests__/a.js\n  //\n  // But not:\n  // - pages/contest.js\n  // - pages/other.js\n  // - pages/test/a.js\n  //\n  const regexIgnoredFile =\n    /[\\\\/]__(?:tests|mocks)__[\\\\/]|(?<=[\\\\/.])(?:spec|test)\\.[^\\\\/]+$/\n  const allDiagnostics = ts\n    .getPreEmitDiagnostics(program as import('typescript').Program)\n    .concat(result.diagnostics)\n    .filter((d) => !(d.file && regexIgnoredFile.test(d.file.fileName)))\n\n  const firstError =\n    allDiagnostics.find(\n      (d) => d.category === DiagnosticCategory.Error && Boolean(d.file)\n    ) ?? allDiagnostics.find((d) => d.category === DiagnosticCategory.Error)\n\n  if (firstError) {\n    throw new CompileError(\n      await getFormattedDiagnostic(ts, baseDir, firstError)\n    )\n  }\n\n  const warnings = await Promise.all(\n    allDiagnostics\n      .filter((d) => d.category === DiagnosticCategory.Warning)\n      .map((d) => getFormattedDiagnostic(ts, baseDir, d))\n  )\n  return {\n    hasWarnings: true,\n    warnings,\n    inputFilesCount: effectiveConfiguration.fileNames.length,\n    totalFilesCount: program.getSourceFiles().length,\n    incremental,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}