{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.recursiveReadDir = recursiveReadDir;\n\nvar _fs = require(\"fs\");\n\nvar _path = require(\"path\");\n\nasync function recursiveReadDir(dir, filter, ignore, arr = [], rootDir = dir) {\n  const result = await _fs.promises.readdir(dir, {\n    withFileTypes: true\n  });\n  await Promise.all(result.map(async part => {\n    const absolutePath = (0, _path).join(dir, part.name);\n    if (ignore && ignore.test(part.name)) return; // readdir does not follow symbolic links\n    // if part is a symbolic link, follow it using stat\n\n    let isDirectory = part.isDirectory();\n\n    if (part.isSymbolicLink()) {\n      const stats = await _fs.promises.stat(absolutePath);\n      isDirectory = stats.isDirectory();\n    }\n\n    if (isDirectory) {\n      await recursiveReadDir(absolutePath, filter, ignore, arr, rootDir);\n      return;\n    }\n\n    if (!filter.test(part.name)) {\n      return;\n    }\n\n    arr.push(absolutePath.replace(rootDir, ''));\n  }));\n  return arr.sort();\n}","map":{"version":3,"sources":["../../lib/recursive-readdir.ts"],"names":[],"mappings":";;;;;QAWsB,gB,GAAA,gB;;AAXW,IAAA,GAAI,GAAA,OAAA,CAAA,IAAA,CAAJ;;AACZ,IAAA,KAAM,GAAA,OAAA,CAAA,MAAA,CAAN;;eAUC,gB,CACpB,G,EACA,M,EACA,M,EACA,GAAa,GAAA,E,EACb,OAAe,GAAG,G,EACC;AACnB,QAAM,MAAM,GAAA,MAlBmB,GAAI,CAAA,QAAJ,CAkBD,OAlBC,CAkBO,GAlBP,EAkBU;AAAI,IAAA,aAAa,EAAE;AAAnB,GAlBV,CAkB/B;QAEM,OAAO,CAAC,GAAR,CACJ,MAAM,CAAC,GAAP,CAAU,MAAQ,IAAR,IAAyB;AACjC,UAAM,YAAY,GAAA,CAAA,GArBH,KAqBG,EArBG,IAqBH,CAAQ,GAAR,EAAa,IAAI,CAAC,IAAlB,CAAlB;AACA,QAAI,MAAM,IAAI,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,IAAjB,CAAd,EAAmC,OAFF,CAIjC;AACA;;AACA,QAAI,WAAW,GAAG,IAAI,CAAC,WAAL,EAAlB;;AACA,QAAI,IAAI,CAAC,cAAL,EAAJ,EAA2B;AACzB,YAAM,KAAK,GAAA,MA7Bc,GAAI,CAAA,QAAJ,CA6BI,IA7BJ,CA6BS,YA7BT,CA6BzB;AACA,MAAA,WAAW,GAAG,KAAK,CAAC,WAAN,EAAd;AACD;;AAED,QAAI,WAAJ,EAAiB;YACT,gBAAgB,CAAC,YAAD,EAAe,MAAf,EAAuB,MAAvB,EAA+B,GAA/B,EAAoC,OAApC,C;;AAEvB;;AAED,QAAE,CAAG,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,IAAjB,CAAL,EAA6B;;AAE5B;;AAED,IAAA,GAAG,CAAC,IAAJ,CAAS,YAAY,CAAC,OAAb,CAAqB,OAArB,EAA4B,EAA5B,CAAT;AACD,GAtBD,CADI,C;SA0BC,GAAG,CAAC,IAAJ,E;AACR","sourcesContent":["import { Dirent, promises } from 'fs'\nimport { join } from 'path'\n\n/**\n * Recursively read directory\n * @param  {string} dir Directory to read\n * @param  {RegExp} filter Filter for the file name, only the name part is considered, not the full path\n * @param  {string[]=[]} arr This doesn't have to be provided, it's used for the recursion\n * @param  {string=dir`} rootDir Used to replace the initial path, only the relative path is left, it's faster than path.relative.\n * @returns Promise array holding all relative paths\n */\nexport async function recursiveReadDir(\n  dir: string,\n  filter: RegExp,\n  ignore?: RegExp,\n  arr: string[] = [],\n  rootDir: string = dir\n): Promise<string[]> {\n  const result = await promises.readdir(dir, { withFileTypes: true })\n\n  await Promise.all(\n    result.map(async (part: Dirent) => {\n      const absolutePath = join(dir, part.name)\n      if (ignore && ignore.test(part.name)) return\n\n      // readdir does not follow symbolic links\n      // if part is a symbolic link, follow it using stat\n      let isDirectory = part.isDirectory()\n      if (part.isSymbolicLink()) {\n        const stats = await promises.stat(absolutePath)\n        isDirectory = stats.isDirectory()\n      }\n\n      if (isDirectory) {\n        await recursiveReadDir(absolutePath, filter, ignore, arr, rootDir)\n        return\n      }\n\n      if (!filter.test(part.name)) {\n        return\n      }\n\n      arr.push(absolutePath.replace(rootDir, ''))\n    })\n  )\n\n  return arr.sort()\n}\n"]},"metadata":{},"sourceType":"script"}