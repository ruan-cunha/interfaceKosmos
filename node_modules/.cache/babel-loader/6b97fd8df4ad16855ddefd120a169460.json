{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSortedRoutes = getSortedRoutes;\n\nclass UrlNode {\n  insert(urlPath) {\n    this._insert(urlPath.split('/').filter(Boolean), [], false);\n  }\n\n  smoosh() {\n    return this._smoosh();\n  }\n\n  _smoosh(prefix = '/') {\n    const childrenPaths = [...this.children.keys()].sort();\n\n    if (this.slugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[]'), 1);\n    }\n\n    if (this.restSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[...]'), 1);\n    }\n\n    if (this.optionalRestSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1);\n    }\n\n    const routes = childrenPaths.map(c => this.children.get(c)._smoosh(`${prefix}${c}/`)).reduce((prev, curr) => [...prev, ...curr], []);\n\n    if (this.slugName !== null) {\n      routes.push(...this.children.get('[]')._smoosh(`${prefix}[${this.slugName}]/`));\n    }\n\n    if (!this.placeholder) {\n      const r = prefix === '/' ? '/' : prefix.slice(0, -1);\n\n      if (this.optionalRestSlugName != null) {\n        throw new Error(`You cannot define a route with the same specificity as a optional catch-all route (\"${r}\" and \"${r}[[...${this.optionalRestSlugName}]]\").`);\n      }\n\n      routes.unshift(r);\n    }\n\n    if (this.restSlugName !== null) {\n      routes.push(...this.children.get('[...]')._smoosh(`${prefix}[...${this.restSlugName}]/`));\n    }\n\n    if (this.optionalRestSlugName !== null) {\n      routes.push(...this.children.get('[[...]]')._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`));\n    }\n\n    return routes;\n  }\n\n  _insert(urlPaths, slugNames, isCatchAll) {\n    if (urlPaths.length === 0) {\n      this.placeholder = false;\n      return;\n    }\n\n    if (isCatchAll) {\n      throw new Error(`Catch-all must be the last part of the URL.`);\n    } // The next segment in the urlPaths list\n\n\n    let nextSegment = urlPaths[0]; // Check if the segment matches `[something]`\n\n    if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n      // Strip `[` and `]`, leaving only `something`\n      let segmentName = nextSegment.slice(1, -1);\n      let isOptional = false;\n\n      if (segmentName.startsWith('[') && segmentName.endsWith(']')) {\n        // Strip optional `[` and `]`, leaving only `something`\n        segmentName = segmentName.slice(1, -1);\n        isOptional = true;\n      }\n\n      if (segmentName.startsWith('...')) {\n        // Strip `...`, leaving only `something`\n        segmentName = segmentName.substring(3);\n        isCatchAll = true;\n      }\n\n      if (segmentName.startsWith('[') || segmentName.endsWith(']')) {\n        throw new Error(`Segment names may not start or end with extra brackets ('${segmentName}').`);\n      }\n\n      if (segmentName.startsWith('.')) {\n        throw new Error(`Segment names may not start with erroneous periods ('${segmentName}').`);\n      }\n\n      function handleSlug(previousSlug, nextSlug) {\n        if (previousSlug !== null) {\n          // If the specific segment already has a slug but the slug is not `something`\n          // This prevents collisions like:\n          // pages/[post]/index.js\n          // pages/[id]/index.js\n          // Because currently multiple dynamic params on the same segment level are not supported\n          if (previousSlug !== nextSlug) {\n            // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n            throw new Error(`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`);\n          }\n        }\n\n        slugNames.forEach(slug => {\n          if (slug === nextSlug) {\n            throw new Error(`You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`);\n          }\n\n          if (slug.replace(/\\W/g, '') === nextSegment.replace(/\\W/g, '')) {\n            throw new Error(`You cannot have the slug names \"${slug}\" and \"${nextSlug}\" differ only by non-word symbols within a single dynamic path`);\n          }\n        });\n        slugNames.push(nextSlug);\n      }\n\n      if (isCatchAll) {\n        if (isOptional) {\n          if (this.restSlugName != null) {\n            throw new Error(`You cannot use both an required and optional catch-all route at the same level (\"[...${this.restSlugName}]\" and \"${urlPaths[0]}\" ).`);\n          }\n\n          handleSlug(this.optionalRestSlugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n          this.optionalRestSlugName = segmentName; // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n\n          nextSegment = '[[...]]';\n        } else {\n          if (this.optionalRestSlugName != null) {\n            throw new Error(`You cannot use both an optional and required catch-all route at the same level (\"[[...${this.optionalRestSlugName}]]\" and \"${urlPaths[0]}\").`);\n          }\n\n          handleSlug(this.restSlugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n          this.restSlugName = segmentName; // nextSegment is overwritten to [...] so that it can later be sorted specifically\n\n          nextSegment = '[...]';\n        }\n      } else {\n        if (isOptional) {\n          throw new Error(`Optional route parameters are not yet supported (\"${urlPaths[0]}\").`);\n        }\n\n        handleSlug(this.slugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n        this.slugName = segmentName; // nextSegment is overwritten to [] so that it can later be sorted specifically\n\n        nextSegment = '[]';\n      }\n    } // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n\n\n    if (!this.children.has(nextSegment)) {\n      this.children.set(nextSegment, new UrlNode());\n    }\n\n    this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n  }\n\n  constructor() {\n    this.placeholder = true;\n    this.children = new Map();\n    this.slugName = null;\n    this.restSlugName = null;\n    this.optionalRestSlugName = null;\n  }\n\n}\n\nfunction getSortedRoutes(normalizedPages) {\n  // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n  // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n  // Only 1 dynamic segment per nesting level\n  // So in the case that is test/integration/dynamic-routing it'll be this:\n  // pages/[post]/comments.js\n  // pages/blog/[post]/comment/[id].js\n  // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n  // So in this case `UrlNode` created here has `this.slugName === 'post'`\n  // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n  // Instead what has to be passed through is the upwards path's dynamic names\n  const root = new UrlNode(); // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n\n  normalizedPages.forEach(pagePath => root.insert(pagePath)); // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n\n  return root.smoosh();\n}","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/sorted-routes.ts"],"names":[],"mappings":"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","sourcesContent":["class UrlNode {\n  placeholder: boolean = true\n  children: Map<string, UrlNode> = new Map()\n  slugName: string | null = null\n  restSlugName: string | null = null\n  optionalRestSlugName: string | null = null\n\n  insert(urlPath: string): void {\n    this._insert(urlPath.split('/').filter(Boolean), [], false)\n  }\n\n  smoosh(): string[] {\n    return this._smoosh()\n  }\n\n  private _smoosh(prefix: string = '/'): string[] {\n    const childrenPaths = [...this.children.keys()].sort()\n    if (this.slugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[]'), 1)\n    }\n    if (this.restSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[...]'), 1)\n    }\n    if (this.optionalRestSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1)\n    }\n\n    const routes = childrenPaths\n      .map((c) => this.children.get(c)!._smoosh(`${prefix}${c}/`))\n      .reduce((prev, curr) => [...prev, ...curr], [])\n\n    if (this.slugName !== null) {\n      routes.push(\n        ...this.children.get('[]')!._smoosh(`${prefix}[${this.slugName}]/`)\n      )\n    }\n\n    if (!this.placeholder) {\n      const r = prefix === '/' ? '/' : prefix.slice(0, -1)\n      if (this.optionalRestSlugName != null) {\n        throw new Error(\n          `You cannot define a route with the same specificity as a optional catch-all route (\"${r}\" and \"${r}[[...${this.optionalRestSlugName}]]\").`\n        )\n      }\n\n      routes.unshift(r)\n    }\n\n    if (this.restSlugName !== null) {\n      routes.push(\n        ...this.children\n          .get('[...]')!\n          ._smoosh(`${prefix}[...${this.restSlugName}]/`)\n      )\n    }\n\n    if (this.optionalRestSlugName !== null) {\n      routes.push(\n        ...this.children\n          .get('[[...]]')!\n          ._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`)\n      )\n    }\n\n    return routes\n  }\n\n  private _insert(\n    urlPaths: string[],\n    slugNames: string[],\n    isCatchAll: boolean\n  ): void {\n    if (urlPaths.length === 0) {\n      this.placeholder = false\n      return\n    }\n\n    if (isCatchAll) {\n      throw new Error(`Catch-all must be the last part of the URL.`)\n    }\n\n    // The next segment in the urlPaths list\n    let nextSegment = urlPaths[0]\n\n    // Check if the segment matches `[something]`\n    if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n      // Strip `[` and `]`, leaving only `something`\n      let segmentName = nextSegment.slice(1, -1)\n\n      let isOptional = false\n      if (segmentName.startsWith('[') && segmentName.endsWith(']')) {\n        // Strip optional `[` and `]`, leaving only `something`\n        segmentName = segmentName.slice(1, -1)\n        isOptional = true\n      }\n\n      if (segmentName.startsWith('...')) {\n        // Strip `...`, leaving only `something`\n        segmentName = segmentName.substring(3)\n        isCatchAll = true\n      }\n\n      if (segmentName.startsWith('[') || segmentName.endsWith(']')) {\n        throw new Error(\n          `Segment names may not start or end with extra brackets ('${segmentName}').`\n        )\n      }\n\n      if (segmentName.startsWith('.')) {\n        throw new Error(\n          `Segment names may not start with erroneous periods ('${segmentName}').`\n        )\n      }\n\n      function handleSlug(previousSlug: string | null, nextSlug: string) {\n        if (previousSlug !== null) {\n          // If the specific segment already has a slug but the slug is not `something`\n          // This prevents collisions like:\n          // pages/[post]/index.js\n          // pages/[id]/index.js\n          // Because currently multiple dynamic params on the same segment level are not supported\n          if (previousSlug !== nextSlug) {\n            // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n            throw new Error(\n              `You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`\n            )\n          }\n        }\n\n        slugNames.forEach((slug) => {\n          if (slug === nextSlug) {\n            throw new Error(\n              `You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`\n            )\n          }\n\n          if (slug.replace(/\\W/g, '') === nextSegment.replace(/\\W/g, '')) {\n            throw new Error(\n              `You cannot have the slug names \"${slug}\" and \"${nextSlug}\" differ only by non-word symbols within a single dynamic path`\n            )\n          }\n        })\n\n        slugNames.push(nextSlug)\n      }\n\n      if (isCatchAll) {\n        if (isOptional) {\n          if (this.restSlugName != null) {\n            throw new Error(\n              `You cannot use both an required and optional catch-all route at the same level (\"[...${this.restSlugName}]\" and \"${urlPaths[0]}\" ).`\n            )\n          }\n\n          handleSlug(this.optionalRestSlugName, segmentName)\n          // slugName is kept as it can only be one particular slugName\n          this.optionalRestSlugName = segmentName\n          // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n          nextSegment = '[[...]]'\n        } else {\n          if (this.optionalRestSlugName != null) {\n            throw new Error(\n              `You cannot use both an optional and required catch-all route at the same level (\"[[...${this.optionalRestSlugName}]]\" and \"${urlPaths[0]}\").`\n            )\n          }\n\n          handleSlug(this.restSlugName, segmentName)\n          // slugName is kept as it can only be one particular slugName\n          this.restSlugName = segmentName\n          // nextSegment is overwritten to [...] so that it can later be sorted specifically\n          nextSegment = '[...]'\n        }\n      } else {\n        if (isOptional) {\n          throw new Error(\n            `Optional route parameters are not yet supported (\"${urlPaths[0]}\").`\n          )\n        }\n        handleSlug(this.slugName, segmentName)\n        // slugName is kept as it can only be one particular slugName\n        this.slugName = segmentName\n        // nextSegment is overwritten to [] so that it can later be sorted specifically\n        nextSegment = '[]'\n      }\n    }\n\n    // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n    if (!this.children.has(nextSegment)) {\n      this.children.set(nextSegment, new UrlNode())\n    }\n\n    this.children\n      .get(nextSegment)!\n      ._insert(urlPaths.slice(1), slugNames, isCatchAll)\n  }\n}\n\nexport function getSortedRoutes(normalizedPages: string[]): string[] {\n  // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n  // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n  // Only 1 dynamic segment per nesting level\n\n  // So in the case that is test/integration/dynamic-routing it'll be this:\n  // pages/[post]/comments.js\n  // pages/blog/[post]/comment/[id].js\n  // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n  // So in this case `UrlNode` created here has `this.slugName === 'post'`\n  // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n  // Instead what has to be passed through is the upwards path's dynamic names\n  const root = new UrlNode()\n\n  // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n  normalizedPages.forEach((pagePath) => root.insert(pagePath))\n  // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n  return root.smoosh()\n}\n"]},"metadata":{},"sourceType":"script"}