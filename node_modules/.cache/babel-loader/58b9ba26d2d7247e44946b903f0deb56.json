{"ast":null,"code":"\"use strict\";\n\nconst {\n  loadBinding\n} = require('@node-rs/helper');\n\nconst path = require('path');\n/**\n * __dirname means load native addon from current dir\n * 'next-swc' is the name of native addon\n * the second arguments was decided by `napi.name` field in `package.json`\n * the third arguments was decided by `name` field in `package.json`\n * `loadBinding` helper will load `next-swc.[PLATFORM].node` from `__dirname` first\n * If failed to load addon, it will fallback to load from `next-swc-[PLATFORM]`\n */\n\n\nconst bindings = loadBinding(path.join(__dirname, '../../../native'), 'next-swc', '@next/swc');\n\nasync function transform(src, options) {\n  var ref;\n  const isModule = typeof src !== 'string';\n  options = options || {};\n\n  if (options === null || options === void 0 ? void 0 : (ref = options.jsc) === null || ref === void 0 ? void 0 : ref.parser) {\n    var _syntax;\n\n    options.jsc.parser.syntax = (_syntax = options.jsc.parser.syntax) !== null && _syntax !== void 0 ? _syntax : 'ecmascript';\n  }\n\n  const {\n    plugin,\n    ...newOptions\n  } = options;\n\n  if (plugin) {\n    var ref1;\n    const m = typeof src === 'string' ? await this.parse(src, options === null || options === void 0 ? void 0 : (ref1 = options.jsc) === null || ref1 === void 0 ? void 0 : ref1.parser) : src;\n    return this.transform(plugin(m), newOptions);\n  }\n\n  return bindings.transform(isModule ? JSON.stringify(src) : src, isModule, toBuffer(newOptions));\n}\n\nfunction transformSync(src, options) {\n  var ref2;\n  const isModule = typeof src !== 'string';\n  options = options || {};\n\n  if (options === null || options === void 0 ? void 0 : (ref2 = options.jsc) === null || ref2 === void 0 ? void 0 : ref2.parser) {\n    var _syntax;\n\n    options.jsc.parser.syntax = (_syntax = options.jsc.parser.syntax) !== null && _syntax !== void 0 ? _syntax : 'ecmascript';\n  }\n\n  const {\n    plugin,\n    ...newOptions\n  } = options;\n\n  if (plugin) {\n    var ref3;\n    const m = typeof src === 'string' ? this.parseSync(src, options === null || options === void 0 ? void 0 : (ref3 = options.jsc) === null || ref3 === void 0 ? void 0 : ref3.parser) : src;\n    return this.transformSync(plugin(m), newOptions);\n  }\n\n  return bindings.transformSync(isModule ? JSON.stringify(src) : src, isModule, toBuffer(newOptions));\n}\n\nfunction toBuffer(t) {\n  return Buffer.from(JSON.stringify(t));\n}\n\nmodule.exports.transform = transform;\nmodule.exports.transformSync = transformSync;","map":{"version":3,"sources":["../../../build/swc/index.js"],"names":[],"mappings":"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","sourcesContent":["const { loadBinding } = require('@node-rs/helper')\nconst path = require('path')\n\n/**\n * __dirname means load native addon from current dir\n * 'next-swc' is the name of native addon\n * the second arguments was decided by `napi.name` field in `package.json`\n * the third arguments was decided by `name` field in `package.json`\n * `loadBinding` helper will load `next-swc.[PLATFORM].node` from `__dirname` first\n * If failed to load addon, it will fallback to load from `next-swc-[PLATFORM]`\n */\nconst bindings = loadBinding(\n  path.join(__dirname, '../../../native'),\n  'next-swc',\n  '@next/swc'\n)\n\nasync function transform(src, options) {\n  const isModule = typeof src !== 'string'\n  options = options || {}\n\n  if (options?.jsc?.parser) {\n    options.jsc.parser.syntax = options.jsc.parser.syntax ?? 'ecmascript'\n  }\n\n  const { plugin, ...newOptions } = options\n\n  if (plugin) {\n    const m =\n      typeof src === 'string'\n        ? await this.parse(src, options?.jsc?.parser)\n        : src\n    return this.transform(plugin(m), newOptions)\n  }\n\n  return bindings.transform(\n    isModule ? JSON.stringify(src) : src,\n    isModule,\n    toBuffer(newOptions)\n  )\n}\n\nfunction transformSync(src, options) {\n  const isModule = typeof src !== 'string'\n  options = options || {}\n\n  if (options?.jsc?.parser) {\n    options.jsc.parser.syntax = options.jsc.parser.syntax ?? 'ecmascript'\n  }\n\n  const { plugin, ...newOptions } = options\n\n  if (plugin) {\n    const m =\n      typeof src === 'string' ? this.parseSync(src, options?.jsc?.parser) : src\n    return this.transformSync(plugin(m), newOptions)\n  }\n\n  return bindings.transformSync(\n    isModule ? JSON.stringify(src) : src,\n    isModule,\n    toBuffer(newOptions)\n  )\n}\n\nfunction toBuffer(t) {\n  return Buffer.from(JSON.stringify(t))\n}\n\nmodule.exports.transform = transform\nmodule.exports.transformSync = transformSync\n"]},"metadata":{},"sourceType":"script"}