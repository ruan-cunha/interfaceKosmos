{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fs = require(\"fs\");\n\nvar _lruCache = _interopRequireDefault(require(\"next/dist/compiled/lru-cache\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _constants = require(\"../shared/lib/constants\");\n\nvar _normalizePagePath = require(\"./normalize-page-path\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction toRoute(pathname) {\n  return pathname.replace(/\\/$/, '').replace(/\\/index$/, '') || '/';\n}\n\nclass IncrementalCache {\n  constructor({\n    max,\n    dev,\n    distDir,\n    pagesDir,\n    flushToDisk,\n    locales\n  }) {\n    this.incrementalOptions = {\n      dev,\n      distDir,\n      pagesDir,\n      flushToDisk: !dev && (typeof flushToDisk !== 'undefined' ? flushToDisk : true)\n    };\n    this.locales = locales;\n\n    if (dev) {\n      this.prerenderManifest = {\n        version: -1,\n        routes: {},\n        dynamicRoutes: {},\n        notFoundRoutes: [],\n        preview: null\n      };\n    } else {\n      this.prerenderManifest = JSON.parse((0, _fs).readFileSync(_path.default.join(distDir, _constants.PRERENDER_MANIFEST), 'utf8'));\n    }\n\n    if (process.env.__NEXT_TEST_MAX_ISR_CACHE) {\n      // Allow cache size to be overridden for testing purposes\n      max = parseInt(process.env.__NEXT_TEST_MAX_ISR_CACHE, 10);\n    }\n\n    if (max) {\n      this.cache = new _lruCache.default({\n        max,\n\n        length({\n          value\n        }) {\n          if (!value || value.kind === 'REDIRECT') return 25; // rough estimate of size of cache value\n\n          return value.html.length + JSON.stringify(value.pageData).length;\n        }\n\n      });\n    }\n  }\n\n  getSeedPath(pathname, ext) {\n    return _path.default.join(this.incrementalOptions.pagesDir, `${pathname}.${ext}`);\n  }\n\n  calculateRevalidate(pathname, fromTime) {\n    pathname = toRoute(pathname); // in development we don't have a prerender-manifest\n    // and default to always revalidating to allow easier debugging\n\n    if (this.incrementalOptions.dev) return new Date().getTime() - 1000;\n    const {\n      initialRevalidateSeconds\n    } = this.prerenderManifest.routes[pathname] || {\n      initialRevalidateSeconds: 1\n    };\n    const revalidateAfter = typeof initialRevalidateSeconds === 'number' ? initialRevalidateSeconds * 1000 + fromTime : initialRevalidateSeconds;\n    return revalidateAfter;\n  }\n\n  getFallback(page) {\n    page = (0, _normalizePagePath).normalizePagePath(page);\n    return _fs.promises.readFile(this.getSeedPath(page, 'html'), 'utf8');\n  } // get data from cache if available\n\n\n  async get(pathname) {\n    if (this.incrementalOptions.dev) return null;\n    pathname = (0, _normalizePagePath).normalizePagePath(pathname);\n    let data = this.cache && this.cache.get(pathname); // let's check the disk for seed data\n\n    if (!data) {\n      if (this.prerenderManifest.notFoundRoutes.includes(pathname)) {\n        const now = Date.now();\n        const revalidateAfter = this.calculateRevalidate(pathname, now);\n        data = {\n          value: null,\n          revalidateAfter: revalidateAfter !== false ? now : false\n        };\n      }\n\n      try {\n        const htmlPath = this.getSeedPath(pathname, 'html');\n        const html = await _fs.promises.readFile(htmlPath, 'utf8');\n        const {\n          mtime\n        } = await _fs.promises.stat(htmlPath);\n        const pageData = JSON.parse(await _fs.promises.readFile(this.getSeedPath(pathname, 'json'), 'utf8'));\n        data = {\n          revalidateAfter: this.calculateRevalidate(pathname, mtime.getTime()),\n          value: {\n            kind: 'PAGE',\n            html,\n            pageData\n          }\n        };\n\n        if (this.cache) {\n          this.cache.set(pathname, data);\n        }\n      } catch (_) {// unable to get data from disk\n      }\n    }\n\n    if (!data) {\n      return null;\n    }\n\n    if (data && data.revalidateAfter !== false && data.revalidateAfter < new Date().getTime()) {\n      data.isStale = true;\n    }\n\n    const manifestPath = toRoute(pathname);\n    const manifestEntry = this.prerenderManifest.routes[manifestPath];\n\n    if (data && manifestEntry) {\n      data.curRevalidate = manifestEntry.initialRevalidateSeconds;\n    }\n\n    return data;\n  } // populate the incremental cache with new data\n\n\n  async set(pathname, data, revalidateSeconds) {\n    if (this.incrementalOptions.dev) return;\n\n    if (typeof revalidateSeconds !== 'undefined') {\n      // TODO: Update this to not mutate the manifest from the\n      // build.\n      this.prerenderManifest.routes[pathname] = {\n        dataRoute: _path.default.posix.join('/_next/data', `${(0, _normalizePagePath).normalizePagePath(pathname)}.json`),\n        srcRoute: null,\n        initialRevalidateSeconds: revalidateSeconds\n      };\n    }\n\n    pathname = (0, _normalizePagePath).normalizePagePath(pathname);\n\n    if (this.cache) {\n      this.cache.set(pathname, {\n        revalidateAfter: this.calculateRevalidate(pathname, new Date().getTime()),\n        value: data\n      });\n    } // TODO: This option needs to cease to exist unless it stops mutating the\n    // `next build` output's manifest.\n\n\n    if (this.incrementalOptions.flushToDisk && (data === null || data === void 0 ? void 0 : data.kind) === 'PAGE') {\n      try {\n        const seedPath = this.getSeedPath(pathname, 'html');\n        await _fs.promises.mkdir(_path.default.dirname(seedPath), {\n          recursive: true\n        });\n        await _fs.promises.writeFile(seedPath, data.html, 'utf8');\n        await _fs.promises.writeFile(this.getSeedPath(pathname, 'json'), JSON.stringify(data.pageData), 'utf8');\n      } catch (error) {\n        // failed to flush to disk\n        console.warn('Failed to update prerender files for', pathname, error);\n      }\n    }\n  }\n\n}\n\nexports.IncrementalCache = IncrementalCache;","map":{"version":3,"sources":["../../server/incremental-cache.ts"],"names":[],"mappings":"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","sourcesContent":["import { promises, readFileSync } from 'fs'\nimport LRUCache from 'next/dist/compiled/lru-cache'\nimport path from 'path'\nimport { PrerenderManifest } from '../build'\nimport { PRERENDER_MANIFEST } from '../shared/lib/constants'\nimport { normalizePagePath } from './normalize-page-path'\n\nfunction toRoute(pathname: string): string {\n  return pathname.replace(/\\/$/, '').replace(/\\/index$/, '') || '/'\n}\n\ninterface CachedRedirectValue {\n  kind: 'REDIRECT'\n  props: Object\n}\n\ninterface CachedPageValue {\n  kind: 'PAGE'\n  html: string\n  pageData: Object\n}\n\nexport type IncrementalCacheValue = CachedRedirectValue | CachedPageValue\n\ntype IncrementalCacheEntry = {\n  curRevalidate?: number | false\n  // milliseconds to revalidate after\n  revalidateAfter: number | false\n  isStale?: boolean\n  value: IncrementalCacheValue | null\n}\n\nexport class IncrementalCache {\n  incrementalOptions: {\n    flushToDisk?: boolean\n    pagesDir?: string\n    distDir?: string\n    dev?: boolean\n  }\n\n  prerenderManifest: PrerenderManifest\n  cache?: LRUCache<string, IncrementalCacheEntry>\n  locales?: string[]\n\n  constructor({\n    max,\n    dev,\n    distDir,\n    pagesDir,\n    flushToDisk,\n    locales,\n  }: {\n    dev: boolean\n    max?: number\n    distDir: string\n    pagesDir: string\n    flushToDisk?: boolean\n    locales?: string[]\n  }) {\n    this.incrementalOptions = {\n      dev,\n      distDir,\n      pagesDir,\n      flushToDisk:\n        !dev && (typeof flushToDisk !== 'undefined' ? flushToDisk : true),\n    }\n    this.locales = locales\n\n    if (dev) {\n      this.prerenderManifest = {\n        version: -1 as any, // letting us know this doesn't conform to spec\n        routes: {},\n        dynamicRoutes: {},\n        notFoundRoutes: [],\n        preview: null as any, // `preview` is special case read in next-dev-server\n      }\n    } else {\n      this.prerenderManifest = JSON.parse(\n        readFileSync(path.join(distDir, PRERENDER_MANIFEST), 'utf8')\n      )\n    }\n\n    if (process.env.__NEXT_TEST_MAX_ISR_CACHE) {\n      // Allow cache size to be overridden for testing purposes\n      max = parseInt(process.env.__NEXT_TEST_MAX_ISR_CACHE, 10)\n    }\n\n    if (max) {\n      this.cache = new LRUCache({\n        max,\n        length({ value }) {\n          if (!value || value.kind === 'REDIRECT') return 25\n          // rough estimate of size of cache value\n          return value.html.length + JSON.stringify(value.pageData).length\n        },\n      })\n    }\n  }\n\n  private getSeedPath(pathname: string, ext: string): string {\n    return path.join(this.incrementalOptions.pagesDir!, `${pathname}.${ext}`)\n  }\n\n  private calculateRevalidate(\n    pathname: string,\n    fromTime: number\n  ): number | false {\n    pathname = toRoute(pathname)\n\n    // in development we don't have a prerender-manifest\n    // and default to always revalidating to allow easier debugging\n    if (this.incrementalOptions.dev) return new Date().getTime() - 1000\n\n    const { initialRevalidateSeconds } = this.prerenderManifest.routes[\n      pathname\n    ] || {\n      initialRevalidateSeconds: 1,\n    }\n    const revalidateAfter =\n      typeof initialRevalidateSeconds === 'number'\n        ? initialRevalidateSeconds * 1000 + fromTime\n        : initialRevalidateSeconds\n\n    return revalidateAfter\n  }\n\n  getFallback(page: string): Promise<string> {\n    page = normalizePagePath(page)\n    return promises.readFile(this.getSeedPath(page, 'html'), 'utf8')\n  }\n\n  // get data from cache if available\n  async get(pathname: string): Promise<IncrementalCacheEntry | null> {\n    if (this.incrementalOptions.dev) return null\n    pathname = normalizePagePath(pathname)\n\n    let data = this.cache && this.cache.get(pathname)\n\n    // let's check the disk for seed data\n    if (!data) {\n      if (this.prerenderManifest.notFoundRoutes.includes(pathname)) {\n        const now = Date.now()\n        const revalidateAfter = this.calculateRevalidate(pathname, now)\n        data = {\n          value: null,\n          revalidateAfter: revalidateAfter !== false ? now : false,\n        }\n      }\n\n      try {\n        const htmlPath = this.getSeedPath(pathname, 'html')\n        const html = await promises.readFile(htmlPath, 'utf8')\n        const { mtime } = await promises.stat(htmlPath)\n        const pageData = JSON.parse(\n          await promises.readFile(this.getSeedPath(pathname, 'json'), 'utf8')\n        )\n\n        data = {\n          revalidateAfter: this.calculateRevalidate(pathname, mtime.getTime()),\n          value: {\n            kind: 'PAGE',\n            html,\n            pageData,\n          },\n        }\n        if (this.cache) {\n          this.cache.set(pathname, data)\n        }\n      } catch (_) {\n        // unable to get data from disk\n      }\n    }\n    if (!data) {\n      return null\n    }\n\n    if (\n      data &&\n      data.revalidateAfter !== false &&\n      data.revalidateAfter < new Date().getTime()\n    ) {\n      data.isStale = true\n    }\n\n    const manifestPath = toRoute(pathname)\n    const manifestEntry = this.prerenderManifest.routes[manifestPath]\n\n    if (data && manifestEntry) {\n      data.curRevalidate = manifestEntry.initialRevalidateSeconds\n    }\n    return data\n  }\n\n  // populate the incremental cache with new data\n  async set(\n    pathname: string,\n    data: IncrementalCacheValue | null,\n    revalidateSeconds?: number | false\n  ) {\n    if (this.incrementalOptions.dev) return\n    if (typeof revalidateSeconds !== 'undefined') {\n      // TODO: Update this to not mutate the manifest from the\n      // build.\n      this.prerenderManifest.routes[pathname] = {\n        dataRoute: path.posix.join(\n          '/_next/data',\n          `${normalizePagePath(pathname)}.json`\n        ),\n        srcRoute: null, // FIXME: provide actual source route, however, when dynamically appending it doesn't really matter\n        initialRevalidateSeconds: revalidateSeconds,\n      }\n    }\n\n    pathname = normalizePagePath(pathname)\n    if (this.cache) {\n      this.cache.set(pathname, {\n        revalidateAfter: this.calculateRevalidate(\n          pathname,\n          new Date().getTime()\n        ),\n        value: data,\n      })\n    }\n\n    // TODO: This option needs to cease to exist unless it stops mutating the\n    // `next build` output's manifest.\n    if (this.incrementalOptions.flushToDisk && data?.kind === 'PAGE') {\n      try {\n        const seedPath = this.getSeedPath(pathname, 'html')\n        await promises.mkdir(path.dirname(seedPath), { recursive: true })\n        await promises.writeFile(seedPath, data.html, 'utf8')\n        await promises.writeFile(\n          this.getSeedPath(pathname, 'json'),\n          JSON.stringify(data.pageData),\n          'utf8'\n        )\n      } catch (error) {\n        // failed to flush to disk\n        console.warn('Failed to update prerender files for', pathname, error)\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}