{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _jestWorker = require(\"jest-worker\");\n\nvar _amphtmlValidator = _interopRequireDefault(require(\"next/dist/compiled/amphtml-validator\"));\n\nvar _findUp = _interopRequireDefault(require(\"next/dist/compiled/find-up\"));\n\nvar _path = require(\"path\");\n\nvar _watchpack = _interopRequireDefault(require(\"watchpack\"));\n\nvar _output = require(\"../../build/output\");\n\nvar _constants = require(\"../../lib/constants\");\n\nvar _fileExists = require(\"../../lib/file-exists\");\n\nvar _findPagesDir = require(\"../../lib/find-pages-dir\");\n\nvar _loadCustomRoutes = _interopRequireDefault(require(\"../../lib/load-custom-routes\"));\n\nvar _verifyTypeScriptSetup = require(\"../../lib/verifyTypeScriptSetup\");\n\nvar _constants1 = require(\"../../shared/lib/constants\");\n\nvar _utils = require(\"../../shared/lib/router/utils\");\n\nvar _nextServer = _interopRequireWildcard(require(\"../next-server\"));\n\nvar _normalizePagePath = require(\"../normalize-page-path\");\n\nvar _router = _interopRequireWildcard(require(\"../router\"));\n\nvar _events = require(\"../../telemetry/events\");\n\nvar _storage = require(\"../../telemetry/storage\");\n\nvar _trace = require(\"../../telemetry/trace\");\n\nvar _hotReloader = _interopRequireDefault(require(\"./hot-reloader\"));\n\nvar _findPageFile = require(\"../lib/find-page-file\");\n\nvar _utils1 = require(\"../lib/utils\");\n\nvar _coalescedFunction = require(\"../../lib/coalesced-function\");\n\nvar _loadComponents = require(\"../load-components\");\n\nvar _utils2 = require(\"../../shared/lib/utils\");\n\nvar _parseStack = require(\"@next/react-dev-overlay/lib/internal/helpers/parseStack\");\n\nvar _middleware = require(\"@next/react-dev-overlay/lib/middleware\");\n\nvar Log = _interopRequireWildcard(require(\"../../build/output/log\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n} // Load ReactDevOverlay only when needed\n\n\nlet ReactDevOverlayImpl;\n\nconst ReactDevOverlay = props => {\n  if (ReactDevOverlayImpl === undefined) {\n    ReactDevOverlayImpl = require('@next/react-dev-overlay/lib/client').ReactDevOverlay;\n  }\n\n  return ReactDevOverlayImpl(props);\n};\n\nclass DevServer extends _nextServer.default {\n  constructor(options) {\n    var ref, ref1;\n    super({ ...options,\n      dev: true\n    });\n    this.renderOpts.dev = true;\n    this.renderOpts.ErrorDebug = ReactDevOverlay;\n    this.devReady = new Promise(resolve => {\n      this.setDevReady = resolve;\n    });\n    var ref2;\n    this.renderOpts.ampSkipValidation = (ref2 = (ref = this.nextConfig.experimental) === null || ref === void 0 ? void 0 : (ref1 = ref.amp) === null || ref1 === void 0 ? void 0 : ref1.skipValidation) !== null && ref2 !== void 0 ? ref2 : false;\n\n    this.renderOpts.ampValidator = (html, pathname) => {\n      const validatorPath = this.nextConfig.experimental && this.nextConfig.experimental.amp && this.nextConfig.experimental.amp.validator;\n      return _amphtmlValidator.default.getInstance(validatorPath).then(validator => {\n        const result = validator.validateString(html);\n        (0, _output).ampValidation(pathname, result.errors.filter(e => e.severity === 'ERROR').filter(e => this._filterAmpDevelopmentScript(html, e)), result.errors.filter(e => e.severity !== 'ERROR'));\n      });\n    };\n\n    if (_fs.default.existsSync((0, _path).join(this.dir, 'static'))) {\n      console.warn(`The static directory has been deprecated in favor of the public directory. https://nextjs.org/docs/messages/static-dir-deprecated`);\n    }\n\n    this.isCustomServer = !options.isNextDevCommand;\n    this.pagesDir = (0, _findPagesDir).findPagesDir(this.dir);\n    this.staticPathsWorker = new _jestWorker.Worker(require.resolve('./static-paths-worker'), {\n      maxRetries: 1,\n      numWorkers: this.nextConfig.experimental.cpus,\n      enableWorkerThreads: this.nextConfig.experimental.workerThreads,\n      forkOptions: {\n        env: { ...process.env,\n          // discard --inspect/--inspect-brk flags from process.env.NODE_OPTIONS. Otherwise multiple Node.js debuggers\n          // would be started if user launch Next.js in debugging mode. The number of debuggers is linked to\n          // the number of workers Next.js tries to launch. The only worker users are interested in debugging\n          // is the main Next.js one\n          NODE_OPTIONS: (0, _utils1).getNodeOptionsWithoutInspect()\n        }\n      }\n    });\n    this.staticPathsWorker.getStdout().pipe(process.stdout);\n    this.staticPathsWorker.getStderr().pipe(process.stderr);\n  }\n\n  readBuildId() {\n    return 'development';\n  }\n\n  async addExportPathMapRoutes() {\n    // Makes `next export` exportPathMap work in development mode.\n    // So that the user doesn't have to define a custom server reading the exportPathMap\n    if (this.nextConfig.exportPathMap) {\n      console.log('Defining routes from exportPathMap');\n      const exportPathMap = await this.nextConfig.exportPathMap({}, {\n        dev: true,\n        dir: this.dir,\n        outDir: null,\n        distDir: this.distDir,\n        buildId: this.buildId\n      }) // In development we can't give a default path mapping\n      ;\n\n      for (const path in exportPathMap) {\n        const {\n          page,\n          query = {}\n        } = exportPathMap[path]; // We use unshift so that we're sure the routes is defined before Next's default routes\n\n        this.router.addFsRoute({\n          match: (0, _router).route(path),\n          type: 'route',\n          name: `${path} exportpathmap route`,\n          fn: async (req, res, _params, parsedUrl) => {\n            const {\n              query: urlQuery\n            } = parsedUrl;\n            Object.keys(urlQuery).filter(key => query[key] === undefined).forEach(key => console.warn(`Url '${path}' defines a query parameter '${key}' that is missing in exportPathMap`));\n            const mergedQuery = { ...urlQuery,\n              ...query\n            };\n            await this.render(req, res, page, mergedQuery, parsedUrl);\n            return {\n              finished: true\n            };\n          }\n        });\n      }\n    }\n  }\n\n  async startWatcher() {\n    if (this.webpackWatcher) {\n      return;\n    }\n\n    const regexPageExtension = new RegExp(`\\\\.+(?:${this.nextConfig.pageExtensions.join('|')})$`);\n    let resolved = false;\n    return new Promise((resolve, reject) => {\n      const pagesDir = this.pagesDir; // Watchpack doesn't emit an event for an empty directory\n\n      _fs.default.readdir(pagesDir, (_, files) => {\n        if (files === null || files === void 0 ? void 0 : files.length) {\n          return;\n        }\n\n        if (!resolved) {\n          resolve();\n          resolved = true;\n        }\n      });\n\n      let wp = this.webpackWatcher = new _watchpack.default();\n      wp.watch([], [pagesDir], 0);\n      wp.on('aggregated', () => {\n        const routedPages = [];\n        const knownFiles = wp.getTimeInfoEntries();\n\n        for (const [fileName, {\n          accuracy\n        }] of knownFiles) {\n          if (accuracy === undefined || !regexPageExtension.test(fileName)) {\n            continue;\n          }\n\n          let pageName = '/' + (0, _path).relative(pagesDir, fileName).replace(/\\\\+/g, '/');\n          pageName = pageName.replace(regexPageExtension, '');\n          pageName = pageName.replace(/\\/index$/, '') || '/';\n          routedPages.push(pageName);\n        }\n\n        try {\n          var ref3; // we serve a separate manifest with all pages for the client in\n          // dev mode so that we can match a page after a rewrite on the client\n          // before it has been built and is populated in the _buildManifest\n\n          const sortedRoutes = (0, _utils).getSortedRoutes(routedPages);\n\n          if (!((ref3 = this.sortedRoutes) === null || ref3 === void 0 ? void 0 : ref3.every((val, idx) => val === sortedRoutes[idx]))) {\n            // emit the change so clients fetch the update\n            this.hotReloader.send(undefined, {\n              devPagesManifest: true\n            });\n          }\n\n          this.sortedRoutes = sortedRoutes;\n          this.dynamicRoutes = this.sortedRoutes.filter(_utils.isDynamicRoute).map(page => ({\n            page,\n            match: (0, _utils).getRouteMatcher((0, _utils).getRouteRegex(page))\n          }));\n          this.router.setDynamicRoutes(this.dynamicRoutes);\n\n          if (!resolved) {\n            resolve();\n            resolved = true;\n          }\n        } catch (e) {\n          if (!resolved) {\n            reject(e);\n            resolved = true;\n          } else {\n            console.warn('Failed to reload dynamic routes:', e);\n          }\n        }\n      });\n    });\n  }\n\n  async stopWatcher() {\n    if (!this.webpackWatcher) {\n      return;\n    }\n\n    this.webpackWatcher.close();\n    this.webpackWatcher = null;\n  }\n\n  async prepare() {\n    await (0, _verifyTypeScriptSetup).verifyTypeScriptSetup(this.dir, this.pagesDir, false, !this.nextConfig.images.disableStaticImages);\n    this.customRoutes = await (0, _loadCustomRoutes).default(this.nextConfig); // reload router\n\n    const {\n      redirects,\n      rewrites,\n      headers\n    } = this.customRoutes;\n\n    if (rewrites.beforeFiles.length || rewrites.afterFiles.length || rewrites.fallback.length || redirects.length || headers.length) {\n      this.router = new _router.default(this.generateRoutes());\n    }\n\n    this.hotReloader = new _hotReloader.default(this.dir, {\n      pagesDir: this.pagesDir,\n      config: this.nextConfig,\n      previewProps: this.getPreviewProps(),\n      buildId: this.buildId,\n      rewrites\n    });\n    await super.prepare();\n    await this.addExportPathMapRoutes();\n    await this.hotReloader.start();\n    await this.startWatcher();\n    this.setDevReady();\n    const telemetry = new _storage.Telemetry({\n      distDir: this.distDir\n    });\n    telemetry.record((0, _events).eventCliSession(_constants1.PHASE_DEVELOPMENT_SERVER, this.distDir, {\n      webpackVersion: this.hotReloader.isWebpack5 ? 5 : 4,\n      cliCommand: 'dev',\n      isSrcDir: (0, _path).relative(this.dir, this.pagesDir).startsWith('src'),\n      hasNowJson: !!(await (0, _findUp).default('now.json', {\n        cwd: this.dir\n      })),\n      isCustomServer: this.isCustomServer\n    })); // This is required by the tracing subsystem.\n\n    (0, _trace).setGlobal('telemetry', telemetry);\n    process.on('unhandledRejection', reason => {\n      this.logErrorWithOriginalStack(reason, 'unhandledRejection').catch(() => {});\n    });\n    process.on('uncaughtException', err => {\n      this.logErrorWithOriginalStack(err, 'uncaughtException').catch(() => {});\n    });\n  }\n\n  async close() {\n    await this.stopWatcher();\n    await this.staticPathsWorker.end();\n\n    if (this.hotReloader) {\n      await this.hotReloader.stop();\n    }\n  }\n\n  async hasPage(pathname) {\n    let normalizedPath;\n\n    try {\n      normalizedPath = (0, _normalizePagePath).normalizePagePath(pathname);\n    } catch (err) {\n      console.error(err); // if normalizing the page fails it means it isn't valid\n      // so it doesn't exist so don't throw and return false\n      // to ensure we return 404 instead of 500\n\n      return false;\n    }\n\n    const pageFile = await (0, _findPageFile).findPageFile(this.pagesDir, normalizedPath, this.nextConfig.pageExtensions);\n    return !!pageFile;\n  }\n\n  async _beforeCatchAllRender(req, res, params, parsedUrl) {\n    const {\n      pathname\n    } = parsedUrl;\n    const pathParts = params.path || [];\n    const path = `/${pathParts.join('/')}`; // check for a public file, throwing error if there's a\n    // conflicting page\n\n    let decodedPath;\n\n    try {\n      decodedPath = decodeURIComponent(path);\n    } catch (_) {\n      throw new _utils2.DecodeError('failed to decode param');\n    }\n\n    if (await this.hasPublicFile(decodedPath)) {\n      if (await this.hasPage(pathname)) {\n        const err = new Error(`A conflicting public file and page file was found for path ${pathname} https://nextjs.org/docs/messages/conflicting-public-file-page`);\n        res.statusCode = 500;\n        await this.renderError(err, req, res, pathname, {});\n        return true;\n      }\n\n      await this.servePublic(req, res, pathParts);\n      return true;\n    }\n\n    return false;\n  }\n\n  async run(req, res, parsedUrl) {\n    var ref4;\n    await this.devReady;\n    const {\n      basePath\n    } = this.nextConfig;\n    let originalPathname = null;\n\n    if (basePath && ((ref4 = parsedUrl.pathname) === null || ref4 === void 0 ? void 0 : ref4.startsWith(basePath))) {\n      // strip basePath before handling dev bundles\n      // If replace ends up replacing the full url it'll be `undefined`, meaning we have to default it to `/`\n      originalPathname = parsedUrl.pathname;\n      parsedUrl.pathname = parsedUrl.pathname.slice(basePath.length) || '/';\n    }\n\n    const {\n      pathname\n    } = parsedUrl;\n\n    if (pathname.startsWith('/_next')) {\n      if (await (0, _fileExists).fileExists((0, _path).join(this.publicDir, '_next'))) {\n        throw new Error(_constants.PUBLIC_DIR_MIDDLEWARE_CONFLICT);\n      }\n    }\n\n    const {\n      finished = false\n    } = await this.hotReloader.run(req, res, parsedUrl);\n\n    if (finished) {\n      return;\n    }\n\n    if (originalPathname) {\n      // restore the path before continuing so that custom-routes can accurately determine\n      // if they should match against the basePath or not\n      parsedUrl.pathname = originalPathname;\n    }\n\n    try {\n      return await super.run(req, res, parsedUrl);\n    } catch (err) {\n      res.statusCode = 500;\n\n      try {\n        this.logErrorWithOriginalStack(err).catch(() => {});\n        return await this.renderError(err, req, res, pathname, {\n          __NEXT_PAGE: (err === null || err === void 0 ? void 0 : err.page) || pathname\n        });\n      } catch (internalErr) {\n        console.error(internalErr);\n        res.end('Internal Server Error');\n      }\n    }\n  }\n\n  async logErrorWithOriginalStack(possibleError, type) {\n    let usedOriginalStack = false;\n\n    if ((possibleError === null || possibleError === void 0 ? void 0 : possibleError.name) && (possibleError === null || possibleError === void 0 ? void 0 : possibleError.stack) && (possibleError === null || possibleError === void 0 ? void 0 : possibleError.message)) {\n      const err = possibleError;\n\n      try {\n        const frames = (0, _parseStack).parseStack(err.stack);\n        const frame = frames[0];\n\n        if (frame.lineNumber && (frame === null || frame === void 0 ? void 0 : frame.file)) {\n          var ref5, ref6, ref7, ref8;\n          const compilation = (ref5 = this.hotReloader) === null || ref5 === void 0 ? void 0 : (ref6 = ref5.serverStats) === null || ref6 === void 0 ? void 0 : ref6.compilation;\n          const moduleId = frame.file.replace(/^(webpack-internal:\\/\\/\\/|file:\\/\\/)/, '');\n          const source = await (0, _middleware).getSourceById(!!((ref7 = frame.file) === null || ref7 === void 0 ? void 0 : ref7.startsWith(_path.sep)) || !!((ref8 = frame.file) === null || ref8 === void 0 ? void 0 : ref8.startsWith('file:')), moduleId, compilation, this.hotReloader.isWebpack5);\n          const originalFrame = await (0, _middleware).createOriginalStackFrame({\n            line: frame.lineNumber,\n            column: frame.column,\n            source,\n            frame,\n            modulePath: moduleId,\n            rootDirectory: this.dir\n          });\n\n          if (originalFrame) {\n            const {\n              originalCodeFrame,\n              originalStackFrame\n            } = originalFrame;\n            const {\n              file,\n              lineNumber,\n              column,\n              methodName\n            } = originalStackFrame;\n            console.error(_chalk.default.red('error') + ' - ' + `${file} (${lineNumber}:${column}) @ ${methodName}`);\n            console.error(`${_chalk.default.red(err.name)}: ${err.message}`);\n            console.error(originalCodeFrame);\n            usedOriginalStack = true;\n          }\n        }\n      } catch (_) {// failed to load original stack using source maps\n        // this un-actionable by users so we don't show the\n        // internal error and only show the provided stack\n      }\n    }\n\n    if (!usedOriginalStack) {\n      if (type) {\n        Log.error(`${type}:`, possibleError);\n      } else {\n        Log.error(possibleError);\n      }\n    }\n  } // override production loading of routes-manifest\n\n\n  getCustomRoutes() {\n    // actual routes will be loaded asynchronously during .prepare()\n    return {\n      redirects: [],\n      rewrites: {\n        beforeFiles: [],\n        afterFiles: [],\n        fallback: []\n      },\n      headers: []\n    };\n  }\n\n  getPreviewProps() {\n    if (this._devCachedPreviewProps) {\n      return this._devCachedPreviewProps;\n    }\n\n    return this._devCachedPreviewProps = {\n      previewModeId: _crypto.default.randomBytes(16).toString('hex'),\n      previewModeSigningKey: _crypto.default.randomBytes(32).toString('hex'),\n      previewModeEncryptionKey: _crypto.default.randomBytes(32).toString('hex')\n    };\n  }\n\n  generateRoutes() {\n    const {\n      fsRoutes,\n      ...otherRoutes\n    } = super.generateRoutes(); // In development we expose all compiled files for react-error-overlay's line show feature\n    // We use unshift so that we're sure the routes is defined before Next's default routes\n\n    fsRoutes.unshift({\n      match: (0, _router).route('/_next/development/:path*'),\n      type: 'route',\n      name: '_next/development catchall',\n      fn: async (req, res, params) => {\n        const p = (0, _path).join(this.distDir, ...(params.path || []));\n        await this.serveStatic(req, res, p);\n        return {\n          finished: true\n        };\n      }\n    });\n    fsRoutes.unshift({\n      match: (0, _router).route(`/_next/${_constants1.CLIENT_STATIC_FILES_PATH}/${this.buildId}/${_constants1.DEV_CLIENT_PAGES_MANIFEST}`),\n      type: 'route',\n      name: `_next/${_constants1.CLIENT_STATIC_FILES_PATH}/${this.buildId}/${_constants1.DEV_CLIENT_PAGES_MANIFEST}`,\n      fn: async (_req, res) => {\n        res.statusCode = 200;\n        res.setHeader('Content-Type', 'application/json; charset=utf-8');\n        res.end(JSON.stringify({\n          pages: this.sortedRoutes\n        }));\n        return {\n          finished: true\n        };\n      }\n    });\n    fsRoutes.push({\n      match: (0, _router).route('/:path*'),\n      type: 'route',\n      requireBasePath: false,\n      name: 'catchall public directory route',\n      fn: async (req, res, params, parsedUrl) => {\n        const {\n          pathname\n        } = parsedUrl;\n\n        if (!pathname) {\n          throw new Error('pathname is undefined');\n        } // Used in development to check public directory paths\n\n\n        if (await this._beforeCatchAllRender(req, res, params, parsedUrl)) {\n          return {\n            finished: true\n          };\n        }\n\n        return {\n          finished: false\n        };\n      }\n    });\n    return {\n      fsRoutes,\n      ...otherRoutes\n    };\n  } // In development public files are not added to the router but handled as a fallback instead\n\n\n  generatePublicRoutes() {\n    return [];\n  } // In development dynamic routes cannot be known ahead of time\n\n\n  getDynamicRoutes() {\n    return [];\n  }\n\n  _filterAmpDevelopmentScript(html, event) {\n    if (event.code !== 'DISALLOWED_SCRIPT_TAG') {\n      return true;\n    }\n\n    const snippetChunks = html.split('\\n');\n    let snippet;\n\n    if (!(snippet = html.split('\\n')[event.line - 1]) || !(snippet = snippet.substring(event.col))) {\n      return true;\n    }\n\n    snippet = snippet + snippetChunks.slice(event.line).join('\\n');\n    snippet = snippet.substring(0, snippet.indexOf('</script>'));\n    return !snippet.includes('data-amp-development-mode-only');\n  }\n\n  async getStaticPaths(pathname) {\n    // we lazy load the staticPaths to prevent the user\n    // from waiting on them for the page to load in dev mode\n    const __getStaticPaths = async () => {\n      const {\n        publicRuntimeConfig,\n        serverRuntimeConfig,\n        httpAgentOptions\n      } = this.nextConfig;\n      const {\n        locales,\n        defaultLocale\n      } = this.nextConfig.i18n || {};\n      const paths = await this.staticPathsWorker.loadStaticPaths(this.distDir, pathname, !this.renderOpts.dev && this._isLikeServerless, {\n        publicRuntimeConfig,\n        serverRuntimeConfig\n      }, httpAgentOptions, locales, defaultLocale);\n      return paths;\n    };\n\n    const {\n      paths: staticPaths,\n      fallback\n    } = (await (0, _coalescedFunction).withCoalescedInvoke(__getStaticPaths)(`staticPaths-${pathname}`, [])).value;\n    return {\n      staticPaths,\n      fallbackMode: fallback === 'blocking' ? 'blocking' : fallback === true ? 'static' : false\n    };\n  }\n\n  async ensureApiPage(pathname) {\n    return this.hotReloader.ensurePage(pathname);\n  }\n\n  async findPageComponents(pathname, query = {}, params = null) {\n    await this.devReady;\n    const compilationErr = await this.getCompilationError(pathname);\n\n    if (compilationErr) {\n      // Wrap build errors so that they don't get logged again\n      throw new _nextServer.WrappedBuildError(compilationErr);\n    }\n\n    try {\n      await this.hotReloader.ensurePage(pathname);\n      return super.findPageComponents(pathname, query, params);\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n\n      return null;\n    }\n  }\n\n  async getFallbackErrorComponents() {\n    await this.hotReloader.buildFallbackError(); // Build the error page to ensure the fallback is built too.\n    // TODO: See if this can be moved into hotReloader or removed.\n\n    await this.hotReloader.ensurePage('/_error');\n    return await (0, _loadComponents).loadDefaultErrorComponents(this.distDir);\n  }\n\n  setImmutableAssetCacheControl(res) {\n    res.setHeader('Cache-Control', 'no-store, must-revalidate');\n  }\n\n  servePublic(req, res, pathParts) {\n    const p = (0, _path).join(this.publicDir, ...pathParts);\n    return this.serveStatic(req, res, p);\n  }\n\n  async hasPublicFile(path) {\n    try {\n      const info = await _fs.default.promises.stat((0, _path).join(this.publicDir, path));\n      return info.isFile();\n    } catch (_) {\n      return false;\n    }\n  }\n\n  async getCompilationError(page) {\n    const errors = await this.hotReloader.getCompilationErrors(page);\n    if (errors.length === 0) return; // Return the very first error we found.\n\n    return errors[0];\n  }\n\n  isServeableUrl(untrustedFileUrl) {\n    // This method mimics what the version of `send` we use does:\n    // 1. decodeURIComponent:\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L989\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L518-L522\n    // 2. resolve:\n    //    https://github.com/pillarjs/send/blob/de073ed3237ade9ff71c61673a34474b30e5d45b/index.js#L561\n    let decodedUntrustedFilePath;\n\n    try {\n      // (1) Decode the URL so we have the proper file name\n      decodedUntrustedFilePath = decodeURIComponent(untrustedFileUrl);\n    } catch {\n      return false;\n    } // (2) Resolve \"up paths\" to determine real request\n\n\n    const untrustedFilePath = (0, _path).resolve(decodedUntrustedFilePath); // don't allow null bytes anywhere in the file path\n\n    if (untrustedFilePath.indexOf('\\x00') !== -1) {\n      return false;\n    } // During development mode, files can be added while the server is running.\n    // Checks for .next/static, .next/server, static and public.\n    // Note that in development .next/server is available for error reporting purposes.\n    // see `packages/next/server/next-server.ts` for more details.\n\n\n    if (untrustedFilePath.startsWith((0, _path).join(this.distDir, 'static') + _path.sep) || untrustedFilePath.startsWith((0, _path).join(this.distDir, 'server') + _path.sep) || untrustedFilePath.startsWith((0, _path).join(this.dir, 'static') + _path.sep) || untrustedFilePath.startsWith((0, _path).join(this.dir, 'public') + _path.sep)) {\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nexports.default = DevServer;","map":{"version":3,"sources":["../../../server/dev/next-dev-server.ts"],"names":[],"mappings":"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","sourcesContent":["import crypto from 'crypto'\nimport fs from 'fs'\nimport chalk from 'chalk'\nimport { IncomingMessage, ServerResponse } from 'http'\nimport { Worker } from 'jest-worker'\nimport AmpHtmlValidator from 'next/dist/compiled/amphtml-validator'\nimport findUp from 'next/dist/compiled/find-up'\nimport { join as pathJoin, relative, resolve as pathResolve, sep } from 'path'\nimport React from 'react'\nimport { UrlWithParsedQuery } from 'url'\nimport Watchpack from 'watchpack'\nimport { ampValidation } from '../../build/output'\nimport { PUBLIC_DIR_MIDDLEWARE_CONFLICT } from '../../lib/constants'\nimport { fileExists } from '../../lib/file-exists'\nimport { findPagesDir } from '../../lib/find-pages-dir'\nimport loadCustomRoutes, { CustomRoutes } from '../../lib/load-custom-routes'\nimport { verifyTypeScriptSetup } from '../../lib/verifyTypeScriptSetup'\nimport {\n  PHASE_DEVELOPMENT_SERVER,\n  CLIENT_STATIC_FILES_PATH,\n  DEV_CLIENT_PAGES_MANIFEST,\n} from '../../shared/lib/constants'\nimport {\n  getRouteMatcher,\n  getRouteRegex,\n  getSortedRoutes,\n  isDynamicRoute,\n} from '../../shared/lib/router/utils'\nimport { __ApiPreviewProps } from '../api-utils'\nimport Server, {\n  WrappedBuildError,\n  ServerConstructor,\n  FindComponentsResult,\n} from '../next-server'\nimport { normalizePagePath } from '../normalize-page-path'\nimport Router, { Params, route } from '../router'\nimport { eventCliSession } from '../../telemetry/events'\nimport { Telemetry } from '../../telemetry/storage'\nimport { setGlobal } from '../../telemetry/trace'\nimport HotReloader from './hot-reloader'\nimport { findPageFile } from '../lib/find-page-file'\nimport { getNodeOptionsWithoutInspect } from '../lib/utils'\nimport { withCoalescedInvoke } from '../../lib/coalesced-function'\nimport { NextConfig } from '../config'\nimport { ParsedUrlQuery } from 'querystring'\nimport {\n  LoadComponentsReturnType,\n  loadDefaultErrorComponents,\n} from '../load-components'\nimport { DecodeError } from '../../shared/lib/utils'\nimport { parseStack } from '@next/react-dev-overlay/lib/internal/helpers/parseStack'\nimport {\n  createOriginalStackFrame,\n  getSourceById,\n} from '@next/react-dev-overlay/lib/middleware'\nimport * as Log from '../../build/output/log'\n\n// Load ReactDevOverlay only when needed\nlet ReactDevOverlayImpl: React.FunctionComponent\nconst ReactDevOverlay = (props: any) => {\n  if (ReactDevOverlayImpl === undefined) {\n    ReactDevOverlayImpl =\n      require('@next/react-dev-overlay/lib/client').ReactDevOverlay\n  }\n  return ReactDevOverlayImpl(props)\n}\n\nexport default class DevServer extends Server {\n  private devReady: Promise<void>\n  private setDevReady?: Function\n  private webpackWatcher?: Watchpack | null\n  private hotReloader?: HotReloader\n  private isCustomServer: boolean\n  protected sortedRoutes?: string[]\n\n  protected staticPathsWorker: import('jest-worker').Worker & {\n    loadStaticPaths: typeof import('./static-paths-worker').loadStaticPaths\n  }\n\n  constructor(\n    options: ServerConstructor & {\n      conf: NextConfig\n      isNextDevCommand?: boolean\n    }\n  ) {\n    super({ ...options, dev: true })\n    this.renderOpts.dev = true\n    ;(this.renderOpts as any).ErrorDebug = ReactDevOverlay\n    this.devReady = new Promise((resolve) => {\n      this.setDevReady = resolve\n    })\n    ;(this.renderOpts as any).ampSkipValidation =\n      this.nextConfig.experimental?.amp?.skipValidation ?? false\n    ;(this.renderOpts as any).ampValidator = (\n      html: string,\n      pathname: string\n    ) => {\n      const validatorPath =\n        this.nextConfig.experimental &&\n        this.nextConfig.experimental.amp &&\n        this.nextConfig.experimental.amp.validator\n      return AmpHtmlValidator.getInstance(validatorPath).then((validator) => {\n        const result = validator.validateString(html)\n        ampValidation(\n          pathname,\n          result.errors\n            .filter((e) => e.severity === 'ERROR')\n            .filter((e) => this._filterAmpDevelopmentScript(html, e)),\n          result.errors.filter((e) => e.severity !== 'ERROR')\n        )\n      })\n    }\n    if (fs.existsSync(pathJoin(this.dir, 'static'))) {\n      console.warn(\n        `The static directory has been deprecated in favor of the public directory. https://nextjs.org/docs/messages/static-dir-deprecated`\n      )\n    }\n    this.isCustomServer = !options.isNextDevCommand\n    this.pagesDir = findPagesDir(this.dir)\n    this.staticPathsWorker = new Worker(\n      require.resolve('./static-paths-worker'),\n      {\n        maxRetries: 1,\n        numWorkers: this.nextConfig.experimental.cpus,\n        enableWorkerThreads: this.nextConfig.experimental.workerThreads,\n        forkOptions: {\n          env: {\n            ...process.env,\n            // discard --inspect/--inspect-brk flags from process.env.NODE_OPTIONS. Otherwise multiple Node.js debuggers\n            // would be started if user launch Next.js in debugging mode. The number of debuggers is linked to\n            // the number of workers Next.js tries to launch. The only worker users are interested in debugging\n            // is the main Next.js one\n            NODE_OPTIONS: getNodeOptionsWithoutInspect(),\n          },\n        },\n      }\n    ) as Worker & {\n      loadStaticPaths: typeof import('./static-paths-worker').loadStaticPaths\n    }\n\n    this.staticPathsWorker.getStdout().pipe(process.stdout)\n    this.staticPathsWorker.getStderr().pipe(process.stderr)\n  }\n\n  protected readBuildId(): string {\n    return 'development'\n  }\n\n  async addExportPathMapRoutes() {\n    // Makes `next export` exportPathMap work in development mode.\n    // So that the user doesn't have to define a custom server reading the exportPathMap\n    if (this.nextConfig.exportPathMap) {\n      console.log('Defining routes from exportPathMap')\n      const exportPathMap = await this.nextConfig.exportPathMap(\n        {},\n        {\n          dev: true,\n          dir: this.dir,\n          outDir: null,\n          distDir: this.distDir,\n          buildId: this.buildId,\n        }\n      ) // In development we can't give a default path mapping\n      for (const path in exportPathMap) {\n        const { page, query = {} } = exportPathMap[path]\n\n        // We use unshift so that we're sure the routes is defined before Next's default routes\n        this.router.addFsRoute({\n          match: route(path),\n          type: 'route',\n          name: `${path} exportpathmap route`,\n          fn: async (req, res, _params, parsedUrl) => {\n            const { query: urlQuery } = parsedUrl\n\n            Object.keys(urlQuery)\n              .filter((key) => query[key] === undefined)\n              .forEach((key) =>\n                console.warn(\n                  `Url '${path}' defines a query parameter '${key}' that is missing in exportPathMap`\n                )\n              )\n\n            const mergedQuery = { ...urlQuery, ...query }\n\n            await this.render(req, res, page, mergedQuery, parsedUrl)\n            return {\n              finished: true,\n            }\n          },\n        })\n      }\n    }\n  }\n\n  async startWatcher(): Promise<void> {\n    if (this.webpackWatcher) {\n      return\n    }\n\n    const regexPageExtension = new RegExp(\n      `\\\\.+(?:${this.nextConfig.pageExtensions.join('|')})$`\n    )\n\n    let resolved = false\n    return new Promise((resolve, reject) => {\n      const pagesDir = this.pagesDir\n\n      // Watchpack doesn't emit an event for an empty directory\n      fs.readdir(pagesDir!, (_, files) => {\n        if (files?.length) {\n          return\n        }\n\n        if (!resolved) {\n          resolve()\n          resolved = true\n        }\n      })\n\n      let wp = (this.webpackWatcher = new Watchpack())\n      wp.watch([], [pagesDir!], 0)\n\n      wp.on('aggregated', () => {\n        const routedPages = []\n        const knownFiles = wp.getTimeInfoEntries()\n        for (const [fileName, { accuracy }] of knownFiles) {\n          if (accuracy === undefined || !regexPageExtension.test(fileName)) {\n            continue\n          }\n\n          let pageName =\n            '/' + relative(pagesDir!, fileName).replace(/\\\\+/g, '/')\n          pageName = pageName.replace(regexPageExtension, '')\n          pageName = pageName.replace(/\\/index$/, '') || '/'\n\n          routedPages.push(pageName)\n        }\n\n        try {\n          // we serve a separate manifest with all pages for the client in\n          // dev mode so that we can match a page after a rewrite on the client\n          // before it has been built and is populated in the _buildManifest\n          const sortedRoutes = getSortedRoutes(routedPages)\n\n          if (\n            !this.sortedRoutes?.every((val, idx) => val === sortedRoutes[idx])\n          ) {\n            // emit the change so clients fetch the update\n            this.hotReloader!.send(undefined, { devPagesManifest: true })\n          }\n          this.sortedRoutes = sortedRoutes\n\n          this.dynamicRoutes = this.sortedRoutes\n            .filter(isDynamicRoute)\n            .map((page) => ({\n              page,\n              match: getRouteMatcher(getRouteRegex(page)),\n            }))\n\n          this.router.setDynamicRoutes(this.dynamicRoutes)\n\n          if (!resolved) {\n            resolve()\n            resolved = true\n          }\n        } catch (e) {\n          if (!resolved) {\n            reject(e)\n            resolved = true\n          } else {\n            console.warn('Failed to reload dynamic routes:', e)\n          }\n        }\n      })\n    })\n  }\n\n  async stopWatcher(): Promise<void> {\n    if (!this.webpackWatcher) {\n      return\n    }\n\n    this.webpackWatcher.close()\n    this.webpackWatcher = null\n  }\n\n  async prepare(): Promise<void> {\n    await verifyTypeScriptSetup(\n      this.dir,\n      this.pagesDir!,\n      false,\n      !this.nextConfig.images.disableStaticImages\n    )\n\n    this.customRoutes = await loadCustomRoutes(this.nextConfig)\n\n    // reload router\n    const { redirects, rewrites, headers } = this.customRoutes\n\n    if (\n      rewrites.beforeFiles.length ||\n      rewrites.afterFiles.length ||\n      rewrites.fallback.length ||\n      redirects.length ||\n      headers.length\n    ) {\n      this.router = new Router(this.generateRoutes())\n    }\n\n    this.hotReloader = new HotReloader(this.dir, {\n      pagesDir: this.pagesDir!,\n      config: this.nextConfig,\n      previewProps: this.getPreviewProps(),\n      buildId: this.buildId,\n      rewrites,\n    })\n    await super.prepare()\n    await this.addExportPathMapRoutes()\n    await this.hotReloader.start()\n    await this.startWatcher()\n    this.setDevReady!()\n\n    const telemetry = new Telemetry({ distDir: this.distDir })\n    telemetry.record(\n      eventCliSession(PHASE_DEVELOPMENT_SERVER, this.distDir, {\n        webpackVersion: this.hotReloader.isWebpack5 ? 5 : 4,\n        cliCommand: 'dev',\n        isSrcDir: relative(this.dir, this.pagesDir!).startsWith('src'),\n        hasNowJson: !!(await findUp('now.json', { cwd: this.dir })),\n        isCustomServer: this.isCustomServer,\n      })\n    )\n    // This is required by the tracing subsystem.\n    setGlobal('telemetry', telemetry)\n\n    process.on('unhandledRejection', (reason) => {\n      this.logErrorWithOriginalStack(reason, 'unhandledRejection').catch(\n        () => {}\n      )\n    })\n    process.on('uncaughtException', (err) => {\n      this.logErrorWithOriginalStack(err, 'uncaughtException').catch(() => {})\n    })\n  }\n\n  protected async close(): Promise<void> {\n    await this.stopWatcher()\n    await this.staticPathsWorker.end()\n    if (this.hotReloader) {\n      await this.hotReloader.stop()\n    }\n  }\n\n  protected async hasPage(pathname: string): Promise<boolean> {\n    let normalizedPath: string\n\n    try {\n      normalizedPath = normalizePagePath(pathname)\n    } catch (err) {\n      console.error(err)\n      // if normalizing the page fails it means it isn't valid\n      // so it doesn't exist so don't throw and return false\n      // to ensure we return 404 instead of 500\n      return false\n    }\n\n    const pageFile = await findPageFile(\n      this.pagesDir!,\n      normalizedPath,\n      this.nextConfig.pageExtensions\n    )\n    return !!pageFile\n  }\n\n  protected async _beforeCatchAllRender(\n    req: IncomingMessage,\n    res: ServerResponse,\n    params: Params,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<boolean> {\n    const { pathname } = parsedUrl\n    const pathParts = params.path || []\n    const path = `/${pathParts.join('/')}`\n    // check for a public file, throwing error if there's a\n    // conflicting page\n    let decodedPath: string\n\n    try {\n      decodedPath = decodeURIComponent(path)\n    } catch (_) {\n      throw new DecodeError('failed to decode param')\n    }\n\n    if (await this.hasPublicFile(decodedPath)) {\n      if (await this.hasPage(pathname!)) {\n        const err = new Error(\n          `A conflicting public file and page file was found for path ${pathname} https://nextjs.org/docs/messages/conflicting-public-file-page`\n        )\n        res.statusCode = 500\n        await this.renderError(err, req, res, pathname!, {})\n        return true\n      }\n      await this.servePublic(req, res, pathParts)\n      return true\n    }\n\n    return false\n  }\n\n  async run(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<void> {\n    await this.devReady\n\n    const { basePath } = this.nextConfig\n    let originalPathname: string | null = null\n\n    if (basePath && parsedUrl.pathname?.startsWith(basePath)) {\n      // strip basePath before handling dev bundles\n      // If replace ends up replacing the full url it'll be `undefined`, meaning we have to default it to `/`\n      originalPathname = parsedUrl.pathname\n      parsedUrl.pathname = parsedUrl.pathname!.slice(basePath.length) || '/'\n    }\n\n    const { pathname } = parsedUrl\n\n    if (pathname!.startsWith('/_next')) {\n      if (await fileExists(pathJoin(this.publicDir, '_next'))) {\n        throw new Error(PUBLIC_DIR_MIDDLEWARE_CONFLICT)\n      }\n    }\n\n    const { finished = false } = await this.hotReloader!.run(\n      req,\n      res,\n      parsedUrl\n    )\n\n    if (finished) {\n      return\n    }\n\n    if (originalPathname) {\n      // restore the path before continuing so that custom-routes can accurately determine\n      // if they should match against the basePath or not\n      parsedUrl.pathname = originalPathname\n    }\n    try {\n      return await super.run(req, res, parsedUrl)\n    } catch (err) {\n      res.statusCode = 500\n      try {\n        this.logErrorWithOriginalStack(err).catch(() => {})\n        return await this.renderError(err, req, res, pathname!, {\n          __NEXT_PAGE: err?.page || pathname,\n        })\n      } catch (internalErr) {\n        console.error(internalErr)\n        res.end('Internal Server Error')\n      }\n    }\n  }\n\n  private async logErrorWithOriginalStack(\n    possibleError?: any,\n    type?: 'unhandledRejection' | 'uncaughtException'\n  ) {\n    let usedOriginalStack = false\n\n    if (possibleError?.name && possibleError?.stack && possibleError?.message) {\n      const err: Error & { stack: string } = possibleError\n      try {\n        const frames = parseStack(err.stack)\n        const frame = frames[0]\n\n        if (frame.lineNumber && frame?.file) {\n          const compilation = this.hotReloader?.serverStats?.compilation\n          const moduleId = frame.file!.replace(\n            /^(webpack-internal:\\/\\/\\/|file:\\/\\/)/,\n            ''\n          )\n\n          const source = await getSourceById(\n            !!frame.file?.startsWith(sep) || !!frame.file?.startsWith('file:'),\n            moduleId,\n            compilation,\n            this.hotReloader!.isWebpack5\n          )\n\n          const originalFrame = await createOriginalStackFrame({\n            line: frame.lineNumber!,\n            column: frame.column,\n            source,\n            frame,\n            modulePath: moduleId,\n            rootDirectory: this.dir,\n          })\n\n          if (originalFrame) {\n            const { originalCodeFrame, originalStackFrame } = originalFrame\n            const { file, lineNumber, column, methodName } = originalStackFrame\n\n            console.error(\n              chalk.red('error') +\n                ' - ' +\n                `${file} (${lineNumber}:${column}) @ ${methodName}`\n            )\n            console.error(`${chalk.red(err.name)}: ${err.message}`)\n            console.error(originalCodeFrame)\n            usedOriginalStack = true\n          }\n        }\n      } catch (_) {\n        // failed to load original stack using source maps\n        // this un-actionable by users so we don't show the\n        // internal error and only show the provided stack\n      }\n    }\n\n    if (!usedOriginalStack) {\n      if (type) {\n        Log.error(`${type}:`, possibleError)\n      } else {\n        Log.error(possibleError)\n      }\n    }\n  }\n\n  // override production loading of routes-manifest\n  protected getCustomRoutes(): CustomRoutes {\n    // actual routes will be loaded asynchronously during .prepare()\n    return {\n      redirects: [],\n      rewrites: { beforeFiles: [], afterFiles: [], fallback: [] },\n      headers: [],\n    }\n  }\n\n  private _devCachedPreviewProps: __ApiPreviewProps | undefined\n  protected getPreviewProps() {\n    if (this._devCachedPreviewProps) {\n      return this._devCachedPreviewProps\n    }\n    return (this._devCachedPreviewProps = {\n      previewModeId: crypto.randomBytes(16).toString('hex'),\n      previewModeSigningKey: crypto.randomBytes(32).toString('hex'),\n      previewModeEncryptionKey: crypto.randomBytes(32).toString('hex'),\n    })\n  }\n\n  generateRoutes() {\n    const { fsRoutes, ...otherRoutes } = super.generateRoutes()\n\n    // In development we expose all compiled files for react-error-overlay's line show feature\n    // We use unshift so that we're sure the routes is defined before Next's default routes\n    fsRoutes.unshift({\n      match: route('/_next/development/:path*'),\n      type: 'route',\n      name: '_next/development catchall',\n      fn: async (req, res, params) => {\n        const p = pathJoin(this.distDir, ...(params.path || []))\n        await this.serveStatic(req, res, p)\n        return {\n          finished: true,\n        }\n      },\n    })\n\n    fsRoutes.unshift({\n      match: route(\n        `/_next/${CLIENT_STATIC_FILES_PATH}/${this.buildId}/${DEV_CLIENT_PAGES_MANIFEST}`\n      ),\n      type: 'route',\n      name: `_next/${CLIENT_STATIC_FILES_PATH}/${this.buildId}/${DEV_CLIENT_PAGES_MANIFEST}`,\n      fn: async (_req, res) => {\n        res.statusCode = 200\n        res.setHeader('Content-Type', 'application/json; charset=utf-8')\n        res.end(\n          JSON.stringify({\n            pages: this.sortedRoutes,\n          })\n        )\n        return {\n          finished: true,\n        }\n      },\n    })\n\n    fsRoutes.push({\n      match: route('/:path*'),\n      type: 'route',\n      requireBasePath: false,\n      name: 'catchall public directory route',\n      fn: async (req, res, params, parsedUrl) => {\n        const { pathname } = parsedUrl\n        if (!pathname) {\n          throw new Error('pathname is undefined')\n        }\n\n        // Used in development to check public directory paths\n        if (await this._beforeCatchAllRender(req, res, params, parsedUrl)) {\n          return {\n            finished: true,\n          }\n        }\n\n        return {\n          finished: false,\n        }\n      },\n    })\n\n    return { fsRoutes, ...otherRoutes }\n  }\n\n  // In development public files are not added to the router but handled as a fallback instead\n  protected generatePublicRoutes(): never[] {\n    return []\n  }\n\n  // In development dynamic routes cannot be known ahead of time\n  protected getDynamicRoutes(): never[] {\n    return []\n  }\n\n  _filterAmpDevelopmentScript(\n    html: string,\n    event: { line: number; col: number; code: string }\n  ): boolean {\n    if (event.code !== 'DISALLOWED_SCRIPT_TAG') {\n      return true\n    }\n\n    const snippetChunks = html.split('\\n')\n\n    let snippet\n    if (\n      !(snippet = html.split('\\n')[event.line - 1]) ||\n      !(snippet = snippet.substring(event.col))\n    ) {\n      return true\n    }\n\n    snippet = snippet + snippetChunks.slice(event.line).join('\\n')\n    snippet = snippet.substring(0, snippet.indexOf('</script>'))\n\n    return !snippet.includes('data-amp-development-mode-only')\n  }\n\n  protected async getStaticPaths(pathname: string): Promise<{\n    staticPaths: string[] | undefined\n    fallbackMode: false | 'static' | 'blocking'\n  }> {\n    // we lazy load the staticPaths to prevent the user\n    // from waiting on them for the page to load in dev mode\n\n    const __getStaticPaths = async () => {\n      const { publicRuntimeConfig, serverRuntimeConfig, httpAgentOptions } =\n        this.nextConfig\n      const { locales, defaultLocale } = this.nextConfig.i18n || {}\n\n      const paths = await this.staticPathsWorker.loadStaticPaths(\n        this.distDir,\n        pathname,\n        !this.renderOpts.dev && this._isLikeServerless,\n        {\n          publicRuntimeConfig,\n          serverRuntimeConfig,\n        },\n        httpAgentOptions,\n        locales,\n        defaultLocale\n      )\n      return paths\n    }\n    const { paths: staticPaths, fallback } = (\n      await withCoalescedInvoke(__getStaticPaths)(`staticPaths-${pathname}`, [])\n    ).value\n\n    return {\n      staticPaths,\n      fallbackMode:\n        fallback === 'blocking'\n          ? 'blocking'\n          : fallback === true\n          ? 'static'\n          : false,\n    }\n  }\n\n  protected async ensureApiPage(pathname: string) {\n    return this.hotReloader!.ensurePage(pathname)\n  }\n\n  protected async findPageComponents(\n    pathname: string,\n    query: ParsedUrlQuery = {},\n    params: Params | null = null\n  ): Promise<FindComponentsResult | null> {\n    await this.devReady\n    const compilationErr = await this.getCompilationError(pathname)\n    if (compilationErr) {\n      // Wrap build errors so that they don't get logged again\n      throw new WrappedBuildError(compilationErr)\n    }\n    try {\n      await this.hotReloader!.ensurePage(pathname)\n      return super.findPageComponents(pathname, query, params)\n    } catch (err) {\n      if ((err as any).code !== 'ENOENT') {\n        throw err\n      }\n      return null\n    }\n  }\n\n  protected async getFallbackErrorComponents(): Promise<LoadComponentsReturnType | null> {\n    await this.hotReloader!.buildFallbackError()\n    // Build the error page to ensure the fallback is built too.\n    // TODO: See if this can be moved into hotReloader or removed.\n    await this.hotReloader!.ensurePage('/_error')\n    return await loadDefaultErrorComponents(this.distDir)\n  }\n\n  protected setImmutableAssetCacheControl(res: ServerResponse): void {\n    res.setHeader('Cache-Control', 'no-store, must-revalidate')\n  }\n\n  private servePublic(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathParts: string[]\n  ): Promise<void> {\n    const p = pathJoin(this.publicDir, ...pathParts)\n    return this.serveStatic(req, res, p)\n  }\n\n  async hasPublicFile(path: string): Promise<boolean> {\n    try {\n      const info = await fs.promises.stat(pathJoin(this.publicDir, path))\n      return info.isFile()\n    } catch (_) {\n      return false\n    }\n  }\n\n  async getCompilationError(page: string): Promise<any> {\n    const errors = await this.hotReloader!.getCompilationErrors(page)\n    if (errors.length === 0) return\n\n    // Return the very first error we found.\n    return errors[0]\n  }\n\n  protected isServeableUrl(untrustedFileUrl: string): boolean {\n    // This method mimics what the version of `send` we use does:\n    // 1. decodeURIComponent:\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L989\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L518-L522\n    // 2. resolve:\n    //    https://github.com/pillarjs/send/blob/de073ed3237ade9ff71c61673a34474b30e5d45b/index.js#L561\n\n    let decodedUntrustedFilePath: string\n    try {\n      // (1) Decode the URL so we have the proper file name\n      decodedUntrustedFilePath = decodeURIComponent(untrustedFileUrl)\n    } catch {\n      return false\n    }\n\n    // (2) Resolve \"up paths\" to determine real request\n    const untrustedFilePath = pathResolve(decodedUntrustedFilePath)\n\n    // don't allow null bytes anywhere in the file path\n    if (untrustedFilePath.indexOf('\\0') !== -1) {\n      return false\n    }\n\n    // During development mode, files can be added while the server is running.\n    // Checks for .next/static, .next/server, static and public.\n    // Note that in development .next/server is available for error reporting purposes.\n    // see `packages/next/server/next-server.ts` for more details.\n    if (\n      untrustedFilePath.startsWith(pathJoin(this.distDir, 'static') + sep) ||\n      untrustedFilePath.startsWith(pathJoin(this.distDir, 'server') + sep) ||\n      untrustedFilePath.startsWith(pathJoin(this.dir, 'static') + sep) ||\n      untrustedFilePath.startsWith(pathJoin(this.dir, 'public') + sep)\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n"]},"metadata":{},"sourceType":"script"}