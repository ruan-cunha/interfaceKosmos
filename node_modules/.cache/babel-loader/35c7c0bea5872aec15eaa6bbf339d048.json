{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getUtils = getUtils;\nexports.vercelHeader = void 0;\n\nvar _url = require(\"url\");\n\nvar _querystring = require(\"querystring\");\n\nvar _normalizeLocalePath = require(\"../../../../shared/lib/i18n/normalize-locale-path\");\n\nvar _pathMatch = _interopRequireDefault(require(\"../../../../shared/lib/router/utils/path-match\"));\n\nvar _routeRegex = require(\"../../../../shared/lib/router/utils/route-regex\");\n\nvar _routeMatcher = require(\"../../../../shared/lib/router/utils/route-matcher\");\n\nvar _prepareDestination = _interopRequireWildcard(require(\"../../../../shared/lib/router/utils/prepare-destination\"));\n\nvar _accept = _interopRequireDefault(require(\"@hapi/accept\"));\n\nvar _detectLocaleCookie = require(\"../../../../shared/lib/i18n/detect-locale-cookie\");\n\nvar _detectDomainLocale = require(\"../../../../shared/lib/i18n/detect-domain-locale\");\n\nvar _denormalizePagePath = require(\"../../../../server/denormalize-page-path\");\n\nvar _cookie = _interopRequireDefault(require(\"next/dist/compiled/cookie\"));\n\nvar _constants = require(\"../../../../shared/lib/constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nconst getCustomRouteMatcher = (0, _pathMatch).default(true);\nconst vercelHeader = 'x-vercel-id';\nexports.vercelHeader = vercelHeader;\n\nfunction getUtils({\n  page,\n  i18n,\n  basePath,\n  rewrites,\n  pageIsDynamic\n}) {\n  let defaultRouteRegex;\n  let dynamicRouteMatcher;\n  let defaultRouteMatches;\n\n  if (pageIsDynamic) {\n    defaultRouteRegex = (0, _routeRegex).getRouteRegex(page);\n    dynamicRouteMatcher = (0, _routeMatcher).getRouteMatcher(defaultRouteRegex);\n    defaultRouteMatches = dynamicRouteMatcher(page);\n  }\n\n  function handleRewrites(req, parsedUrl) {\n    for (const rewrite of rewrites) {\n      const matcher = getCustomRouteMatcher(rewrite.source);\n      let params = matcher(parsedUrl.pathname);\n\n      if (rewrite.has && params) {\n        const hasParams = (0, _prepareDestination).matchHas(req, rewrite.has, parsedUrl.query);\n\n        if (hasParams) {\n          Object.assign(params, hasParams);\n        } else {\n          params = false;\n        }\n      }\n\n      if (params) {\n        const {\n          parsedDestination\n        } = (0, _prepareDestination).default(rewrite.destination, params, parsedUrl.query, true);\n        Object.assign(parsedUrl.query, parsedDestination.query);\n        delete parsedDestination.query;\n        Object.assign(parsedUrl, parsedDestination);\n        let fsPathname = parsedUrl.pathname;\n\n        if (basePath) {\n          fsPathname = fsPathname.replace(new RegExp(`^${basePath}`), '') || '/';\n        }\n\n        if (i18n) {\n          const destLocalePathResult = (0, _normalizeLocalePath).normalizeLocalePath(fsPathname, i18n.locales);\n          fsPathname = destLocalePathResult.pathname;\n          parsedUrl.query.nextInternalLocale = destLocalePathResult.detectedLocale || params.nextInternalLocale;\n        }\n\n        if (fsPathname === page) {\n          break;\n        }\n\n        if (pageIsDynamic && dynamicRouteMatcher) {\n          const dynamicParams = dynamicRouteMatcher(fsPathname);\n\n          if (dynamicParams) {\n            parsedUrl.query = { ...parsedUrl.query,\n              ...dynamicParams\n            };\n            break;\n          }\n        }\n      }\n    }\n\n    return parsedUrl;\n  }\n\n  function handleBasePath(req, parsedUrl) {\n    // always strip the basePath if configured since it is required\n    req.url = req.url.replace(new RegExp(`^${basePath}`), '') || '/';\n    parsedUrl.pathname = parsedUrl.pathname.replace(new RegExp(`^${basePath}`), '') || '/';\n  }\n\n  function getParamsFromRouteMatches(req, renderOpts, detectedLocale) {\n    return (0, _routeMatcher).getRouteMatcher(function () {\n      const {\n        groups,\n        routeKeys\n      } = defaultRouteRegex;\n      return {\n        re: {\n          // Simulate a RegExp match from the \\`req.url\\` input\n          exec: str => {\n            const obj = (0, _querystring).parse(str); // favor named matches if available\n\n            const routeKeyNames = Object.keys(routeKeys || {});\n\n            const filterLocaleItem = val => {\n              if (i18n) {\n                // locale items can be included in route-matches\n                // for fallback SSG pages so ensure they are\n                // filtered\n                const isCatchAll = Array.isArray(val);\n\n                const _val = isCatchAll ? val[0] : val;\n\n                if (typeof _val === 'string' && i18n.locales.some(item => {\n                  if (item.toLowerCase() === _val.toLowerCase()) {\n                    detectedLocale = item;\n                    renderOpts.locale = detectedLocale;\n                    return true;\n                  }\n\n                  return false;\n                })) {\n                  // remove the locale item from the match\n                  if (isCatchAll) {\n                    val.splice(0, 1);\n                  } // the value is only a locale item and\n                  // shouldn't be added\n\n\n                  return isCatchAll ? val.length === 0 : true;\n                }\n              }\n\n              return false;\n            };\n\n            if (routeKeyNames.every(name => obj[name])) {\n              return routeKeyNames.reduce((prev, keyName) => {\n                const paramName = routeKeys === null || routeKeys === void 0 ? void 0 : routeKeys[keyName];\n\n                if (paramName && !filterLocaleItem(obj[keyName])) {\n                  prev[groups[paramName].pos] = obj[keyName];\n                }\n\n                return prev;\n              }, {});\n            }\n\n            return Object.keys(obj).reduce((prev, key) => {\n              if (!filterLocaleItem(obj[key])) {\n                return Object.assign(prev, {\n                  [key]: obj[key]\n                });\n              }\n\n              return prev;\n            }, {});\n          }\n        },\n        groups\n      };\n    }())(req.headers['x-now-route-matches']);\n  }\n\n  function interpolateDynamicPath(pathname, params) {\n    if (!defaultRouteRegex) return pathname;\n\n    for (const param of Object.keys(defaultRouteRegex.groups)) {\n      const {\n        optional,\n        repeat\n      } = defaultRouteRegex.groups[param];\n      let builtParam = `[${repeat ? '...' : ''}${param}]`;\n\n      if (optional) {\n        builtParam = `[${builtParam}]`;\n      }\n\n      const paramIdx = pathname.indexOf(builtParam);\n\n      if (paramIdx > -1) {\n        let paramValue;\n\n        if (Array.isArray(params[param])) {\n          paramValue = params[param].map(v => v && encodeURIComponent(v)).join('/');\n        } else {\n          paramValue = params[param] && encodeURIComponent(params[param]);\n        }\n\n        pathname = pathname.substr(0, paramIdx) + (paramValue || '') + pathname.substr(paramIdx + builtParam.length);\n      }\n    }\n\n    return pathname;\n  }\n\n  function normalizeVercelUrl(req, trustQuery) {\n    // make sure to normalize req.url on Vercel to strip dynamic params\n    // from the query which are added during routing\n    if (pageIsDynamic && trustQuery && defaultRouteRegex) {\n      const _parsedUrl = (0, _url).parse(req.url, true);\n\n      delete _parsedUrl.search;\n\n      for (const param of Object.keys(defaultRouteRegex.groups)) {\n        delete _parsedUrl.query[param];\n      }\n\n      req.url = (0, _url).format(_parsedUrl);\n    }\n  }\n\n  function normalizeDynamicRouteParams(params) {\n    let hasValidParams = true;\n    if (!defaultRouteRegex) return {\n      params,\n      hasValidParams: false\n    };\n    params = Object.keys(defaultRouteRegex.groups).reduce((prev, key) => {\n      let value = params[key]; // if the value matches the default value we can't rely\n      // on the parsed params, this is used to signal if we need\n      // to parse x-now-route-matches or not\n\n      const defaultValue = defaultRouteMatches[key];\n      const isDefaultValue = Array.isArray(defaultValue) ? defaultValue.some(defaultVal => {\n        return Array.isArray(value) ? value.some(val => val.includes(defaultVal)) : value === null || value === void 0 ? void 0 : value.includes(defaultVal);\n      }) : value === null || value === void 0 ? void 0 : value.includes(defaultValue);\n\n      if (isDefaultValue || typeof value === 'undefined') {\n        hasValidParams = false;\n      } // non-provided optional values should be undefined so normalize\n      // them to undefined\n\n\n      if (defaultRouteRegex.groups[key].optional && (!value || Array.isArray(value) && value.length === 1 && (value[0] === 'index' || value[0] === `[[...${key}]]`))) {\n        value = undefined;\n        delete params[key];\n      } // query values from the proxy aren't already split into arrays\n      // so make sure to normalize catch-all values\n\n\n      if (value && typeof value === 'string' && defaultRouteRegex.groups[key].repeat) {\n        value = value.split('/');\n      }\n\n      if (value) {\n        prev[key] = value;\n      }\n\n      return prev;\n    }, {});\n    return {\n      params,\n      hasValidParams\n    };\n  }\n\n  function handleLocale(req, res, parsedUrl, routeNoAssetPath, shouldNotRedirect) {\n    if (!i18n) return;\n    const pathname = parsedUrl.pathname || '/';\n    let defaultLocale = i18n.defaultLocale;\n    let detectedLocale = (0, _detectLocaleCookie).detectLocaleCookie(req, i18n.locales);\n    let acceptPreferredLocale;\n\n    try {\n      acceptPreferredLocale = i18n.localeDetection !== false ? _accept.default.language(req.headers['accept-language'], i18n.locales) : detectedLocale;\n    } catch (_) {\n      acceptPreferredLocale = detectedLocale;\n    }\n\n    const {\n      host\n    } = req.headers || {}; // remove port from host and remove port if present\n\n    const hostname = host && host.split(':')[0].toLowerCase();\n    const detectedDomain = (0, _detectDomainLocale).detectDomainLocale(i18n.domains, hostname);\n\n    if (detectedDomain) {\n      defaultLocale = detectedDomain.defaultLocale;\n      detectedLocale = defaultLocale;\n      req.__nextIsLocaleDomain = true;\n    } // if not domain specific locale use accept-language preferred\n\n\n    detectedLocale = detectedLocale || acceptPreferredLocale;\n    let localeDomainRedirect;\n    const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(pathname, i18n.locales);\n    routeNoAssetPath = (0, _normalizeLocalePath).normalizeLocalePath(routeNoAssetPath, i18n.locales).pathname;\n\n    if (localePathResult.detectedLocale) {\n      detectedLocale = localePathResult.detectedLocale;\n      req.url = (0, _url).format({ ...parsedUrl,\n        pathname: localePathResult.pathname\n      });\n      req.__nextStrippedLocale = true;\n      parsedUrl.pathname = localePathResult.pathname;\n    } // If a detected locale is a domain specific locale and we aren't already\n    // on that domain and path prefix redirect to it to prevent duplicate\n    // content from multiple domains\n\n\n    if (detectedDomain) {\n      const localeToCheck = localePathResult.detectedLocale ? detectedLocale : acceptPreferredLocale;\n      const matchedDomain = (0, _detectDomainLocale).detectDomainLocale(i18n.domains, undefined, localeToCheck);\n\n      if (matchedDomain && matchedDomain.domain !== detectedDomain.domain) {\n        localeDomainRedirect = `http${matchedDomain.http ? '' : 's'}://${matchedDomain.domain}/${localeToCheck === matchedDomain.defaultLocale ? '' : localeToCheck}`;\n      }\n    }\n\n    const denormalizedPagePath = (0, _denormalizePagePath).denormalizePagePath(pathname);\n    const detectedDefaultLocale = !detectedLocale || detectedLocale.toLowerCase() === defaultLocale.toLowerCase();\n    const shouldStripDefaultLocale = false; // detectedDefaultLocale &&\n    // denormalizedPagePath.toLowerCase() === \\`/\\${i18n.defaultLocale.toLowerCase()}\\`\n\n    const shouldAddLocalePrefix = !detectedDefaultLocale && denormalizedPagePath === '/';\n    detectedLocale = detectedLocale || i18n.defaultLocale;\n\n    if (!shouldNotRedirect && !req.headers[vercelHeader] && i18n.localeDetection !== false && (localeDomainRedirect || shouldAddLocalePrefix || shouldStripDefaultLocale)) {\n      // set the NEXT_LOCALE cookie when a user visits the default locale\n      // with the locale prefix so that they aren't redirected back to\n      // their accept-language preferred locale\n      if (shouldStripDefaultLocale && acceptPreferredLocale !== defaultLocale) {\n        const previous = res.getHeader('set-cookie');\n        res.setHeader('set-cookie', [...(typeof previous === 'string' ? [previous] : Array.isArray(previous) ? previous : []), _cookie.default.serialize('NEXT_LOCALE', defaultLocale, {\n          httpOnly: true,\n          path: '/'\n        })]);\n      }\n\n      res.setHeader('Location', (0, _url).format({ // make sure to include any query values when redirecting\n        ...parsedUrl,\n        pathname: localeDomainRedirect ? localeDomainRedirect : shouldStripDefaultLocale ? basePath || '/' : `${basePath}/${detectedLocale}`\n      }));\n      res.statusCode = _constants.TEMPORARY_REDIRECT_STATUS;\n      res.end();\n      return;\n    }\n\n    detectedLocale = localePathResult.detectedLocale || detectedDomain && detectedDomain.defaultLocale || defaultLocale;\n    return {\n      defaultLocale,\n      detectedLocale,\n      routeNoAssetPath\n    };\n  }\n\n  return {\n    handleLocale,\n    handleRewrites,\n    handleBasePath,\n    defaultRouteRegex,\n    normalizeVercelUrl,\n    dynamicRouteMatcher,\n    defaultRouteMatches,\n    interpolateDynamicPath,\n    getParamsFromRouteMatches,\n    normalizeDynamicRouteParams\n  };\n}","map":{"version":3,"sources":["../../../../../build/webpack/loaders/next-serverless-loader/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { IncomingMessage, ServerResponse } from 'http'\nimport { format as formatUrl, UrlWithParsedQuery, parse as parseUrl } from 'url'\nimport { parse as parseQs, ParsedUrlQuery } from 'querystring'\nimport { Rewrite } from '../../../../lib/load-custom-routes'\nimport { normalizeLocalePath } from '../../../../shared/lib/i18n/normalize-locale-path'\nimport pathMatch from '../../../../shared/lib/router/utils/path-match'\nimport { getRouteRegex } from '../../../../shared/lib/router/utils/route-regex'\nimport { getRouteMatcher } from '../../../../shared/lib/router/utils/route-matcher'\nimport prepareDestination, {\n  matchHas,\n} from '../../../../shared/lib/router/utils/prepare-destination'\nimport { __ApiPreviewProps } from '../../../../server/api-utils'\nimport { BuildManifest } from '../../../../server/get-page-files'\nimport {\n  GetServerSideProps,\n  GetStaticPaths,\n  GetStaticProps,\n} from '../../../../types'\nimport accept from '@hapi/accept'\nimport { detectLocaleCookie } from '../../../../shared/lib/i18n/detect-locale-cookie'\nimport { detectDomainLocale } from '../../../../shared/lib/i18n/detect-domain-locale'\nimport { denormalizePagePath } from '../../../../server/denormalize-page-path'\nimport cookie from 'next/dist/compiled/cookie'\nimport { TEMPORARY_REDIRECT_STATUS } from '../../../../shared/lib/constants'\nimport { NextConfig } from '../../../../server/config'\n\nconst getCustomRouteMatcher = pathMatch(true)\n\nexport const vercelHeader = 'x-vercel-id'\n\nexport type ServerlessHandlerCtx = {\n  page: string\n\n  pageModule: any\n  pageComponent?: any\n  pageConfig?: any\n  pageGetStaticProps?: GetStaticProps\n  pageGetStaticPaths?: GetStaticPaths\n  pageGetServerSideProps?: GetServerSideProps\n\n  appModule?: any\n  errorModule?: any\n  documentModule?: any\n  notFoundModule?: any\n\n  runtimeConfig: any\n  buildManifest?: BuildManifest\n  reactLoadableManifest?: any\n  basePath: string\n  rewrites: Rewrite[]\n  pageIsDynamic: boolean\n  generateEtags: boolean\n  distDir: string\n  buildId: string\n  escapedBuildId: string\n  assetPrefix: string\n  poweredByHeader: boolean\n  canonicalBase: string\n  encodedPreviewProps: __ApiPreviewProps\n  i18n?: NextConfig['i18n']\n}\n\nexport function getUtils({\n  page,\n  i18n,\n  basePath,\n  rewrites,\n  pageIsDynamic,\n}: {\n  page: ServerlessHandlerCtx['page']\n  i18n?: ServerlessHandlerCtx['i18n']\n  basePath: ServerlessHandlerCtx['basePath']\n  rewrites: ServerlessHandlerCtx['rewrites']\n  pageIsDynamic: ServerlessHandlerCtx['pageIsDynamic']\n}) {\n  let defaultRouteRegex: ReturnType<typeof getRouteRegex> | undefined\n  let dynamicRouteMatcher: ReturnType<typeof getRouteMatcher> | undefined\n  let defaultRouteMatches: ParsedUrlQuery | undefined\n\n  if (pageIsDynamic) {\n    defaultRouteRegex = getRouteRegex(page)\n    dynamicRouteMatcher = getRouteMatcher(defaultRouteRegex)\n    defaultRouteMatches = dynamicRouteMatcher(page) as ParsedUrlQuery\n  }\n\n  function handleRewrites(req: IncomingMessage, parsedUrl: UrlWithParsedQuery) {\n    for (const rewrite of rewrites) {\n      const matcher = getCustomRouteMatcher(rewrite.source)\n      let params = matcher(parsedUrl.pathname)\n\n      if (rewrite.has && params) {\n        const hasParams = matchHas(req, rewrite.has, parsedUrl.query)\n\n        if (hasParams) {\n          Object.assign(params, hasParams)\n        } else {\n          params = false\n        }\n      }\n\n      if (params) {\n        const { parsedDestination } = prepareDestination(\n          rewrite.destination,\n          params,\n          parsedUrl.query,\n          true\n        )\n\n        Object.assign(parsedUrl.query, parsedDestination.query)\n        delete (parsedDestination as any).query\n\n        Object.assign(parsedUrl, parsedDestination)\n\n        let fsPathname = parsedUrl.pathname\n\n        if (basePath) {\n          fsPathname =\n            fsPathname!.replace(new RegExp(`^${basePath}`), '') || '/'\n        }\n\n        if (i18n) {\n          const destLocalePathResult = normalizeLocalePath(\n            fsPathname!,\n            i18n.locales\n          )\n          fsPathname = destLocalePathResult.pathname\n          parsedUrl.query.nextInternalLocale =\n            destLocalePathResult.detectedLocale || params.nextInternalLocale\n        }\n\n        if (fsPathname === page) {\n          break\n        }\n\n        if (pageIsDynamic && dynamicRouteMatcher) {\n          const dynamicParams = dynamicRouteMatcher(fsPathname)\n          if (dynamicParams) {\n            parsedUrl.query = {\n              ...parsedUrl.query,\n              ...dynamicParams,\n            }\n            break\n          }\n        }\n      }\n    }\n\n    return parsedUrl\n  }\n\n  function handleBasePath(req: IncomingMessage, parsedUrl: UrlWithParsedQuery) {\n    // always strip the basePath if configured since it is required\n    req.url = req.url!.replace(new RegExp(`^${basePath}`), '') || '/'\n    parsedUrl.pathname =\n      parsedUrl.pathname!.replace(new RegExp(`^${basePath}`), '') || '/'\n  }\n\n  function getParamsFromRouteMatches(\n    req: IncomingMessage,\n    renderOpts?: any,\n    detectedLocale?: string\n  ) {\n    return getRouteMatcher(\n      (function () {\n        const { groups, routeKeys } = defaultRouteRegex!\n\n        return {\n          re: {\n            // Simulate a RegExp match from the \\`req.url\\` input\n            exec: (str: string) => {\n              const obj = parseQs(str)\n\n              // favor named matches if available\n              const routeKeyNames = Object.keys(routeKeys || {})\n\n              const filterLocaleItem = (val: string | string[]) => {\n                if (i18n) {\n                  // locale items can be included in route-matches\n                  // for fallback SSG pages so ensure they are\n                  // filtered\n                  const isCatchAll = Array.isArray(val)\n                  const _val = isCatchAll ? val[0] : val\n\n                  if (\n                    typeof _val === 'string' &&\n                    i18n.locales.some((item) => {\n                      if (item.toLowerCase() === _val.toLowerCase()) {\n                        detectedLocale = item\n                        renderOpts.locale = detectedLocale\n                        return true\n                      }\n                      return false\n                    })\n                  ) {\n                    // remove the locale item from the match\n                    if (isCatchAll) {\n                      ;(val as string[]).splice(0, 1)\n                    }\n\n                    // the value is only a locale item and\n                    // shouldn't be added\n                    return isCatchAll ? val.length === 0 : true\n                  }\n                }\n                return false\n              }\n\n              if (routeKeyNames.every((name) => obj[name])) {\n                return routeKeyNames.reduce((prev, keyName) => {\n                  const paramName = routeKeys?.[keyName]\n\n                  if (paramName && !filterLocaleItem(obj[keyName])) {\n                    prev[groups[paramName].pos] = obj[keyName]\n                  }\n                  return prev\n                }, {} as any)\n              }\n\n              return Object.keys(obj).reduce((prev, key) => {\n                if (!filterLocaleItem(obj[key])) {\n                  return Object.assign(prev, {\n                    [key]: obj[key],\n                  })\n                }\n                return prev\n              }, {})\n            },\n          },\n          groups,\n        }\n      })() as any\n    )(req.headers['x-now-route-matches'] as string) as ParsedUrlQuery\n  }\n\n  function interpolateDynamicPath(pathname: string, params: ParsedUrlQuery) {\n    if (!defaultRouteRegex) return pathname\n\n    for (const param of Object.keys(defaultRouteRegex.groups)) {\n      const { optional, repeat } = defaultRouteRegex.groups[param]\n      let builtParam = `[${repeat ? '...' : ''}${param}]`\n\n      if (optional) {\n        builtParam = `[${builtParam}]`\n      }\n\n      const paramIdx = pathname!.indexOf(builtParam)\n\n      if (paramIdx > -1) {\n        let paramValue: string\n\n        if (Array.isArray(params[param])) {\n          paramValue = (params[param] as string[])\n            .map((v) => v && encodeURIComponent(v))\n            .join('/')\n        } else {\n          paramValue =\n            params[param] && encodeURIComponent(params[param] as string)\n        }\n\n        pathname =\n          pathname.substr(0, paramIdx) +\n          (paramValue || '') +\n          pathname.substr(paramIdx + builtParam.length)\n      }\n    }\n\n    return pathname\n  }\n\n  function normalizeVercelUrl(req: IncomingMessage, trustQuery: boolean) {\n    // make sure to normalize req.url on Vercel to strip dynamic params\n    // from the query which are added during routing\n    if (pageIsDynamic && trustQuery && defaultRouteRegex) {\n      const _parsedUrl = parseUrl(req.url!, true)\n      delete (_parsedUrl as any).search\n\n      for (const param of Object.keys(defaultRouteRegex.groups)) {\n        delete _parsedUrl.query[param]\n      }\n      req.url = formatUrl(_parsedUrl)\n    }\n  }\n\n  function normalizeDynamicRouteParams(params: ParsedUrlQuery) {\n    let hasValidParams = true\n    if (!defaultRouteRegex) return { params, hasValidParams: false }\n\n    params = Object.keys(defaultRouteRegex.groups).reduce((prev, key) => {\n      let value: string | string[] | undefined = params[key]\n\n      // if the value matches the default value we can't rely\n      // on the parsed params, this is used to signal if we need\n      // to parse x-now-route-matches or not\n      const defaultValue = defaultRouteMatches![key]\n\n      const isDefaultValue = Array.isArray(defaultValue)\n        ? defaultValue.some((defaultVal) => {\n            return Array.isArray(value)\n              ? value.some((val) => val.includes(defaultVal))\n              : value?.includes(defaultVal)\n          })\n        : value?.includes(defaultValue as string)\n\n      if (isDefaultValue || typeof value === 'undefined') {\n        hasValidParams = false\n      }\n\n      // non-provided optional values should be undefined so normalize\n      // them to undefined\n      if (\n        defaultRouteRegex!.groups[key].optional &&\n        (!value ||\n          (Array.isArray(value) &&\n            value.length === 1 &&\n            // fallback optional catch-all SSG pages have\n            // [[...paramName]] for the root path on Vercel\n            (value[0] === 'index' || value[0] === `[[...${key}]]`)))\n      ) {\n        value = undefined\n        delete params[key]\n      }\n\n      // query values from the proxy aren't already split into arrays\n      // so make sure to normalize catch-all values\n      if (\n        value &&\n        typeof value === 'string' &&\n        defaultRouteRegex!.groups[key].repeat\n      ) {\n        value = value.split('/')\n      }\n\n      if (value) {\n        prev[key] = value\n      }\n      return prev\n    }, {} as ParsedUrlQuery)\n\n    return {\n      params,\n      hasValidParams,\n    }\n  }\n\n  function handleLocale(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery,\n    routeNoAssetPath: string,\n    shouldNotRedirect: boolean\n  ) {\n    if (!i18n) return\n    const pathname = parsedUrl.pathname || '/'\n\n    let defaultLocale = i18n.defaultLocale\n    let detectedLocale = detectLocaleCookie(req, i18n.locales)\n    let acceptPreferredLocale\n    try {\n      acceptPreferredLocale =\n        i18n.localeDetection !== false\n          ? accept.language(req.headers['accept-language'], i18n.locales)\n          : detectedLocale\n    } catch (_) {\n      acceptPreferredLocale = detectedLocale\n    }\n\n    const { host } = req.headers || {}\n    // remove port from host and remove port if present\n    const hostname = host && host.split(':')[0].toLowerCase()\n\n    const detectedDomain = detectDomainLocale(i18n.domains, hostname)\n    if (detectedDomain) {\n      defaultLocale = detectedDomain.defaultLocale\n      detectedLocale = defaultLocale\n      ;(req as any).__nextIsLocaleDomain = true\n    }\n\n    // if not domain specific locale use accept-language preferred\n    detectedLocale = detectedLocale || acceptPreferredLocale\n\n    let localeDomainRedirect\n    const localePathResult = normalizeLocalePath(pathname, i18n.locales)\n\n    routeNoAssetPath = normalizeLocalePath(\n      routeNoAssetPath,\n      i18n.locales\n    ).pathname\n\n    if (localePathResult.detectedLocale) {\n      detectedLocale = localePathResult.detectedLocale\n      req.url = formatUrl({\n        ...parsedUrl,\n        pathname: localePathResult.pathname,\n      })\n      ;(req as any).__nextStrippedLocale = true\n      parsedUrl.pathname = localePathResult.pathname\n    }\n\n    // If a detected locale is a domain specific locale and we aren't already\n    // on that domain and path prefix redirect to it to prevent duplicate\n    // content from multiple domains\n    if (detectedDomain) {\n      const localeToCheck = localePathResult.detectedLocale\n        ? detectedLocale\n        : acceptPreferredLocale\n\n      const matchedDomain = detectDomainLocale(\n        i18n.domains,\n        undefined,\n        localeToCheck\n      )\n\n      if (matchedDomain && matchedDomain.domain !== detectedDomain.domain) {\n        localeDomainRedirect = `http${matchedDomain.http ? '' : 's'}://${\n          matchedDomain.domain\n        }/${localeToCheck === matchedDomain.defaultLocale ? '' : localeToCheck}`\n      }\n    }\n\n    const denormalizedPagePath = denormalizePagePath(pathname)\n    const detectedDefaultLocale =\n      !detectedLocale ||\n      detectedLocale.toLowerCase() === defaultLocale.toLowerCase()\n    const shouldStripDefaultLocale = false\n    // detectedDefaultLocale &&\n    // denormalizedPagePath.toLowerCase() === \\`/\\${i18n.defaultLocale.toLowerCase()}\\`\n\n    const shouldAddLocalePrefix =\n      !detectedDefaultLocale && denormalizedPagePath === '/'\n\n    detectedLocale = detectedLocale || i18n.defaultLocale\n\n    if (\n      !shouldNotRedirect &&\n      !req.headers[vercelHeader] &&\n      i18n.localeDetection !== false &&\n      (localeDomainRedirect ||\n        shouldAddLocalePrefix ||\n        shouldStripDefaultLocale)\n    ) {\n      // set the NEXT_LOCALE cookie when a user visits the default locale\n      // with the locale prefix so that they aren't redirected back to\n      // their accept-language preferred locale\n      if (shouldStripDefaultLocale && acceptPreferredLocale !== defaultLocale) {\n        const previous = res.getHeader('set-cookie')\n\n        res.setHeader('set-cookie', [\n          ...(typeof previous === 'string'\n            ? [previous]\n            : Array.isArray(previous)\n            ? previous\n            : []),\n          cookie.serialize('NEXT_LOCALE', defaultLocale, {\n            httpOnly: true,\n            path: '/',\n          }),\n        ])\n      }\n\n      res.setHeader(\n        'Location',\n        formatUrl({\n          // make sure to include any query values when redirecting\n          ...parsedUrl,\n          pathname: localeDomainRedirect\n            ? localeDomainRedirect\n            : shouldStripDefaultLocale\n            ? basePath || '/'\n            : `${basePath}/${detectedLocale}`,\n        })\n      )\n      res.statusCode = TEMPORARY_REDIRECT_STATUS\n      res.end()\n      return\n    }\n\n    detectedLocale =\n      localePathResult.detectedLocale ||\n      (detectedDomain && detectedDomain.defaultLocale) ||\n      defaultLocale\n\n    return {\n      defaultLocale,\n      detectedLocale,\n      routeNoAssetPath,\n    }\n  }\n\n  return {\n    handleLocale,\n    handleRewrites,\n    handleBasePath,\n    defaultRouteRegex,\n    normalizeVercelUrl,\n    dynamicRouteMatcher,\n    defaultRouteMatches,\n    interpolateDynamicPath,\n    getParamsFromRouteMatches,\n    normalizeDynamicRouteParams,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}